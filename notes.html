<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Level up your front end development</title>

	<style>
		.incomplete {
			background: red;
			color: white;
		}

		.needs-example {
			background: blue;
			color: white;
		}

		.in-draft {
			background: #74f7f0e3;
			color: #666;
		}

		.needs-review {
			background: #aaf3aa;
		}
	</style>
</head>
<body>
	<h1>Level up your front end development</h1>

	<div>Contents</div>
	<ul>
		<li><a href="#disclaimer">Disclaimer</a></li>
		<li><a href="#clean-code">Clean code</a></li>
		<li><a href="#modern-javascript">Modern JavaScript</a></li>
		<li><a href="#architecting-applications">Architecting applications</a></li>
		<li><a href="#testing">Testing</a></li>
		<li><a href="#semantic-html">Semantic HTML & accessibility</a></li>
		<li><a href="#understanding-css">Understanding CSS</a></li>
		<li><a href="#css-layouts">CSS layouts</a></li>
		<li><a href="#conclusion">Wrap up</a></li>
	</ul>

	<section class="needs-review">
		<h2 id="disclaimer">Disclaimer</h2>

		<p>
			This workshop contains a bunch of stuff that I think is important to understand to become a 
			good front end developer. Some of it - like how <code>Array.prototype.reduce</code> works - is 
			fact. However, some of it - like when you should create a function - is my opinion, based on 
			experience. And some of it - like <span class="needs-example">rule of thumb</span> is a good rule of 
			thumb, but doesn't apply in all situations.
		</p>

		<p>
			The point isn't to memorise everything here and apply it exactly as described. The point is that these 
			are things that you should think about, and work out the best approach for your situation. Code written 
			for production in an enterprise organisation demands much different standards than code written at home 
			to try and learn a new topic. You need to work out what's going to be most helpful for you and your team.
		</p>

		<p>
			That said, the opinions given here should give you a decent starting point. If you don't currently have 
			an opinion on one of the topics we discuss here, feel free to just take mine and use it, while you work 
			out your own. And if you do already have an opinion, I'd encourage you to think about <i>why</i> you have 
			that opinion, and if there's anything else you might want to consider. (Even if your opinion agrees with 
			mine!)
		</p>
	</section>

	<section class="needs-review">
		<h2 id="clean-code">Clean code</h2>

		<p>
			Clean code is code that is easy to understand and maintain. The term comes from the book 
			<i>Clean Code</i> by Robert Martin. Writing clean code is about going beyond writing code that 
  		<i>works</i>, to writing coding that is great for the next person to work on. As Martin Fowler says
		</p>

		<blockquote>
			Any fool can write code that a computer can understand. 
			Good programmers write code that humans can understand.
		</blockquote>

		<p>
			Clean code
		</p>
		<ul>
			<li>makes its intent clear</li>
			<li>doesn't do unexpected things</li>
			<li>is broken up logically</li>
		</ul>

		<h3>Signalling intent & self-documenting code</h3>

		<p>
			According to a 1979 study (quoted in Steve McConnell's <i>Code Complete</i>)
			<q>understanding the original programmer's intent was the most difficult problem</q>.
			Working out what the previous dev was trying to do is usually key to understanding bugs, 
			and is also important when adding new features, or updating existing ones. Fortunately, there 
			are a bunch of different options available to us to try and express our intent. 
		</p>

		<p>Here's a couple of options, ranked by some important factors</p>

		<table>
			<th>
				<td></td><td>low</td><td>medium</td><td>high</td>
			</th>
			<tr>
				<td>discoverability</td>
				<td>
					<div class="doc external" aria-label="external docs"></div>
				</td>
				<td>
					<div class="doc readme" aria-label="readme"></div>
				</td>
				<td>
					<div class="doc comments" aria-label="code comments"></div>
					<div class="doc code" aria-label="code itself"></div>
				</td>
			</tr>
			<tr>
				<td>finding the relevant information</td>
				<td></td>
				<td>
					<div class="doc external" aria-label="external docs"></div>
					<div class="doc readme" aria-label="readme"></div>
				</td>
				<td>
					<div class="doc comments" aria-label="code comments"></div>
					<div class="doc code" aria-label="code itself"></div>	
				</td>
			</tr>
			<tr>
				<td>confidence it's up-to-date</td>
				<td><div class="doc external" aria-label="external docs"></div></td>
				<td>
					<div class="doc readme" aria-label="readme"></div>
					<div class="doc comments" aria-label="code comments"></div>
				</td>
				<td>
					<div class="doc code" aria-label="code itself"></div>
				</td>
			</tr>
		</table>
		<table>
			<thead>Key</thead>
			<tr><th>External documentation</th><td><div class="doc external"></div></td></tr>
			<tr><th>README</th><td><div class="doc readme"></div></td></tr>
			<tr><th>Code comments</th><td><div class="doc comments"></div></td></tr>
			<tr><th>Code itself</th><td><div class="doc code"></div></td></tr>
		</table>

		<p>
			As you can see from the table above, the closer to the code your documentation is,
			the easier it is to discover, the easier it is to find the relevant information, and 
			the easier it is to trust that it's been kept up-to-date and relevant. The logical 
			conclusion of this is that the code itself is the best way to signal your intent.
		</p>

		<p>
			Of course, not all code is actually good at signalling intent, so we're going to look
			at some things you can do to help with this.
		</p>

		<h4>Use names that are descriptive, concise and unambiguous</h4>

		<ul>
			<li>
				<strong>Don't use acronyms or abbreviations.</strong> It might be obvious to you what you
				mean, but will it be obvious to the next developer? What if they're a junior? Or someone who
				is new to the domain? I've been working at my current employer for over a year now, and I still 
				have no idea what MIRN stands for. Even in cases where someone could work out what the abbreviation 
				stood for, you're making them use extra brain-power, and they might need that brain-power for 
				something that's legitimately difficult. Just use the whole word - your IDE can autocomplete it for 
				you if the typing gets too much.
			</li>
			<li>
				<strong>Don't add superfluous junk to your names.</strong> Don't add type suffixes, like Obj, 
				Str, or Arr. For a start, they're abbreviations, and we already agreed not to use abbreviations.
				But also, your IDE knows the type. It can tell you everything you need to know.
			</li>
			<li>
				<strong>Avoid generic names</strong>. Names like <code>data</code>, <code>items</code>, 
				<code>x</code> don't convey any meaning. Pick something descriptive. (I usually make an 
				exception to this rule for loop indices - I think <code>i</code> is commonly-enough understood 
				as a loop index to cause no confusion. That said, I rarely use loop indices, as we'll see later on.)
			</li>
			<li>
				<strong>Name things consistently.</strong> A <code>message</code> and a <code>notification</code> should 
				be different things. Using synonyms to refer to the same object just adds ambiguity to your code. It's 
				not clear to a new developer whether those things refer to the same thing, or which name they should use 
				for the new thing that they're creating.
			</li>
		</ul>

		<h4>Don't be surprising</h4>

		<ul>
			<li>
				<strong>Functions should do what they say they do.</strong> I shouldn't need to read through your 
				function to work out what it does. As we already discussed, it should have a descriptive, concise, 
				and unambiguous name. But you also need to make sure it doesn't do anything <i>else</i>. <div class="needs-example">
					an example of a function with an unintended side-effect
				</div>
			</li>
			<li>
				<strong>Don't reuse variables</strong>, even if the two uses seem similar. Discovering that a variable 
				suddenly refers to something else is surprising, and not the good kind. <div class="needs-example">
					example of reusing variables that we should avoid
				</div>
			</li>
			<li>
				<strong>Follow established patterns.</strong> Human brains are good at optimising for patterns. Ensuring
				your code follows established patterns makes it easier to process. This could mean project-specific things,
				like following established punctation and indenting rules, or maintaing the existing file structure.
				But it can also mean following more generic patterns. If you have a status called <code>ENABLED</code>,
				then the opposite is <code>DISABLED</code>, not <code>OFF</code>, or <code>OUT</code> or anthing else. 
				Similarly, if you have function called <code>login()</code>, then its partner should be <code>logout()</code>,
				not <code>logOut()</code>, or <code>signout()</code>, or anything else.
			</li>
		</ul>

		<h3>Increase your signal-to-noise ratio</h3>

		<p>
			The signal-to-noise ratio refers to how much of your code conveys actual meaning to the reader, compared
			to the amount that is just boilerplate, or repeating something that's been conveyed elsewhere. 
			Meaningless code is all that stuff that you just skip over when you're reading the code, because it's
			not helpful.
		</p>

		<p>
			We can improve the signal-to-noise ratio by either increasing the signal (adding meaning), or reducing
			the noise (removing the useless stuff). (Or, ideally, both!)
		</p>

		<p>
			Often, you can increase the signal-to-noise ratio by reducing the amount of code that you write.
			Code like
		</p>

		<pre><code>
let isParentNode;
if (hasChildren(node)) {
	isParentNode = true;
} else {
	isParentNode = false;
}
		</code></pre>

		<p>can be greatly simplified down to</p>

		<pre><code>const isParentNode = hasChildren(node)</code></pre>

		<p>
			It's not always quite as obvious as this, but it's worth keeping an eye out for this pattern. 
			Often, your IDE or linter can spot (and autofix) things like this for you.
		</p>

		<p>
			Another way you can increase the signal to noise ratio, is by moving the "noise" away from the signal.
			For example, imagine we had a function like the following, which checks if a file is valid, and 
			then posts it to the server if it is:
		</p>

		<pre><code>
				const match = file.name.match(/\.[a-z]+$/);
				let extension;
				if (match && match.length > 0) {
					extension = match[0];
				} 
				let valid;
				if (extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'svg') {
					valid = true;
				}
				if (file.size > MAX_SIZE) {
					valid = false;
				}
				if (valid) {
					const formData = new FormData();
					formData.append('files[]', file);
					fetch(URL, {
						method: 'POST',
						body: formData,
					})
				}
		</code></pre>

		<p>
			You can probably make out what's going on, but it's not... great. We can improve it by moving the "noise"
			of the implementation details away from the main decision flow.
		</p>


		<pre><code>
			...
			
			if (isFileValid(file.name, file.size)) {
				sendFile(file);
			}

			...

			function isFileValid(name, size) {
				const match = filename.match(/\.[a-z]+$/);
				let extension;
				if (match && match.length > 0) {
					extension = match[0];
				} 

				const validFileTypes = ['jpg', 'jpeg', 'png', 'svg'];
				let valid = validFileTypes.includes(extension);

				if (fileSize > MAX_SIZE) {
					valid = false;
				}
			}

			function sendFile(file) {
				const formData = new FormData();
				formData.append('files[]', file);
				fetch(URL, {
					method: 'POST',
					body: formData,
				})
			}
		</code></pre>

		<p>
			Here, the function names act like a kind of outline of what's going on: if the file is valid, 
			then send it. If we need to know the details about how we determine if a file is valid, or how 
			we send a file, then we can look inside the functions. But generally, when you're reading code, 
			you're looking for a high level overview, then dipping into a deeper level when you get to the bit 
			that interests you. Structuring your code with functions that hide implementation details like this 
			makes that easier to do.
		</p>

		<p>
			We've also added meaning in the file validation code by replacing the lengthy if statement with 
		</p>

		<pre><code>
			const validFileTypes = ['jpg', 'jpeg', 'png', 'svg'];
			let valid = validFileTypes.includes(extension);
		</code></pre>

		<p>
			Adding the <code>validFileTypes</code> variable adds extra meaning to our code, and the list check is 
			much shorter, and easier to read, than the if statement. Plus, it's now easier to add or remove valid
			file types.
		</p>

		<p class="needs-example">
			There are also a few techniques we can use to reduce the noise in our code. For example, heavy 
			indenting adds a lot of noise and makes your code harder to understand. Reducing indenting by 
			factoring out to functions and returning early can make it much eaiser to follow.
		</p>

		<pre><code>
			deeply nested code
		</code></pre>

		<p class="needs-example">Instead, we can just do all our validity checks up front...</p>

		<pre><code>
			returning early
		</code></pre>

		<p>
			Using JavaScript idioms is another way to potentially reduce noise in code. For example, something 
			like 
		</p>

		<pre><code>
			let name = user.getName();
			if (name === undefined) {
				name = 'hey you';
			}
		</code></pre>

		<p>
			can be simplified to
		</p>

		<pre><code>
				const name = user.getName() || 'hey you';
		</code></pre>

		<p>
			(If you're not familiar with the <code>||</code> shortcut, in JavaScript <code>||</code> returns the first truthy value,
			or the last value, if none of them are truthy. In this case, if <code>user.getName()</code> returns a value, then we'll get that 
			value. Otherwise, we'll get 'hey you'.)
		</p>

		<p>
			A couple of things to keep in mind when using idioms like this though:
		</p>
		<ul>
			<li>
				The two code snippets aren't exactly equivalent. The second version will replace any falsey value with 'you' - including null, or 
				empty string. In this case, this is probably the behaviour that you want, and the second version is actually more robust. This 
				won't always be the case though.
			</li>
			<li>
				You're aiming to make the code easier to understand. Sometimes there is a fine line between idiomatic code and "clever" code, which 
				is short, but difficult to understand. For example, nested ternary operators might make your code shorter than using if statements, 
				but they're almost certainly more difficult to understand. If you're not sure - ask someone else to have a look!
			</li>
		</ul>

		<p>
			Here are a few more JavaScript idioms you should be familiar with:
		</p>

		<ul>
			<li>Using <code>||</code> to set defaults (like we did above)</li>
			<li>
				Using <code>&&</code> for null-checking. <code>&&</code> will return the first falsey value, or the last value if all values are truthy.
				So, we can do null-checking like
				<pre><code>const name = user && user.name && user.name.firstName;</code></pre>
				If either <code>user</code> or <code>user.name</code> are null or undefined, then <code>name</code> will be null or undefined. Otherwise, 
				it will have the value of <code>user.name.firstName</code>
			</li>
			<li>
				Convert to boolean via <code>!!</code>. The negation operator (<code>!</code>) converts a value to boolean. So 
				<code>!someTruthyValue</code> equals <code>false</code>. <code>!!</code> sets it back to the boolean equivalent of its initial value.
				So <code>!!someTruthyValue</code> equals <code>true</code>.
			</li>
			<li>
				You can convert a string to a number using unary <code>+</code>.
				<pre><code>const age = +document.getElementById('age').value;</code></pre>
				Converting a non-numeric value will result in <code>NaN</code>, so make sure your code includes the appropriate checks.
			</li>
			<li>
				Creating a copy via JSON. Generally speaking, the fastest way to make a copy of an object in JavaScript is to use
				<pre><code>const copy = JSON.parse(JSON.stringify(myObjectToCopy))</code></pre>
				Yes, it looks like a hack, but it's such a common use case that browsers have actually optimised it to be faster.
				Just bear in mind that if your object has any function properties, those won't be stringified, so they won't appear in the copy. If you 
				want to make a copy of an object with function properties, you can use object destructuring
				<pre><code>const copy = {...myObjectToCopy}</code></pre>. However, this will only create a shallow copy! (We'll look into object 
				destructuring a bit more later).
			</li>
		</ul>

		<h3>Don't repeat yourself</h3>

		<p>
			Perhaps the most effective way you can reduce noise in your code, though, is by DRYing out your code. If you've not heard of DRY before, it stands 
			for "Don't Repeat Yourself". At its most fundamental, this means that you shouldn't implement the same logic twice in your code. Instead, factor 
			the repeated logic out into a function, class, or module.
		</p>

		<p>
			There are several reasons why you want to avoid repeated logic in your code.
		</p>

		<ul>
			<li>More code means more things that can go wrong</li>
			<li>Having logic implemented in multiple places means it's more work to update it when things change</li>
			<li>Similarly, it's more work to fix bugs, as they will need to be fixed multiple times</li>
			<li>
				There is a high risk that your implementations will get out of sync. This is particularly problematic as there is 
				no way for future devs to know which implementation is correct, or why they're different.
			</li>
		</ul>

		<pre class="needs-example"><code>
			an example where DRYing code makes it better
		</code></pre>

		<p>
			Be careful when you're DRYing out your code that the logic you're coalescing really is the same logic. If the new function takes in a 
			lot of parameters, which then get used in a lot of conditionals, there's a good chance the logic is actually different.
		</p>

		<pre class="needs-example"><code>
			an example of logic that wasn't really the same so DRYing it didn't help
		</code></pre>

		<p>
			And it's not just code you should be thinking about. Comments which repeat the same information as the code gives us suffer from the 
			same problems as repeated logic. They don't add any real value, and they run the risk of getting out of sync and actually providing 
			negative value.
		</p>

		<pre class="needs-example"><code>good comments and bad comments</code></pre>

		<aside>
			<h3>Other types of documentation</h3>

			<p>
				None of this is to say that other types of documentation aren't useful. Code comments are often 
				useful for explaining <i>why</i> you did something, or adding some extra clarity.
			</p>

			<div class="needs-example">Doing something weird in CSS so it works in IE</div>

			<p>
				JSDoc-type comments are valuable, if you're buildiing a library and want to expose the API to
				your users. READMEs are essential for describing how the app works in generic terms, how to get 
				it up and running, and any guides for contributing. When creating these guides, don't just describe 
				how to get the system up and running - include information like the URL to go to, and any login 
				information required.
			</p>
				
			<p>
				Finally, external documentation can be helpful if you need to provide documentation to people who 
				don't have access to your source control for some reason, or if your documentation relates to 
				multiple apps in different repositories - like a collection of micro-frontends or micro-services.
				However, I would strongly recommend storing the documentation in source control (where it's easy for 
				devs to update) and linking to it from your README. Otherwise, in a month's time, it's going to be 
				out of date, and in two months' time, nobody is even going to know it exists.
			</p>

			<p>
				The exception to this, of course, is the kind of pointless documentation you're required to produce so 
				somebody can tick a box. Nobody's going to read it, so put in the minimum effort you can, and immediately 
				forget about it.
			</p>
		</aside>

		<h3>Design your code with humans in mind</h3>

		<p>
			Most studies show that humans can really only hold 4-5 things in our working memory at a time.
			<span class="needs-example">[citation needed]</span>
			This means that we can really only keep track of that many things easily. However, we also have the ability to "chunk" data - that is to 
			group a number of pieces of data together, and think of them as a single piece. For example, most people would struggle a bi 
			remembering a list of eight single-digit numbers. But remembering two 4-digit years is fairly trivial.
		</p>

		<p>
			How can this help us write code? We can break our code up into logical units that only deal with 4-5 variables.
		</p>

		<p class="needs-example">
			One way to do this is to keep variables as local as possible. If you've got a function that deals with 10 variables, then don't 
			declare them until you actually need to use them. 
		</p>

		<p>
			Better than this though, is not to have functions with ten variables in them. As we talked about earlier, we can factor out 
			functionality into other functions - essentially using chunking to turn a lot of information into a manageable amount. We can also 
			do this on multiple levels. We could factor out the functionality of a group of related functions into a class, or a component. And we can 
			factor out multiple classes and components into a module.
		</p>

		<p>
			The important principle here is that each unit (function, component, class, or module) should only do one thing. In object-oriented programming,
			this is knows as the Single Responsibility Principle, which states that a class should only have one reason to change. Now, JavaScript isn't 
			an object-oriented language, and I don't actually think that description is that helpful, but I do think that following the Single 
			Responsibility Principle does make your code easier to understand and reason about.
		</p>

		<p>
			So, how do we decide what "one thing" is? Unfortunately, I can't give you a hard and fast rule, here - it's a bit of a judgement call.
			There are a few things that can hint that your unit of code could benefit from being split up though.
		</p>

		<ul>
			<li>
				It's hard to name. Are you having trouble coming up with a name that describes all the functionality of your component?
				Does your class have a very generic name <span class="needs-example">like ...</span>. Does your function have a name with a conjunction in 
				it (like 'and', 'or', 'if', or 'when')?
			</li>
			<li>
				Does your function or class have a heap of variables? <span class="needs-example">Sometimes</span>, this is inevitable, but it's always 
				a sign you should at least think about whether it needs splitting.
			</li>
			<li class="needs-example">
				Are you covering multiple levels of abstraction? 
			</li>
			<li>
				Is your code deeply nested? As we discussed earlier, more than one or two levels of nesting is a good sign you should consider factoring 
				some functionality out into another function, which a nice, descriptive name.
			</li>
			<li class="needs-example">
				Does your function have a flag parameter? A flag parameter is usually a boolean value that is used to change the behaviour of a function.
				Flag parameters make your code harder to understand, because it's not really clear what the function is doing from the name alone. And 
				they're a pretty good indicator that the function is doing two things.
			</li>
		</ul>

		<p>
			A corollary of the idea that we only want 4-5 variables in scope at once is that we want our functions to take as few parameters as possible. 
			It's very easy to understand what a function with no parameters is doing. But it's a bit impractical to only use functions with no parameters.
			So functions with one or two parameters are ok too. Using three or more parameters greatly increases the cognitive load of using your function. 
			It's harder to understand what's going on, because there's more in scope, and it's harder to use your function, as we've got to remember what 
			more parameters do. The smart context in your IDE can help mitigate this a little, but it's still not ideal.
		</p>

		<p class="needs-example">
			However, if you do need to pass a lot of stuff into a function, don't forget that we can rely on our old friend chunking!
		</p>

		<p class="needs-example">
			One final thing to remember, when factoring out into new classes, is that we want to favour composition over inheritance. We prefer to share 
			functionality by composing classes from a number of lower-level classes, rather than using inheritance. Using composition makes our objects more 
			flexible, as things don't need to be in the same family tree to share stuff. It also makes them easier to understand as everything at a given 
			level of abstraction is in the same place, instead of being spread across a parent class and child class.
		</p>

		<h3>Refactoring code & testing</h3>

		<p>
			One last note on the topic of clean code: keeping your code base clean is going to require refactoring your code, a lot.
			In order to do this reliably, you're going to need good tests, which test the intent of your code, not your implementation. One way to 
			achieve this is to use Test Driven Development (TDD). I highly recommend that you at least give TDD a shot, even if you don't end up 
			using it all the time. I find it particularly helpful when fixing bugs, and writing new utility code. I find it less helpful when I'm 
			writing new components, or anything that involves a lot of HTML & CSS.
		</p>

		<p>
			If you're working with legacy code which doesn't have good test coverage, things are a bit trickier. Often, it's incredibly difficult to work 
			out what the original author's intent was. In these cases, I recommend writing tests that test the current behaviour (whether it's correct or 
			not), and working against those. Make sure you clearly communicate that this is what you're doing.
		</p>

		<p>
			When it comes time to actually do the refactoring, smaller is better. Refactor a small piece of code, and check that it still works. Then do 
			another small piece. Once you've done a few small pieces you can combine them into a larger refactor. Ideally though, you should be able to 
			drop your refactoring work at just about any point, and still have functioning code.
		</p>

		<p>
		 And finally, make deliberate decisions about what code you're going to refactor. Generally speaking, only refactor code that you're actually 
		 touching. It might be tempting to re-write that 1000-line component written in archaic JavaScript with inconsistent naming everywhere, but if 
		 it's actually working ok, then you're more likely to just introduce bugs. If you find yourself needing to make changes to it, then feel free to 
		 factor out parts of it, but don't try and do the whole thing. Our goal is to create code that is easy to reason about and change, but not at the 
		 cost of breaking existing functionality.
		</p>
	</section>
	
	<section class="in-draft">
		<h2 class="incomplete" id="modern-javascript">Modern JavaScript</h2>

		<p>
			JavaScript underwent a fairly serious update in 2015, which introduced a lot of new features into the language. Since then, it has 
			had incremental additions every year, to ensure the language continues to update and evolve without the significant overhead of 
			the ES6 update. Some of these new features add brand new functionality to the language, but many of them are actually intended to 
			make it easier to follow the clean code principles we just discussed - making our code easier to reason about by making it less 
			surprising, and increasing the signal-to-noise ratio by removing boilerplate and introducing standard methods to do things.
		</p>

		<p>Today, we're going to have a look at a few of these new features, and how how they can help us write cleaner code.</p>

		<h3>Declaring variables</h3>

		<p>
			ES6 introduced two new ways to declare variables in JavaScript - <code>let</code> and <code>const</code>. So, how do we know which 
			one to use?
		</p>

		<p>
			Well, there's one simple rule: <strong>don't use <code>var</code></strong>. Like, ever.
		</p>

		<p>
			The reason for this has to do with the way that variables are scoped - that is the part of your code that a particular variable is 
			accessible in. No matter whether you use <code>var</code>, <code>let</code>, <code>const</code>, your variable will be available in the 
			current scope, and any child scopes, unless they are shadowed.
		</p>

		<p class="needs-example">What does that mean?</p>
		<ul>
			<li>
				Code that is outside of any function or module is considered the global scope. All other scopes are children of the global scope.
				This means that if you declare a variable in the global scope, it will be available in all other scopes.
			</li>
			<li>
				Code that is inside a module (<code>&lt;script type="module"&gt;</code>), but not inside any function, is module scoped. Any function 
				declared inside a module is a child scope of that module. So a module-scoped variable would be available anywhere in that module, including
				inside any functions.
			</li>
			<li>
				Code that is declared inside a function is scoped to that function. Other functions declared inside the original function are child 
				scopes of that function. A function-scoped variable is available inside the top-level function, as well as any child functions. In fact,
				this is what closures are - using a variable scoped to the parent function from inside a child function.
			</li>
		</ul>

		<p>
			What about shadowing? Shadowing occurs when a child scope contains a variable with the same name as a variable in the parent scope.
			In this case, the parent-scoped variable is no longer available in the child scope. Generally speaking, this is something you want to
			avoid, as it means you have one name referring to two different things.
		</p>

		<p>
			So how do <code>let</code> and <code>const</code> differ from <code>var</code>? <code>let</code> and <code>const</code> introduce a new 
			level of scoping - the block scope. A block scope is anything in curly brackets - like a function body, an if statement, or a loop body.
			Variables declared with <code>let</code> or <code>const</code> are block-scoped. They are accessible inside the current block, and any 
			child block scopes - such as nested conditionals, or functions declared within this block.
		</p>

		<p>What does this mean in practice? With <code>var</code> it is possible to do the following:</p>

		<pre><code>
			for (var i = 0; i < 10; i++) {
				try {
					processItem(items[i]);
				} catch (e) {
					break;
				}
			}
			console.log(`Successfully processed ${i} items`);
		</code></pre>

		<p>or</p>

		<pre><code>
			var hour = (new Date()).getHours();
			if (hour < 13) {
				var greeting = 'Good morning!';
			} else {
				var greeting = 'Good afternoon!';
			}
			console.log(greeting);
		</code></pre>

		<p>
			In the first example, we're declaring the variable <code>i</code> inside the <code>for</code> loop, then accessing it outside 
			the loop. In the second example, we're declaring the variable <code>greeting</code> in two different places.
		</p>

		<p>
			This might seem like a handy feature. (I know I find the second one tempting when I'm building strings conditionally!) However, this isn't how 
			variables work in most languages, so it makes our code a little more suprising. More importantly though, it's confusing because variables appear 
			to be being used in higher scopes than the one they were declared in. Especially in the second example, you have to read what's going on 
			inside the conditional blocks to be able to understand what's going on outside, which is the inverse of how code normally works.
		</p>

		<p>
			<code>let</code> and <code>const</code> remove the possibility of doing this.
		</p>

		<pre><code>
			for (let i = 0; i < 10; i++) {
				try {
					processItem(items[i]);
				} catch (e) {
					break;
				}
			}
			console.log(`Successfully processed ${i} items`);
		</code></pre>

		<p>
			will result in Uncaught ReferenceError: i is not defined. You'll get a similar error if you try to declare <code>message</code> with 
			either <code>let</code> or <code>const</code> in the second example. (You'll get a different error if you try to use <code>const</code>
			as a counter in a standard for loop).
		</p>

		<p>
			Ok, so we should never use <code>var</code>. But should we use <code>let</code>, or <code>const</code>? This one is actually the subject of 
			a bit of debate. To understand the debate though, we need to understand the difference between the two.
		</p>

		<p>
			If you're not familiar with <code>let</code> and <code>const</code>, <code>let</code> works basically the same as <code>var</code>, except 
			with block scoping. <code>const</code>, on the other hand, creates a "constant" - a variable that can't be reassigned to new value. This 
			makes <code>const</code> ideal for things like defining magic numbers, and you should definitely use it for that.
		</p>

		<pre><code>const GST = 0.1;</code></pre>

		<p>
			However, this doesn't mean that any variable declared with <code>const</code> is immutable. If you declare an object with <code>const</code>,
			you can't reassign it to another object, but you can change the properties of that object.
		</p>

		<pre><code>
			const person; // Uncaught SyntaxError: Missing initializer in const declaration

			const person = { name: 'Amy Pond' };
			person = { name: 'River Song' }; // Uncaught TypeError: Assignment to constant variable

			person.name = 'Rose Tyler'; // perfectly fine
		</code></pre>

		<p>
			So, given this difference, the JavaScript community is basically split into two camps: prefer <code>let</code>, or prefer <code>const</code>.
		</p>

		<p>
			The prefer <code>let</code> camp use <code>let</code>, unless they specifically want to convey that something is constant, in which case 
			they use <code>const</code>. This essentially makes the <code>const</code> declaration more meaningful.
		</p>

		<p>
			The prefer <code>const</code> camp, on the other hand, use <code>const</code> unless the variable specifically needs to be re-assigned. 
			The argument for this comes from functional programming. Reassigning variables to new values adds "surprise" to your code, makes it harder 
			to reason about, and can introduce subtle bugs. Instead of changing existing variables, we should just create new ones, with new, descriptive
			names. In this camp, <code>let</code> is really only used in situations like assigning things conditionally, or building strings.
		</p>

		<pre><code>
			const hours = (new Date()).getHours();
			let greeting;
			if (hours < 13) {
				greeting = 'Good morning!';
			} else {
				greeting = 'Good afternoon!';
			}
		</code></pre>

		<p>
			In an ideal world, we'd probably even get rid of this one <code>let</code>, like so:
		</p>

		<pre><code>
			const hours = (new Date()).getHours();
			const isMorning = hours < 13;
			const greeting = isMorning ? 'Good morning!' : 'Good afternoon!';
		</code></pre>

		<p>
			I personally prefer <code>const</code>. I think it encourages a cleaner style of coding, as shown above. Additionally, if you prefer 
			<code>const</code>, you're never going to accidentally going to declare a constant using <code>let</code>. If you prefer <code>let</code>,
			you're relying on humans to know when something must be constant.
		</p>

		<p>
			That said, it's really not a big deal. There are plenty of smart people on both sides of the debate, and the difference isn't a going to
			matter in most cases. Just pick one and run with it.
		</p>

		<p>
			One final word on refactoring code that uses <code>var</code>: While I definitely recommend converting your <code>vars</code> to <code>let</code>
			or <code>const</code>, be careful about it. The kinds of bugs you can introduce by changing the scope of a variable are quite subtle. I 
			recommend using an automated tool like a linter.
		</p>

		<h3>Array functions</h3>

		<p>
			ES6 also added a bunch of new functions to <code>Array.prototype</code>, for looping through and manipulating data. These functions 
			let us write cleaner code by allowing us to write more declarative code. Declarative code describes <i>what</i> the code should do,
			rather than <i>how</i> to do it. CSS and SQL are both declarative languages.
		</p>

		<p>
			The advantage of declarative code, is that it hides the implementation details that we're not interested in. For example, 
			<code>Array.protoype.forEach</code> allows us to do something for each item in an array, without worrying about the details of how
			the loop actually works. Or, to put it another way, it increases the signal-to-noise ratio.
		</p>
			
		<p>
			Of course, there is also a downside to declarative programming - you have less control. In the case of <code>forEach</code>, you 
			can't have a loop counter that is incremented by 2 each time, for example. 
		</p>

		<p>
			Let's have a look at some examples of declarative coding using JavaScript's array functions, and why they're nicer than the traditional 
			way of doing things. We'll start with <code>Array.prototype.forEach</code>, as it's conceptually the simplest.
		</p>

		<h4><code>Array.prototype.forEach</code></h4>
		
		<pre><code>myList.forEach((item, index, list) => ...do something... )</code></pre>

		<p>
			<code>Array.prototype.forEach</code> is a generic loop that will call your callback function on each item in the given list.
			The callback function will be passed the current item, the index of the current item, and the list itself. You <i>can</i> change 
			the list from within the loop, but I strongly recommend against it, as it makes your code weird and hard to understand.
		</p>
		 
		<p>
			So, how does it work? Imagine we want to log a list of results to the console. In traditional JavaScript, we might do that something like 
			this...
		</p>

		<pre><code>
			const results = ['pass', 'pass', 'fail', 'pass'];
			for (let i = 0; i < results.length; i++) {
				const result = results[i];
				console.log(result);
			}
		</code></pre>

		<p>Using <code>forEach</code>, that would look like...</p>

		<pre><code>
			const results = ['pass', 'pass', 'fail', 'pass'];
			results.forEach(result => console.log(result));
		</code></pre>

		<p>
			You can see we get as much signal as the first example, but with much less noise. 
		</p>

		<p>
			Now, this is a super-contrived example. The reason for this is that <code>forEach</code> is a very generic function, which returns nothing.
			The only thing it can do is produce side-effects. While this might be useful for something like logging, in most cases you're going to want 
			to use one of the other functions.
		</p>

		<h4><code>Array.prototype.map</code></h4>

		<pre><code>myList.map((item, index, list) => ... return a boolean ...)</code></pre>

		<p>
			<code>Array.prototype.map</code> gives us the ability to convert each item in an array into a new item, while leaving the original 
			array untouched. React apps use <code>map</code> extensively to convert objects into HTML elements. You can also use it to extract 
			specific properties from objects in an array.
		</p>

		<p>Converting between different objects, in traditional JavaScript</p>
		<pre><code>
			const animals = ['bear', 'cat', 'giraffe'];
			const elements = [];

			for (let i = 0; i < animals.length; i++) {
				const animal = animals[i];
				const div = createDiv(animal);
				elements.push(div);
			}

			function createDiv(animal) {
				const element = document.createElement('div');
				element.innerText = animal;
				return element;
			}
		</code></pre>

		<p>Converting between different objects, using <code>map</code></p>
		<pre><code>
			const animals = ['bear', 'cat', 'giraffe'];
			const elements = animals.map(animal => createDiv(animal));

			function createDiv(animal) {
				const element = document.createElement('div');
				element.innerText = animal;
				return element;
			}
		</code></pre>

		<p>Extracting properties, in traditional JavaScript</p>
		<pre><code>
			const users = [
				{ givenName: 'Phillip', familyName: 'Fry', occupation: 'delivery boy' },
				{ givenName: 'Turunga', familyName: 'Leela', occupation: 'captain' },
				{ givenName: 'Bender', familyName: 'Rodrigues', occupation: 'bending robot' }
			];
			const names = [];

			for (let i = 0; i < users.length; i++) {
				const user = users[i];
				const name = `${user.givenName} ${user.familyName}`;
				names.push(name);
			}
		</code></pre>

		<p>Extracting properties, using <code>map</code></p>
		<pre><code>
			const users = [
				{ givenName: 'Phillip', familyName: 'Fry', occupation: 'delivery boy' },
				{ givenName: 'Turunga', familyName: 'Leela', occupation: 'captain' },
				{ givenName: 'Bender', familyName: 'Rodrigues', occupation: 'bending robot' }
			];
			const names = users.map(user => `${user.firstName} ${user.lastName}`);
		</code></pre>

		<p>We can actually simplify this even more, using object destructuring (which we'll go into shortly)</p>
		<pre><code>const names = users.map(({firstName, lastName}) => `${firstName} ${lastName}`)</code></pre>

		<h4><code>Array.prototype.find/findIndex & Array.prototype.filter</code></h4>

		<pre><code>myList.find((item, index, list) => ... return a boolean ...)</code></pre>
		<pre><code>myList.findIndex((item, index, list) => ... return a boolean ...)</code></pre>
		<pre><code>myList.filter((item, index, list) => ... return a boolean ...)</code></pre>

		<p>
			A super common task in JavaScript is to find a particular item an array. Imagine we had list of accounts and we wanted 
			to find the one belonging to a particular user. In traditional JavaScript, we could do something like...
		</p>

		<pre><code>
			let userAccount;
			for (let i = 0; i < accounts.length; i++) {
				const account = accounts[i];
				if (account.name === name) {
					userAccount = account;
					break;
				}
			}
		</code></pre>

		<p><code>Array.prototype.find</code> greatly simplifies this.</p>

		<pre><code>const userAccount = accounts.find(account => account.name === name)</code></pre>

		<p>Similarly, if you would prefer to find the index of an item, rather than the item itself, you can use <code>findIndex</code>.</p>

		<pre><code>
			an example where you have two arrays and you findIndex in one to retrieve a value from the other
		</code></pre>

		<p>
			Sometimes, you don't just want to find the first item that matches your criteria - you want to find all the matching items.
			For example, imagine you had a list of postcodes, and you wanted to find all the ones that are in Queensland. (Postcodes in 
			Queensland all start with '4'). The postcodes are stored as strings.
		</p>

		<p>In traditional JavaScript, we could do this something like...</p>

		<pre><code>
			const queenslandPostcodes = [];
			for (let i = 0, i < postcodes.length; i++) {
				const postcode = postcodes[i];
				if (postcode.startsWith(4)) {
					queenslandPostcodes.push(postcode);
				}
			}
		</code></pre>

		<p>(The String prototype got a bunch of new declarative methods too - <code>startsWith</code> is one of those)</p>

		<p>Using <code>Array.prototype.filter...</code></p>

		<pre><code>const queenslandPostcodes = postcodes.filter(postcode => postcode.startsWith('4');</code></pre>

		<h4><code>Array.prototype.some and Array.prototype.every</code></h4>

		<pre><code>myList.some((item, index, list) => ... return a boolean ...)</code></pre>
		<pre><code>myList.every((item, index, list) => ... return a boolean ...)</code></pre>

		<p>
			Often, you want to check whether any item in an array meets a specific criterion. For example, imagine you have a form where the 
			user needs to enter some contact details. They can add a physical address, an email address, a phone number, or a Twitter handle.
			You want to check that they've entered at least one before you submit the form.
		</p>

		<p>In traditional JavaScript, that usually looks something like this</p>

		<pre><code>
			const inputs = document.querySelectorAll('.contact');

			let hasContactMethod = false;
			for (let i = 0; i < inputs.length; i++) {
				const input = inputs[i];
				if (!!input.value) {
					hasContactMethod = true;
					break;
				}
			}
		</code></pre>

		<p>We can simplify this using <code>Array.prototype.some</code></p>

		<pre><code>
			const inputs = document.querySelectorAll('.contact');
			const hasContactMethod = Array.from(inputs).some(input => !!input.value);
		</code></pre>

		<p>
			Note we're using <code>Array.from</code> to convert the <code>NodeList</code> returned by <code>document.querySelectorAll</code>
			into an actual array. Array functions will only work on true arrays, but just about anything that looks like an array can be converted to one.
		</p>

		<p>
			On the other hand, sometimes we want to check that <i>everything</i> in the array meets the criterion. For example, imagine we have 
			an order that contains a list of books. If all the books are digital, then we don't want to go through the shipping flow.
		</p>

		<p>In traditional JavaScript...</p>

		<pre><code>
			let allDigital = true;

			for (let i = 0; i < items.length; i++) {
				const item = items[i];
				if (!isDigitalMedia(item)) {
					allDigital = false;
					break;
				}
			}
		</code></pre>

		<p>
			You might notice that this is essentially the same code as the previous example, will all the trues and falses around the other way.
			As such, we could implement it using an inversion of <code>some</code>.
		</p>

		<pre><code>
			const allDigital = !items.some(item => !isDigitalMedia(item));
		</code></pre>

		<p>This is pretty confusing though. <code>Array.prototype.every</code> lets us do the same thing, without all the the <code>!</code>s.</p>

		<pre><code>
			const allDigital = items.every(item => isDigitalMedia(item));
		</code></pre>

		<p>Or, even better</p>

		<pre><code>const allDigital = items.every(isDigitalMedia)</code></pre>

		<p>
			Remember, if you don't need to define your callbacks inline. You can always define them somewhere else and just pass in the function name.
			It doesn't matter what you call the parameters of your callback function - the first one will get the value of the current item. If you declare 
			a second and third parameter, they'll get the value of the index of the current item and the list itself respectively. If you declare fewer than
			three parameters, then the index and/or list values just won't be available in your function. It won't cause any errors. And if you declare more 
			than three parameters, the remainder will just be undefined. JavaScript is very forgiving with function parameters. This can be a good thing and 
			a bad thing.
		</p>

		<h4><code>Array.prototype.includes</code></h4>

		<pre><code>myList.includes(myItem)</code></pre>
		<pre><code>myString.includes(substring)</code></pre>

		<p>
			We've already seen a couple of ways to check whether an item exists in an array, but here's another one.
			This one is often preferable, because it's much simpler. However, it does have a drawback. It uses reference equality to check 
			whether the item you're searching for is the same as the one in the array. This means it's going to work great for strings and 
			numbers, and not so much for objects.
		</p>

		<p>Imagine that we want to check whether a user has a specific role. In traditional JavaScript, you might do somethign like...</p>

		<pre><code>
			const isAdmin = user.roles.indexOf(Roles.ADMIN) > -1;
		</code></pre>

		<p>Using <code>includes</code> allows us to tidy this up a bit</p>

		<pre><code>const isAdmin = user.roles.includes(Roles.ADMIN)</code></pre>

		<p>This function can be particularly useful when combined with <code>map</code> extracting a primitive value, like the following example</p>

		<pre><code>
			const someoneHasACat = users.map(user => user.pet).includes('cat');
		</code></pre>

		<p>
			And it also exists on <code>String.prototype</code>, so you can use it check for the existence of substrings. The String protoype also 
			includes new methods to check specifically whether the substring occurs at the start or end of the string.
		</p>

		<pre><code>
			'elephant'.includes('ant'); // true 
			'elephant'.startsWith('ant'); // false
			'elephant'.endsWith('ant'); // true
		</code></pre>

		<h4><code>Array.prototype.reduce</code></h4>

		<pre><code>myList.reduce((acc, curr) => { ... do stuff ... }, startingValue);</code></pre>

		<p>
			This is the most flexible of the array functions - all the others can actually be implemented using <code>reduce</code>.
			Unfortunately, it's also a little tricky to understand.
		</p>

		<p>
			Unlike the other array functions, <code>reduce</code> takes two parameters: a callback, which is called for every item in the 
			list, and a starting value, which is passed into the callback on the first call.
		</p>

		<p>
			The callback also takes two parameters: the accumulated value, and the current value. The current value is the next item in the list.
			The first time the callback is called, the accumulated value is the starting value passed into <code>reduce</code>. Every other time, 
			it's the value returned from the previous pass of the callback.
		</p>

		<p>The traditional example for demonstrating <code>reduce</code> is to sum the values in an array, so let's look at that.</p>

		<pre><code>
			const numbers = [2, 7, 3];
			const total = numbers.reduce((sum, number) => sum + number, 0); // 12
		</code></pre>

		<p>Let's break it down step by step</p>

		<ol>
			<li>The callback is called with the starting value and the first number: (0, 2) => 0 + 2, which returns 2</li>
			<li>The callback is called with the previous returned value, and the second number: (2, 7) => 2 + 7, which returns 9</li>
			<li>The callback is called with the previous returned value, and the third number: (9, 3) => 9 + 3, which returns 12, our final value</li>
		</ol>

		<p class="needs-example">
			While summing up arrays is undeniably useful, <code>reduce</code> can be used for other things too.
			appending nodes to dom via document fragment?
			However, bear in mind that reduce can be quite tricky to understand, so use it sparingly.
		</p>

		<h4>Async array functions</h4>

		<p>
			While these new array functions provide a fantastic way to write cleaner code, there is one small gotcha you should be aware of:
			using array functions with <code>async/await</code>.
		</p>

		<p>
			When you use <code>async/await</code> in a traditional loop, like this
		</p>

		<pre><code>
			async function setPrices(items) {
				for (let i = 0; i < items.length; i++) {
					const item = items[i];
					const price = await getPrice(item.id);
					item.price = price;
				}
			}
		</code></pre>

		<p>
			The loop will pause on each iteration, wait for the price to be returned, and then continue.
		</p>

		<p>
			If you do the equivalent thing using <code>forEach</code>
		</p>

		<pre><code>
			function setPrices(items) {
				items.forEach(async (item) => {
					const price = await getPrice(item.id);
					item.price = price;
				});
			}
		</code></pre>

		<p>
			You'll notice that it's the callback function that is <code>async</code> in this case. This is because 
			<code>await</code> can only be used immediately inside an <code>async</code> function. This means that 
			the callback function will fire off the request to fetch the price, and then immediately continue to the 
			next item, without waiting for the response to come back.
		</p>

		<p>
			Now, in this situation, that's probably the behaviour that you want. This code is going to fetch all the 
			prices in parallel, which is going to be faster than fetching them one-by-one, as in the traditional loop.
			However, you've got no way of knowing when all the prices have finished being fetched!
		</p>

		<p>
			If we do need to know when the prices have all been fetched, we can take advantage of the fact that an 
			<code>async</code> function always returns a Promise, which resolves when the function returns.
		</p>

		<pre><code>
			async function setPrices(items) {
				const promises = items.map((item) => {
					const price = await getPrice(item.id);
					item.price = price;
				});

				await Promise.all(promises);
			}
		</code></pre>

		<p>
			This code will 
		</p>
		<ol>
			<li>Generate a promise for each item in the list, and add it to the <code>promises</code> array</li>
			<li>Wait until all of the promises in the <code>promises</code> array have been resolved before returning</li>			
		</ol>

		<p>And, at the same time</p>
		<ol>
			<li>Fetch all of the prices in parallel</li>
			<li>Resolve each promise in the <code>promises</code> array, once the price has been set for the related item</li>
		</ol>

		<p>
			However, sometimes this parallel behaviour isn't what you want. Instead, you want to wait for each request 
			to return before making the next request. In these cases, you're better off using a more traditional loop. However,
			there is a more declarative version of the <code>for</code> loop available in JavaScript.
		</p>

		<pre><code>
			for (const item of items) {
				try {
					await placeOrder(item);
				} catch (e) {
					console.log('Couldn\'t place all orders. Giving up.');
					break;
				}
			}
		</code></pre>

		<p>
			This code will wait until each order has been successfully placed before placing the next order. If any order fails, it will 
			give up. This type of loop still removes some of the boilerplate associated with your basic <code>for</code> loop, and will 
			work with anything array-like (including our <code>NodeList</code> from above).
		</p>

		<p>Two things to note, in order of importance</p>
		<ol>
			<li>
				This is a <code>for ... of</code> loop. It is a different beast to a <code>for ... in</code> loop, and should not be confused with
				it. If you can think of a way to remember which is which, I'd love to hear it.
			</li>
			<li>
				You can declare your <code>item</code> using <code>const</code>, if you want. This is due to the way scope works in <code>for</code>
				loops in JavaScript. Check out this <a href="https://www.youtube.com/watch?v=Nzokr6Boeaw">HTTP203 video on for loops</a> if you're 
				interested to understand why.
			</li>
		</ol>

		<h3>Other ways to reduce noise</h3>

		<p>
			Modern JavaScript also has a bunch of "shorthand" features - essentially ways to increase the signal-to-noise ratio of your code 
			by removing boilerplate and repetition. Some of them can seem a little hard to wrap your head around at first. I strongly encourage 
			you to learn how they work though, and then decide for yourself whether using them makes your code cleaner or not. If you do decide 
			you like them, you might also want to consider adding linter rules enforcing their usage.
		</p>

		<h4>Object property shorthand</h4>

		<p>
			Probably the simplest to wrap your head around - the object property shorthand can be used when you have an object property whose 
			name and value are the same. It allows you to omit the value, leading to less repeated code.
		</p>

		<pre><code>
			const name = 'Leia Organa';

			// old JavaScript
			const request = { name: name };

			// with shorthand 
			const request = { name };
		</code></pre>

		<p>
			While this shorthand is usually straightforward to understand, it can get confusing when you're using a mixture of 
			shorthand and non-shorthand values. In these cases, a bit of formatting can be very helpful.
		</p>

		<pre><code>
			// a bit confusing
			const request = { method: 'GET', name, birthDate, accountNumber: accountId, accountType };

			// better 
			const request = {
				method: 'GET',
				name,
				birthDate,
				accountNumber: accountId,
				accountType
			};
		</code></pre>

		<h4>Object and array destructuring</h4>

		<p>
			While the object property shorthand makes it easier to create objects, object destructuring makes it easier to extract things 
			out of objects. Imagine that we have an account object like so...
		</p>

		<pre><code>
			const account = {
				name: 'Ellen Ripley',
				type: 'PHONE',
				number: '34352';
			}
		</code></pre>

		<p>We can extract the properties into variables like </p>

		<pre><code>
			const name = account.name; // 'Ellen Ripley'
			const type = account.type; // 'PHONE'
			const number = account.number; // '34352'
		</code></pre>

		<p>We can now do this...</p>

		<pre><code>
			const { name, type, number } = account;

			console.log(name); // 'Ellen Ripley'
			console.log(type); // 'PHONE'
			console.log(number); // '34352'
		</code></pre>

		<p>
			This code will create three new variables - <code>name</code>, <code>type</code>, and <code>number</code>. It will set the value of these 
			variables to the values of the properties of <code>account</code> which have the same names. 
		</p>

		<p>
			We can also use destructuring when the property name is not the same as the variable name we want to use.
		</p>

		<pre><code>
			const { number: id } = account;

			console.log(id); // '34352'
		</code></pre>

		<p>
			Note that the property name goes first, the variable being declared second. So here, we declaring a variable named <code>id</code>, which is 
			taking the value of <code>account.number</code>. I personally find this a little confusing, and would think twice about using it.
		</p>

		<p>
			We can also extract properties that are nested inside the target object.
		</p>

		<pre><code>
			const user = {
				name: 'Princess Zelda',
				contactDetails: {
					type: 'TWITTER'
					value: '@zelda'
				}
			};

			const { contactDetails: { value }} = user;
			console.log(value); // '@zelda'
		</code></pre>

		<p>You can even combine nested values with renaming values.</p>

		<pre><code>
			const { contactDetails: { value: twitterHandle }} = user;

			console.log(twitterHandle); // '@zelda'
		</code></pre>

		<p>However, at this point, I would be seriously considering if this is really better than just using </p>

		<pre><code>
			const twitterHandle = user.contactDetails.value;
		</code></pre>

		<p>
			One place, however, where I think object destructuring is particularly useful, is in function parameters.
			Imagine we have a function that receives a config option like so...
		</p>

		<pre><code>
			function makeRequest(config) {
				const method = config.method;
				const url = config.url;

				const request = { method, url };

				if (method === 'POST') {
					request.body = config.body;
				}
			}
		</code></pre>

		<p>We can simplify this using object destructuring!</p>

		<pre><code>
			function makeRequest({ method, url, body }) {
				const request = { method, url };

				if (method === 'POST') {
					request.body = body;
				}
			}
		</code></pre>

		<p>
			Not only does this save us from assigning the variales manually, it also makes it clear 
			which properties the config object should have.
		</p>

		<p>
			But, wait, there's more! Objects aren't the only thing that can be destructured - we can do the same thing with arrays!
			For example, the new <code>Object.entries</code> function returns the properties of an object as a array or arrays 
			containing the property name and value.
		</p>

		<pre><code>
			const account = {
				name: 'Ellen Ripley',
				type: 'PHONE',
				number: '34352';
			}

			const properties = Object.entries(account);
			console.log(properties); // [['name', 'Ellen Ripley'], ['type', 'PHONE'], ['number', '34352']];
		</code></pre>

		<p>Array destructuring can make processing these properties simpler.</p>
		
		<pre><code>
			const firstProperty = properties[0];
			const [name, value] = firstProperty;

			console.log(name); // 'name'
			console.log(value); // 'Ellen Ripley'
		</code></pre>

		<p>We can use array destructing on function parameters as well</p>

		<pre><code>
			const copyOfAccount;

			properties.forEach(([name, value]) => {
				copyOfAccount[name] = value;
			});
		</code></pre>

		<p>Array destructuring can also be used to swap variables without using a temp variable.</p>

		<p>Traditional JavaScript...</p>
		<pre><code>
			let leftPane = viewport;
			let rightPane = devTools;

			// traditional swap 
			let temp = leftPane;
			leftPane = rightPane;
			rightPane = leftPane;

			console.log(leftPane); // devTools
			console.log(rightPane); // viewport;
		</code></pre>

		<p>With array destructuring...</p>
		
		<pre><code>
			let leftPane = viewport;
			let rightPane = devTools;

			[leftPane, rightPane] = [rightPane, leftPane]
		</code></pre>

		<p>I don't think I've ever run into an actual use case for this, but you can totally do it, if you need to.</p>

		<h4>Rest parameters & the spread operator</h4>

		<p>
			Rest and spread are essentially the same operator, used in different situations. They're used for converting groups of things into 
			arrays or objects, and vice versa. Both are represented by three dots (...).
		</p>

		<p>
			Rest parameters are used to convert an array into a list of arguments, or to convert a list of arguments into an array. This is helpful 
			when dealing with functions which can accept any number of arguments. For example, the built-in function <code>Math.min()</code> takes 
			any number of numbers and returns the lowest.
		</p>

		<pre><code>console.log(Math.min(4, 63, -2, 0, -79)) // -79</code></pre>

		<p>
			This isn't super practical in a lot of situations though as we can't use <code>Math.min</code> to find the lowest number in an array of numbers.
			Historically, if we wanted to do that, we'd probably sort the array, then take the first value. Rest parameters simplify this problem for us 
			a little. Here, we can use it to find the cheapest item in a list of items.
		</p>

		<pre><code>
			const prices = items.map(({price}) => price);
			const cheapestPrice = Math.min(...prices);
			const cheapestItem = items.find(({price}) => price === cheapestPrice);
		</code></pre>

		<p>In this code we</p>
		<ol>
			<li>Convert the list of items into a list of prices, using object destructuring of the parameter</li>
			<li>Find the lowest price, by converting the array of prices into a list of arguments for <code>Math.min</code></li>
			<li>Find the cheapest item, by findind the item with the cheapest price! (Again using object destructuring)</li>
		</ol>

		<p>
			Rest parameters also work the other way - to convert a list of arguments into an array. For example, we could define a <code>sum</code>
			function, which takes any number of arguments, and converts them into an array.
		</p>

		<pre><code>
			function sum(...numbers) {
				numbers.reduce((total, number) => total + number, 0);
			}

			console.log(sum(4, 9, 17, 23)); // 53
		</code></pre>

		<p>
			Generally speaking, I think rest parameters are more useful in the first case - passing an array into an existing function that doesn't 
			accept an array. The second case essentially takes a function that works with an array, and makes it look like it doesn't work with an 
			array. You'd want to think very carefully about why you're doing that.
		</p>

		<p>
			The other thing that <code>...</code> can do is act as a spread operator. The spread operator converts an array into a kind of "array fragment"
			that can then be used inside another array. We can use this for concatenating arrays, or for adding new values to an array.
		</p>

		<pre><code>
			const cats = ['Burmese', 'Siamese', 'Ragdoll'];
			const dogs = ['Labrador', 'Husky', 'Kelpie'];

			const pets = [...cats, ...dogs];
			console.log(pets); /// ['Burmese', 'Siamese', 'Ragdoll', 'Labrador', 'Husky', 'Kelpie'];

			const moreDogs = [...dogs, 'Shiba Inu', 'Beagle'];
			console.log(moreDogs); // ['Labrador', 'Husky', 'Kelpie', 'Shiba Inu', 'Beagle'];
		</code></pre>

		<p>
			If it helps, you can think of the spread operator as creating a copy of your array, and stripping off the brackets.
		</p>

		<p>
			The spread operator can also be used on objects. In that case, it essentially creates a copy and removes the curly braces.
			You can use this for extending objects with more properties.
		</p>

		<pre><code>
			const person = {
				name: 'Amy Wong',
				birthday: '2978-12-03'
			};

			const employee = {
				...person,
				role: 'intern'
			};

			console.log(employee); // { name: 'Amy Wong', birthday: '2978-12-03', role: 'intern' }
		</code></pre>

		<p>
			Because the spread operator makes a copy of the array or object, you can also use it for... creating copies! 
			Just bear in mind that it's only going to create a shallow copy. If you want to create a deep copy, you can use		
			<code>JSON.parse(JSON.stringify(myThing))</code>, as long as none of your properties are functions.
		</p>

		<pre><code>
			const birbs = ['Canary', 'Rosella', 'Galah'];
			const copyOfBirbs = [...birbs];

			const size = {
				height: 47,
				width: 23
			};
			const copyOfSize = {...size};
		</code></pre>

		<h4>Default parameter values</h4>

		<p>
			The last topic I wanted to touch on in this section is default parameter value. Due to the nature of JavaScript, all function
			parameters are essentially optional. If a function expects an argument, and you don't pass anything in, it's simply undefined.
		</p>
		
		<pre><code>
			function sayHello(name) {
				console.log('Hello', name);
			}

			sayHello(); // Hello undefined
		</code></pre>

		<p>
			As a result, it's usually a good idea to check that arguments have been set. If they haven't, you can either set them to some 
			sensible default, or throw an exception.
		</p>

		<pre><code>
			function sayHello(name) {
				name = name || 'world';
				console.log('Hello', name);
			}

			sayHello('Captain Janeway'); // Hello Captain Janeway
			sayHello(); // Hello world
		</code></pre>

		<p>
			Setting a bunch of default values can get a bit cumbersome, so modern JavaScript gives us a simpler way to do it.
		</p>

		<pre><code>
			function sayHellow(name = 'world') {
				console.log('Hello', name);
			}

			sayHello(); // Hello world
		</code></pre>

		<p>
			One small thing to remember - parameters with default values need to appear at the end of the argument list. Of course,
			this won't be that much of a problem, as we only write functions with one or two parameters, right?
		</p>

		<p>
			Also, your default values absolutely can refer to previous parameters.
		</p>

		<pre><code>
			function registerUser(name, preferredName = name) {
				createUser(name);
				printNameBadge(preferredName);
			}
		</code></pre>

		<h3>This binding & how arrow functions can help</h3>

		<p>
			The final part of modern JavaScript I wanted to talk about is arrow functions. By this point you've seen me using them all over the place.
			They provide a nice way to write callbacks inline - they're a little shorter to declare than normal functions, and a single line 
			arrow function has an implicit return, saving even more characters.
		</p>

		<pre><code>
			const evenNumbersNormalFunction = numbers.filter(function (number) {
				return number % 2 === 0;
			});

			const evenNumbersArrowFunction = numbers.filter(number => number % 2 === 0);
		</code></pre>

		<p>
			As you can see, the arrow function is shorter, and has a greater signal-to-noise ration. However, arrow functions are special for another 
			reason too. To understand this, we need to look at the <code>this</code> keyword in JavaScript.
		</p>

		<p>
			Understanding how <code>this</code> works can be one of the most challenging parts of learning JavaScript. The rules themselves aren't 
			super complicated, it's just that there are a lot of them. Often, you'll see people working around <code>this</code> by using code like 
		</p>

		<pre><code>
			const that = this;
		</code></pre>

		<p>
			While this hack works (and is used a lot), it's not really clean code. We're adding variables that don't add any meaning. And, in older code, 
			before the introduction of <code>const</code>, there was nothing stopping us from assigning <code>that</code> to something else. Today,
			there are plenty of ways to manage <code>this</code> without resorting to hacks, and I would see the code above as a pretty clear indicator 
			that the author didn't really get how <code>this</code> works.
		</p>

		<p>
			So how does <code>this</code> work? As a general rule, in JavaScript, <code>this</code> refers to the object that called the function.
			However, there are a few ways to override that. Also, it's important to remember that <code>this</code> refers to the object that 
			<i>called</i> the function, not the object that defined it.
		</p>

		<pre><code>
			const uhura = {
				givenName: 'Nyota',
				familyName: 'Uhura',
				sayHello: function () {
					console.log('hello', this.givenName, this.familyName);
				}
			};

			const scully = {
				givenName: 'Dana',
				familyName: 'Scully',
				sayHello: uhura.sayHello
			};

			uhura.sayHello(); // Hello Nyota Uhura
			scully.sayHello(); // Hello Dana Scully
		</code></pre>

		<p>
			You'll notice that even though <code>scully.sayHello</code> calls <code>uhura.sayHello</code>, <code>this</code> refers to 
			<code>scully</code>, <strong>not</strong> <code>uhura</code>. This can be confusing, especially if you've come from a language 
			that doesn't work this way, but it makes a lot of sense in a language that deals with event handlers.
		 </p>
		 
		 <pre><code>
			 const button = document.getElementById('special-button');
			 button.addEventListener('click', function () {
				 console.log(this); // button
			 });
		 </code></pre>

		<p>However, like I said, there are a bunch of ways to override this default behaviour.</p>
		<ol>
			<li>
				If the function is called from the global scope, <code>this</code> refers to the <code>window</code> object.
				<pre><code>
					const person = {
						name: 'Sarah Connor',
						sayHello: function () {
							console.log('Hello', this.name);
						}
					}

					const sayHello = person.sayHello;
					sayHello(); // Hello
				</code></pre>
			</li>
			<li>
				If the function is called from a strict global context, <code>this</code> is undefined. Any code written inside a module 
				is in strict mode, as is any code with a <code>'use strict';</code> declaration.

				<pre><code>
					const person = {
						name: 'Sarah Connor',
						sayHello: function () {
							'use strict';
							console.log('Hello', this.name);
						}
					}

					const sayHello = person.sayHello;
					sayHello(); // Uncaught TypeError: Cannot read property 'name' of undefined
				</code></pre>
			</li>
			<li>
				If the function is called via <code>call</code> or <code>apply</code>, then <code>this</code> refers to the first argument 
				of <code>call</code> or <code>apply</code>.

				<pre><code>
					const person = {
						name: 'Sarah Connor',
						sayHello: function () {
							console.log('Hello', this.name);
						}
					};

					const anotherPerson = {
						name: 'Katniss Everdeen'
					};

					person.sayHello.call(anotherPerson); // Hello Katniss Everdeen
				</code></pre>
			</li>
			<li>
				If the function was created via <code>bind</code>, then <code>this</code> refers to the first of argument of <code>bind</code>.
				This can't be overridden via <code>call</code> or <code>apply</code>

				<pre><code>
					const person = {
						name: 'Sarah Connor',
						sayHello: function () {
							console.log('Hello', this.name);
						}
					};

					const anotherPerson = {
						name: 'Katniss Everdeen'
					};

					const boundHello = person.sayHello.bind(anotherPerson);

					boundHello(); // Hello Katniss Everdeen 
					boundHello.call(person); // Hello Katniss Everdeen
				</code></pre>
			</li>
			<li>
				And finally, if the function is called with the <code>new</code> keyword, then <code>this</code> refers to a brand new object, 
				that will be returned by the function. This can't be overried by binding the function.
			</li>

			<pre><code>
				function Ship(name) {
					this.name = name;
				}

				const objectShip = Ship('Planet Express');
				console.log(objectShip.name); // Uncaught TypeError: Cannot read property 'name' of undefined

				const constructedShip = new Ship('Planet Express');
				console.log(constructedShip.name); // Planet Express

				const boundShip = Ship.bind({ name: 'Millenium Falcon' });
				const constructedBoundShip = new boundShip('Planet Express');
				console.log(constructedBoundShip.name); // Planet Express
			</code></pre>
		</ol>

		<p>
			All of this changes with arrow functions though. Arrow functions essentially don't bind <code>this</code>.
		</p>

		<pre><code>
			const uhura = {
				givenName: 'Nyota',
				familyName: 'Uhura',
				sayHello: () => {
					console.log('hello', this.givenName, this.familyName);
				}
			};

			uhura.sayHello(); // Hello undefined undefined
		</code></pre>

		<p>Instead, they'll use the <code>this</code> from the context that they're declared in.</p>

		<pre><code>
			class Person {
				constructor(name) {
					this.name = name;
					this.sayHello = () => console.log('Hello', this.name);
				}
			}

			const uhura = new Person('Uhura');
			uhura.sayHello(); // Hello Uhura
		</code></pre>

		<p>So how does <code>this</code>-binding in arrow functions behave in our exceptional circumstances?</p>
		<ol>
			<li>In global context, it works the same as in normal functions, in strict and non-strict mode.</li>
			<li>
				Calling an arrow function via <code>call</code> or <code>apply</code> has no effect. <code>this</code> will refer to the same 
				thing it would have referred to if you didn't use <code>call</code> or <code>apply</code>

				<pre><code>
					class Person {
						constructor(name) {
							this.name = name;
							this.sayHello = () => console.log('Hello', this.name);
						}
					}

					const uhura = new Person('Uhura');
					const katniss = { name: 'Katniss' };
					
					uhura.sayHello.call(katniss); // Hello Uhura
				</code></pre>
			</li>
			<li>
				Creating a function from an arrow function with <code>bind</code> also has no effect.
				<pre><code>
					class Person {
						constructor(name) {
							this.name = name;
							this.sayHello = () => console.log('Hello', this.name);
						}
					}

					const katniss = { name: 'Katniss' };
					const boundPerson = Person.bind(katniss);
					
					const uhura = new boundPerson('Uhura');
					uhura.sayHello.call(katniss); // Hello Uhura
				</code></pre>
			</li>
			<li>
				And finally, you can't use <code>new</code> on an arrow function.

				<pre><code>
					const Person = (name) => ({ name });
					const person = new Person('Uhura'); // Uncaught TypeError: Person is not a constructor
				</code></pre>
			</li>
		</ol>

	</section>
	
	<section><h2 class="incomplete" id="architecting-applications">Architecting applications</h2></section>
	<section><h2 class="incomplete" id="testing">Testing</h2></section>

	<section>
		<h2 class="in-draft" id="semantic-html">Semantic HTML & accessibility/h2>

		<p>
			Semantic HTML refers to HTML that uses elements that have intrinsic meaning. For example, if you're creating something for a user 
			to click on, then you should use a <code>&lt;button&gt;</code>, rather than a <code>&lt;div&gt;</code>. It's often spoken about in 
			the context of accessibility, but it's important to remember that accessible code isn't just about making your code work with a 
			screen reader.
		</p>

		<ul>
			<li>
				Using semantic HTML adds meaning to your code, increasing the signal-to-noise ratio. It's far easier to understand as a developer.
			</li>
			<li>
				Web page users expect certain types of elements to behave in certain ways. If you use the correct semantic element, you
				get a lot of this behaviour for free. This means you don't have to write as much code, and you're less likely to introduce 
				bugs.
			</li>
			<li>
				You don't know what type of device a user is going to use to interact with your app. It could be a mouse and keyboard, or a touch-screen,
				or a less common device like a watch, a gaming controller, or a screen reader.  Using semantic HTML means your app follows 
				a standard that will help your app work correctly on all those devices - as well as a bunch that haven't been invented yet!
			</li>
		</ul>

		<aside>
			<h3>What about ARIA?</h3>

			<p>
				ARIA is a set of attributes that you can add to your HTML elements to provide hints to the browser for building the accessibility tree.
				The accessibility tree is used by screen readers to provide information to screen readers that sighted users can get visually.
			</p>
			
			<pre><code>
				<label>Please send me spam</label>
				<input type="checkbox" aria-label="please send me spam">
			</code></pre>

			<p>
				A screen reader encountering the above <code>&lt;input&gt;</code> element will read out that it has a label of <code>please send me spam</code>.
			</p>

			<p>
				The thing about ARIA though, is that it's actually quite difficult to get right. And the majority of the time, you can accomplish the 
				same thing just using plain HTML. For example,
			</p>

			<pre><code>
				<label for="spam">Please send me spam</label>
				<input id="spam" type="checkbox">
			</code></pre>

			<p>
				achieves the exact same thing, from the screen reader's point of view. It also has the added bonus of linking the <code>&lt;label&gt;</code>
				to the <code>&lt;input&gt;</code> without needing to maintain two versions of the label text.
			</p>

			<p>
				Furthermore, ARIA doesn't add the functionality that you get from using semantic HTML. An HTML <code>&lt;button&gt;</code> element can be 
				tabbed to, and activated via pressing the enter key or space bar. Adding <code>role="button"</code> to a <code>&lt;div&gt;</code> does not 
				bestow these abilities on it. Similarly, in the first example above (the one using <code>aria-label</code>), the user must click on the 
				<code>&lt;input&gt;</code> element to change the value of the checkbox. In the second example, the user can click on the <code>&lt;label&gt;</code>
				element as well, greatly increasing the clickable area, and improving usability.
			</p>

			<p>
				Generally speaking, compared to using semantic HTML, using ARIA is far more difficult, and provides benefits to far fewer of your users.
			</p>

			<p>
				Now, that doesn't mean you're never going to need ARIA. Sometimes there are just things that work well for sighted users that aren't going 
				to work well with a screen reader. For example, if you update part of a page after a screen-reader user as already read it, then you 
				need a way to notify the user of the change. ARIA is perfect for this.
			</p>

			<p>
				Just remember that ARIA <i>is</i> important - but it shouldn't be the first tool that you reach for when building accessible apps.
			</p>			
		</aside>

		<p>So what does a semantic HTML look like?</p>

		<h3>Landmarks & descriptions</h3>

		<p>
			Each page should contain some landmarks. These are especially helpful to screen-reader users, but a page designed with these landmarks 
			in mind will also be easier for other users to navigate, especially in situations where you can't rely on CSS, like in Reader mode.
			Landmark HTML elements include heading tags (<code>&lt;h1&gt; - &lt;h6&gt;</code>), <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>,
			<code>&lt;nav&gt;</code>, <code>&lt;main&gt;</code>, and <code>&lt;aside&gt;</code> elements.
		</p>

		<p>
			Not every page is going to have all of these features, but if your page has any of them, then you should use the appropriate element.
			This fits with the clean coding principles we were discussing earlier - communicate your intent by using meaningful names.
		</p>

		<p>
			If you're building a SPA with multiple logical pages, then you should give each page a distinct title via the 
			<code>&lt;title&gt;</code> element. For example, on Twitter, the feed page has the title <code>Latest Tweets / Twitter</code>, while the 
			notifications page is <code>Notifications / Twitter</code>. These titles help screen reader users know when they've navigated to a new 
			page, but they also help sighted users distinguish between browser tabs, as the <code>&lt;title&gt;</code> element is used as the tab 
			title. The title should include the specific page name, followed by your app name. (Put the app name last. The tab title is likely to be 
			truncated, but sighted users can use the favicon to distinguish between apps.)
		</p>

		<p>
			As well as having some landmarks, we should make sure we have appropriate descriptions for our elements. This is most relevant for 
			<code>&lt;input&gt;</code> elements (where we're asking the user to do something), and images (which not be available, due to network
			conditions, or device restrictions, or might not be visible, due to the user's vision, or lighting, or screen glare).
		</p>

		<p>
			Every <code>input</code> element should have an obvious label that remains visible while the user is interacting with the element.
			This means that placeholder text that disappears when the input has focus is not enough. Disappearing labels can be particularly 
			difficult for users with cognitive difficulties, but they also make life harder for users who are using your app while distracted 
			by something else. If you are particularly enamoured of inline labels, try something like Google's Material Design labels, which 
			start inline, but move above the input once you start typing.
		</p>

		<p class="needs-example">material design labels</p>

		<p>
			Ideally, you should use a <code>&lt;label&gt;</code> element to label your <code>&lt;input&gt;</code> element. The <code>&lt;input&gt;</code>
			should be a child of the <code>&lt;label&gt;</code> <i>or</i> they should be linked via <code>for</code> and <code>id</code> attributes.
		</p>

		<pre><code>
			<label>
				<input type="checkbox"> Yes! Please send me spam!
			</label>

			<label for="favourite-book">What is your favourite book?</label>
			<input type="text" id="favourite-book">
		</code></pre>

		<p>
			Linking labels and inputs like this means that a click on the <code>&lt;label&gt;</code> is treated like a click on the 
			<code>&lt;input&gt;</code>. For checkboxes and radiobuttons, this means the item will be selected just by clicking the label. 
			This increases the clickable area, which is particularly helpful on small screens. It also provides us with opportunities to style 
			our radiobuttons and checkboxes in an accessible way, as we can add the styling to the label.
		</p>

		<p class="needs-example">example of styled checkbox or radiobutton</p>

		<p>
			Images are the other types of element that are super important to describe. The rules for describing them are a bit more complicated 
			though. First of all, <strong>all</strong> <code>&lt;img&gt;</code> elements should have an <code>alt</code> attribute. Sometimes this 
			attribute will be empty, but it's still important to include it. Otherwise, screen readers will read out the filename. 
		</p>

		<p class="needs-example">
			Images should have a descriptive alt-text if the information in the image isn't available anywhere else. If you have an illustrative 
			image, it should have a descriptive alt-text. If you have a button with an icon and some text, the icon doesn't need descriptive text.
			If you have a button with an icon and no text, then you need to provide a description somewhere, but the alt-text probably isn't the 
			right place for it. This is because alt-text is only available to screen readers. Your icon-only button is inaccessible to other users 
			as well.
		</p>

		<p class="needs-example">why is the save icon a vending machine</p>

		<p>
			Icons are not a great way to convey meaning. You can use a <code>title</code> attribute, which will add some hover text. But this 
			will only work for mouse users. I would strongly recommend against using icon-only buttons in most cases. The exceptions would be 
			if space is extremely limited, and you have no real choice, or your users are experts, and are likely to understand the icons.
			Icon-only buttons in a game, where space for controls is limited, and users invest a lot of time? Fine. Icon-only buttons in your banking 
			app, which users only use once or twice a month? Not great.
		</p>

		<p class="needs-example">
			When writing image descriptions, make sure you're describing what the image is illustrating. some examples. And don't use the words 
			"image" or "picture" in the description. The screen reader will already announce that it's an image, so you're just wasting the user's 
			time by repeating information they already have.
		</p>

		<p>
			And finally, if all else fails, ARIA provides the <code>aria-labelledby</code> and <code>aria-describedby</code> attributes, which 
			you can use to add descriptions aimed specifically at screen readers. If you do use these attributes though, make sure that the
			same information is also available to your sighted readers in some form!
		</p>

		<h3>Navigation</h3>

		<p>
			Accessibility isn't just about semantic HTML though. You also need to think about how users navigate around your page.
			Most websites are designed with a user using a mouse in mind. However, most users are actually using touchscreen devices 
			(chiefly mobile phones). <p class="needs-example">citation needed</p> Furthermore, there's a reasonable segment of the 
			population using non-standard inputs, like accessibility devices, watches, or game controllers.
		</p>

		<p class="needs-example">image of non-standard device</p>

		<p>
			The good news is that most non-standard devices appear as keyboards. So if you can get your site working for touchscreens and 
			keyboards, you'll be fine for the vast majority of people. (Honestly, I wouldn't even bother too much with mouse users, as an
			app which works for keyboards and touchscreens will work with a mouse. Maybe just add some hover states.)
		</p>

		<p>So what are the things you should keep in mind when designing for keyboard and touchscreen users?</p>

		<p>For keyboard users</p>
		<ul>
			<li class="needs-example">
				You need some kind of indicator of which element currently has focus. The browser will give you this for free - 
				it's a blue fuzzy outline in Chrome.
				picture of focus indicator
				However, I find that most designers don't like the default - it appears differently on different browsers, and almost 
				certainly doesn't match the site's theme. You can remove the default, but, if you do, you <i>must</i> replace it with 
				something else. I find a dashed outline in the current colour is usually a good standby
				<pre><code>
					how to remove focus indicator in chrome & firefox
					how to add dashed currentColor outline
				</code></pre>
				<code>currentColor</code> is a CSS variable that references the <code>color</code> attribute of the current element.
				example of what that looks like
			</li>
			<li>
				<p>
					Pressing <kbd>tab</kbd> should take the user to the next <code>&lt;a&gt;</code>, <code>&lt;input&gt;</code>, or 
					<code>&lt;button&gt;</code> element. If you use semantic HTML, this will Just Work. Don't force other elements to be 
					tabbable by adding a <code>tabindex</code>, and don't remove elements from the tab order by setting <code>tabindex="-1"</code>.
					Don't be tempted to add <code>tabindex</code> to things that you think screen reader users might want to tab to - screen readers 
					have a different way of navigating that doesn't rely on tabbing.
				</p>

				<p>
					The one exception to this is if you're building a custom control. Sometimes you need to group elements in a way that requires 
					manual tab-indexing. You should give your control <code>tabindex="0"</code>, so the browser can insert it into the tab order 
					automatically. You should <strong>never</strong> add a <code>tabindex</code> other than 0 or -1. This will cause the 
					tab navigation in weird and unexpected ways, and generally cause unhappiness.
				</p>
			</li>
			<li>
				<p>
					If you have a multi-page SPA (which, yes, sounds like an oxymoron) you need to move the focus back to the top of the page 
					manually when the user navigates to a new route. Otherwise, the next tab will just continue on from where you were. And, given that
					the rest of that particular page no longer exists, that's probably going to be the footer.
				</p>
				<p>
					My recommendation would be to have an <code>&lt;h1&gt;</code> element at the start of each page. (I mean this is just good design, 
					but is also helpful here). Give your <code>&lt;h1&gt;</code> a <code>tabindex</code> of -1, so it can be focussed with JavaScript, 
					but can't actually be tabbed to. Then, have some kind of interceptor that moves the focus to the <code>&lt;h1&gt;</code> whenever
					the route changes.

					<pre><code class="needs-example">setting focus to h1</code></pre>
				</p>
			</li>
			<li>
				When using modals, you need to move the focus to the modal when it opens. Then you need to ensure that focus is trapped inside the
				modal. As long as the modal is open, the user shouldn't be able to tab to anything outside of it. If they tab to the last item in 
				the modal, then the next tab should take them back to the first item. (And don't forget your modal needs to be closeable via keyboard,
				preferably via a close button (which is tabbable), or by hitting <kbd>esc</kbd>)
			</li>
		</ul>

		<p>And what about touchscreen users?</p>
		<ul>
			<li>
				Make sure you're not relying solely on hover actions. You can have hover states on your buttons to indicate they are clickable, 
				just make sure they have focus states as well. And if you have tooltips or menus that open on hover, make sure they open on click 
				as well. (In fact, I would suggest using only click, and ditching open on hover. Hover can be difficult for people with motor 
				difficulties or in awkward situations, which includes people with disabilities, the elderly, people on buses, 
				people sitting on the couch, people using Lenovo laptops with those awful nipple trackpoints...)
			</li>
			<li>
				Make sure you're not assuming whether or not someone is using a touchscreen based on their screen size. Devices with large screens 
				can have touch interfaces (2-in-1 laptops, touch-based whiteboards, etc), and some small devices don't have touch-screens 
				(watches, portable gaming devices, e-readers). If you must, you can detect whether a device has "hover capability" via 
				the <code>hover</code> media query. It's not supported in IE, but I don't think it's going to matter that much if your IE 
				users just get the non-hover version of your site.
			</li>
			<li>
				A person's finger is much less precise than a mouse cursor. Make sure that your touch targets are large enough. The Apple style 
				guide suggests 44px by 44px. Apple themselves regularly break this rule <span class="needs-example">citation needed</span>. Be 
				better than Apple.
			</li>
		</ul>

		<h3>Standards</h3>

		<p>
			Finally, the web has been around for over 30 years now. There are well-established conventions for interating with pages.
			If you use semantic HTML, you will follow these conventions automatically, and users will learn how to use your app far more 
			quickly. And they'll probably enjoy it more. Some examples of these things are:
		</p>

		<ul>
			<li>
				If you use an <code>&lt;a&gt;</code> element for links, the cursor will automatically change to a hand, and the link destination 
				will appear in the browser status bar on hover. The user can open the link in a new tab by ctrl-clicking, or using the context 
				menu. Pressing <kbd>enter</kbd> while the link is focussed will activate it. (Furthermore, pressing <kbd>space</kbd> will
				 <i>not</i> open the link. This behaviour is not preserved if you use a <code>&lt;button&gt;</code> for your link.)
			</li>
			<li>
				If you use a <code>&lt;button&gt;</code> element, the <code>onclick</code> handler will be fired if the user presses <kbd>enter</kbd> or 
				<kbd>space</kbd> while the button has focus, so it's automatically usable by a keyboard user.
			</li>
			<li>
				When an element inside a <code>&lt;form&gt;</code> element has focus, pressing <kbd>enter</kbd> or <kbd>space</kbd> will 
				submit the form.
			</li>
			<li>
				As mentioned previously, a click on a <code>&lt;label&gt;</code> element is treated as a click on the linked <code>&lt;input&gt;</code>
				element.
			</li>
		</ul>

		<p>
			When writing HTML, it is important to remember to choose your HTML element based on the <i>functionality</i> of the element, not its 
			appearance. For example, for some reason, designers really like styling links as buttons (and vice versa). I'm sure they have their 
			reasons, and that's fine. Let them have at it. You, however, should still use <code>&lt;a&gt;</code> elements for links, and just 
			CSS the heck out of them. HTML describes what our app does. CSS describes how it looks.
		</p>

		<p>
			And finally, I hope this has convinced you that accessibility isn't something that you just tack on at the end. Building an 
			accessible app is almost as much about clean code as it is about user experience. And the user experience isn't just about catering 
			to screen reader users - it's about making your app work for <i>everyone</i>. And, most importantly, building an accessible page 
			doesn't have to be time-consuming or expensive. Using semantic HTML is actually <i>quicker</i> than adding functionality manually.
		</p>

		<p>
			And, I mean, sure, the above guidelines aren't going to get you a AAA certified page. But it <i>will</i> get you a page that is 
			significantly more accessible than most pages out there. This means your users are going to have a better time, you're going to have 
			more users able to use your site, and you're much less likely to get sued by someone who can't use your site ;-)
		</p>
	</section>

	<section>
		<h2 class="in-draft" id="understanding-css">Understanding CSS</h2>

		<p>
			Out of CSS, HTML, and JavaScript, I think CSS is the thing people struggle with most. If you're looking for 
			work as a frontend developer, strong JavaScript skills are important, but mastery of CSS and HTML is what 
			will make you really stand out.
		</p>

		<p>
			Part of the reason that CSS is so difficult is that it's a completely different paradigm to most programming 
			languages. While knowing C++ or Java will give you a huge leg-up with learning JavaScript, it won't help at 
			all with learning CSS.
		</p>

		<p>
			Another factor is the fact that CSS seems to lack underlying principles. Learning CSS often feels like just 
			memorising property names and allowed values, then learning a bunch of tricks to achieve what you want. This 
			makes learning CSS very time consuming, but also very tedious.
		</p>

		<p>
			Luckily, modern CSS is much more systematic than earlier versions. Rather than just adding new features willy-nilly, 
			modern CSS has underlying models that are shared between different properties. This makes learning new CSS 
			features much quicker and easier.
		</p>

		<p>
			So today, rather than just explaining how to achieve various effects with CSS, we're going to have a look 
			under the covers at the principles and models that make CSS work.
		</p>

		<h3>The box model</h3>

		<p>
			In CSS, everything is a box. Boxes are rectangular. They have a width and a height. Boxes are divided into 
			four areas:
		</p>
		<ul>
			<li>The content goes in the innermost part of the box</li>
			<li>The content is surrounded by padding</li>
			<li>The border goes around the content and padding</li>
			<li>
				The box is surrounded by the margin. The margin isn't technically part of the box - it's the space around
				it. The margin isn't counted in the width or height, and backgrounds don't cover any of the margin.
			</li>
		</ul>

		<p class="needs-example">picture of the box model</p>

		<p>
			A box also has a <code>box-sizing</code>, which determines how the width and height are calculated. The allowed values 
			are <code>border-box</code> and <code>content-box</code>.
		</p>

		<dl>
			<dt><code>border-box</code></dt>
			<dd>
				The width and height refer to the total size of the box, including the border and padding
				<p class="needs-example">picture of border-box sizing</p>
			</dd>
			<dt><code>content-box</code></dt>
			<dd>
				The width and height refer to the size of the <i>content</i>. The padding and border are added on top of this.
				<p class="needs-example">picture of content-box sizing</p>
			</dd>
		</dl>

		<p>
			All elements have <code>box-sizing: content-box</code> by default, in all browsers, except IE, which uses 
			<code>box-sizing: border-box</code>. Now, as much as I hate to admit it, I actually think IE the IE way is better.
			Designs almost always use <code>border-box</code> sizing, as it's just generally easier to work with.
		</p>

		<p class="needs-example">an illustration of buttons or something that stay the same size regardless of content</p>

		<p>
			As such, I would recommend over-riding the default value as a standard practice. (Overriding the browser's default styling 
			like this is called a CSS reset. CSS resets are commonly used to ensure defaults are consistent across browsers.)
			You can reset <code>box-sizing</code> to <code>border-box like so</code>
		</p>

		<pre><code>
			*, *::before, *::after {
				box-sizing: border-box;
			}
		</code></pre>
		
		<p>The <code>*</code> selector is as generic as it gets, so you can easily override it for specific elements if you need to.</p>

		<h3>Normal flow</h3>

		<p>
			In CSS, individual elements are placed on the page according to normal flow. Each element is placed immediately adjacent to 
			its previous sibling (respecting margins) in one of the two directions - inline, or block.
		</p>

		<p>
			The inline direction is the direction that you write words in a sentence. On a page written in English, the inline direction 
			is left to right, across the page. On an Arabic page, it's right to left. On a Japanese page, it's top to bottom, down the page.
		</p>

		<p>
			The block direction is the direction that you add paragraphs to the page. On a page written in English or Arabic, it's top 
			to bottom, down the page. In Japanese, it's right-to-left, across the page.
		</p>

		<p>
			Why do we use the terms inline and block, rather than just saying across and down? Because we want CSS to be as language-agnostic 
			as possible. It's not actually that good at it currently - just ask anyone who's ever tried to internationalise a page to a
			non-left-to-right language. But we are moving towards a more language-agnostic CSS, and it's good to get the hang of these things 
			sooner rather than later.
		</p>

		<p>
			So how do we know if an element should be added in the inline direction, or the block direction? Each element has a <code>display</code>
			property of either <code>block</code> or <code>inline</code>. (Technically, there are a few more <code>display</code> properties, as 
			we'll see shortly. But they can all be thought of as a type of <code>block</code>, or a type of <code>inline</code>). Elements with 
			<code>display: inline</code> are added in the inline direction. Elements with <code>display: block</code> are added in the block 
			direction. <code>span</code> is your default inline element, with no other semantics. <code>div</code> is your default block element.
			(But this can be overridden in CSS.)
		</p>

		<p class="needs-example">examples of block and inline elements</p>
		<p class="needs-example">demo of adding block and inline elements</p>

		<h3>Block layout</h3>

		<p>
			The display property controls more than just how the element is placed on the page though. Block and inline elements have 
			other distinct properties and behaviours. Block elements are a little easier to understand conceptually though, so let's 
			start with them.
		</p>

		<p>
			As we already discussed, block elements are added in the block direction. Each block element is also on a row by itself - 
			the next element will be placed below the block element, whether it is block or inline.
		</p>

		<p>
			The size of a block element is determined by its width and height (plus the padding and border, if you're still using 
			<code>content-sizing</code>, despite everything we just discussed). If the width of the element is <code>auto</code>
			(which is the default value), then the element will be as wide as its parent element. If the height is <code>auto</code>,
			then the element will be as tall as it needs to be to fit all its content, given the current width.
		</p>

		<p>
			If you give your element a width and height that is too small to fit the contents, then it'll overflow, and probably look 
			terrible. This overflowed contents won't affect the placement of the next element though - it'll just get covered up.
		</p>

		<p class="needs-example">overflow and how it doesn't affect placement</p>

		<p>
			One small gotcha with block layout is margin-collapse. In some situations, the margins of two adjacent block
			elements will overlap, resulting in a single margin that is the same size as the larger one. This is due to HTML's 
			origins as a document delivery system - author's didn't want to end up with double margins around headings, or the 
			last paragraph on a page. It also means that an empty element will disappear completely, rather than hanging 
			around as a margin-ghost.
		</p>

		<p class="needs-example">margins collapsing!</p>

		<p>
			If you think you've been affected by margin-collapse, or you just want to know more about it, check out 
			<a href="https://www.smashingmagazine.com/2019/07/margins-in-css/">Rachel Andrew's article on CSS margins</a>.
		</p>

		<h3>Inline layout</h3>

		<p>
			Inline layout is a bit more complicated than block layout. Inline elements behave like text - they are laid out side-by-side 
			in the inline direction, until they get to the end of the line, and then they wrap to the next line.
		</p>

		<p>
			In order to layout inline elements (and text), the browser creates a line box. The line box is a container that the 
			browser uses to place elements - it doesn't appear in the DOM, and it can't be styled. It's kind of like adding pencil 
			lines that are erased later.
		</p>

		<p>
			The width of the line box is the width of the parent element's content box. (In vertical languages, this will actually be the 
			height. I'm just going to assume a horizontal language here though, because, honestly, this stuff is already confusing enough.)
			The height of the line box is determined by the current font - it depends on both the font-size, and some of the font's internal 
			metrics. If there are multiple fonts in the one line box, it's up to the browser to decide what height to use, but it'll probably 
			pick one based on the tallest font.
		</p>

		<p>
			If you need to, you can set the height of the line box yourself, using the <code>line-height</code> property. If you set the 
			<code>line-height</code> of a block element, it will set the minimum height of all line boxes inside that element. If you set it on 
			an inline element, then that height will be used in the line box height calculation, along with all the fonts and stuff.
			You should use a unit-less value for <code>line-height</code>, so that it scales properly if the font size changes.
		</p>

		<p>
			The width and height of an inline element are determined by the content of the element. You can't set them manually. You can,
			however, add padding and margins. Paddings and margins in the inline direction will add space around the element, as you would 
			expect. Paddings in the block direction will actually add space around the element, but if it makes the element taller than the 
			line box, it will overflow. As a result, you won't be able to see the padding, unless you add a border or a background colour.
			Margins in the block direction have no effect.
		</p>

		<p class="needs-example">overflowing over the line box</p>

		<p>
			If the line box is a different size than the line-height of your element, you can control whether your element is aligned to the top, 
			middle, or bottom of the line box using the <code>vertical-align</code> property. (And yes, it's called <code>vertical-align</code>
			even in situations where it's controlling the horizontal alignment. I told you CSS wasn't quite there yet with internationalisation.)
			The <code>vertical-align</code> property is only going to have an effect on inline elements, in a line box that isn't the same size 
			as their own line-height. This is why it never actually does what you want it to, when you try to use it to align things.
		</p>

		<p class="needs-example">using vertical-align</p>

		<p>
			Inline elements (and text) are placed into the line box until the line box until the line box is full. Then, the browser creates a 
			new line box, directly after the first one, and continues adding items to that line box.
		</p>

		<p class="needs-example">wrapping line box</p>

		<h3>New display values</h3>

		<p>
			Now, you might have noticed that there are some disadvantages to the inline/block system. It conflates the sizing with the 
			layout. What if you want elements to sit side-by-side in the inline direction, but you <i>also</i> want to control their size?
		</p>

		<p>
			<code>display: inline-block</code> was introduced to deal with this situation. An inline-block element is laid out like an 
			inline element, but can be sized like a block element. 
		</p>

		<p>
			Over time, other <code>display</code> properties were added too. <code>table</code> lays out an element like a table, 
			<code>flex</code> gives us a flexible one-dimensional layout, and <code>grid</code> gives a flexible two-dimensional layout.
			Of course, it's possible you might want any of these to exist in an inline context, so we also have <code>inline-table</code>,
			<code>inline-flex</code>, and <code>inline-grid</code>.
		</p>

		<p>
			At some point, someone realised that it was kind of silly to define two new display properties any time we wanted to add new 
			display functionality. It makes a lot more sense just to treat how the element is laid out and how it behaves internally as 
			two different things. So now, the <code>display</code> property can take <i>two</i> values - the outer display value, and 
			the inner display value.
		</p>

		<p>
			The outer value determines how the element itself is placed in the flow. The inner value determines how the element's children 
			are laid out. So <code>display: block</code> is now <code>display: block flow</code>. <code>display: inline-flex</code> would be 
			<code>display: inline flex</code>
		</p>

		<p>
			No browsers actually support the new two-value syntax yet, so don't go using it. However, it is a good model of how they 
			implement the existing values, so I think it's a good thing to understand.
		</p>

		<h3 class="incomplete">CSS is recursive</h3>

		<p>something about how children are laid out inside their parents</p>

		<h3 class="incomplete">CSS in three dimensions</h3>

		<p>
			Ok, so now we understand how an individual element behaves, and how elements are laid out in two dimensions. But CSS actually 
			allows us to lay things out in <i>three</i> dimensions.
		</p>

	</section>
	
	<section>
		<h2 class="in-draft" id="css-layouts">CSS layouts</h2>

		<p>
			Everything we've just talked about allows you to do some pretty nifty stuff. But there are some serious limitations to the 
			normal flow. Elements can really only be positioned relative to their parent, or their immediately previous sibling.
			There's no way to co-ordinate the layout of several elements at once.
		</p>
	</section>

	<section><h2 class="incomplete" id="conclusion">Wrap up</h2></section>
</body>
</html>