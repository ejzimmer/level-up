<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<meta http-equiv="X-UA-Compatible" content="ie=edge">
	<title>Level up your front end development</title>

	<link rel="stylesheet" href="lib/css/monokai.css">
	<link rel="stylesheet" href="css/fonts.css">
	<link rel="stylesheet" href="css/theme/moon.css">


	<link rel="stylesheet" href="css/notes.css">

	<script src="js/highlight.pack.js"></script>
	<script>hljs.initHighlightingOnLoad();</script>


	<style>
		.flex {
			display: flex;
		}
		.grid {
			display: grid;
		}

	</style>
</head>
<body>
	<h1>Level up your<br> front end development</h1>

	<section class="contents">
		<div>Contents</div>
		<ul>
			<li><a href="#disclaimer">Disclaimer</a></li>
			<li><a href="#clean-code">Clean code</a></li>
			<li><a href="#modern-javascript">Modern JavaScript</a></li>
			<li class="incomplete"><a href="#architecting-applications">Architecting applications</a></li>
			<li class="incomplete"><a href="#testing">Testing</a></li>
			<li><a href="#semantic-html">Semantic HTML & accessibility</a></li>
			<li><a href="#understanding-css">Understanding CSS</a></li>
			<li><a href="#css-layouts">CSS layouts</a></li>
			<li><a href="#conclusion">Wrap up</a></li>
		</ul>
	</section>

	<section>
		<h2 id="disclaimer">Disclaimer</h2>

		<p>
			This workshop contains a bunch of stuff that I think is important to understand to become a 
			good front end developer. Some of it - like how <code>Array.prototype.reduce</code> works - is 
			fact. However, some of it - like when you should create a function - is my opinion, based on 
			experience. And some of it - like the accessibility stuff - contains some good rules of thumb,
			but isn't really the complete story.
		</p>

		<p>
			The point isn't to memorise everything here and apply it exactly as described. The point is that these 
			are things that you should think about, and work out the best approach for your situation. Code written 
			for production in an enterprise organisation demands very different standards than code written at home 
			to try and learn a new topic. You need to work out what's going to be most helpful for you and your team.
		</p>

		<p>
			That said, the opinions given here should give you a decent starting point. If you don't currently have 
			an opinion on one of the topics we discuss here, feel free to just take mine and use it, while you work 
			out your own. And if you do already have an opinion, I'd encourage you to think about <i>why</i> you have 
			that opinion, and if there's anything else you might want to consider (even if your opinion agrees with 
			mine)!
		</p>
	</section>

	<section>
		<h2 id="clean-code">Clean code</h2>

		<p>
			Clean code is code that is easy to understand and maintain. The term comes from the book 
			<a href="https://www.goodreads.com/book/show/3735293-clean-code"><i>Clean Code</i> by Robert Martin 
			</a>. Writing clean code is about going beyond writing code that 
  		<i>works</i>, to writing coding that is great for the next person to work on. As Martin Fowler says
		</p>

		<blockquote cite="https://en.wikiquote.org/wiki/Martin_Fowler">
			<span style="font-weight: bold; font-size: 1.2em">A</span>ny fool can write code that a computer can understand. 
			Good programmers write code that humans can understand.
		</blockquote>

		<p>
			Clean code
		</p>
		<ul>
			<li>makes its intent clear</li>
			<li>doesn't do unexpected things</li>
			<li>is broken up logically</li>
		</ul>

		<div class="flex-columns">
			<div style="flex: 2 1 400px;">
				<h3>Signalling intent & self-documenting code</h3>

				<p>
					According to a 1979 study (quoted in <a href="https://www.goodreads.com/book/show/4845.Code_Complete">
						Steve McConnell's <i>Code Complete</i></a>)
					<q cite="https://www.goodreads.com/book/show/4845.Code_Complete">understanding the original programmer's intent was the most difficult problem</q>.
					Working out what the previous dev was trying to do is usually key to understanding bugs, 
					and is also important when adding new features, or updating existing ones. Fortunately, there 
					are a bunch of different options available to us to try and express our intent. 
				</p>

				<p>Here's a couple of options, ranked by some important factors</p>

				<div class="flex-columns">
					<table class="docs" style="max-width: 425px">
						<tr>
							<th>discoverability</th>
							<td>
								<div class="doc external" aria-label="external docs"></div>
							</td>
							<td>
								<div class="doc readme" aria-label="readme"></div>
							</td>
							<td>
								<div class="doc comments" aria-label="code comments"></div>
								<div class="doc code" aria-label="code itself"></div>
							</td>
						</tr>
						<tr>
							<th>finding the relevant information</th>
							<td></td>
							<td>
								<div class="doc external" aria-label="external docs"></div>
								<div class="doc readme" aria-label="readme"></div>
							</td>
							<td>
								<div class="doc comments" aria-label="code comments"></div>
								<div class="doc code" aria-label="code itself"></div>	
							</td>
						</tr>
						<tr>
							<th>confidence it's up-to-date</th>
							<td><div class="doc external" aria-label="external docs"></div></td>
							<td>
								<div class="doc readme" aria-label="readme"></div>
								<div class="doc comments" aria-label="code comments"></div>
							</td>
							<td>
								<div class="doc code" aria-label="code itself"></div>
							</td>
						</tr>
						<tr>
							<td></td><th>low</th><th>medium</th><th>high</th>
						</tr>
					</table>

					<table class="docs-key">
						<thead><tr><th>KEY</th></tr></thead>
						<tr><th>External documentation</th><td><div class="doc external"></div></td></tr>
						<tr><th>README</th><td><div class="doc readme"></div></td></tr>
						<tr><th>Code comments</th><td><div class="doc comments"></div></td></tr>
						<tr><th>Code itself</th><td><div class="doc code"></div></td></tr>
					</table>
				</div>
				<p>
					As you can see from the table above, the closer to the code your documentation is,
					the easier it is to discover, the easier it is to find the relevant information, and 
					the easier it is to trust that it's been kept up-to-date and relevant. The logical 
					conclusion of this is that the code itself is the best way to signal your intent.
				</p>

				<p>
					Of course, not all code is actually good at signalling intent, so we're going to look
					at some things you can do to help with this.
				</p>
			</div>
			<aside style="flex: 1 1 400px">
				<h4>Other types of documentation</h4>

				<p>
					None of this is to say that other types of documentation aren't useful. Code comments are often 
					useful for explaining <i>why</i> you did something, or adding some extra clarity.
				</p>

				<pre><code class="css">
/* ensure focus ring doesn't get cut off by overflow: hidden */
.menu .item {
	outline-offset: -2px; 
}
				</code></pre>

				<p>
					JSDoc-type comments are valuable, if you're building a library and want to expose the API to
					your users. READMEs are essential for describing how the app works in generic terms, how to get 
					it up and running, and any guides for contributing. When creating these guides, don't just describe 
					how to get the system up and running - include information like the URL to go to, and any login 
					information required.
				</p>
					
				<p>
					Finally, external documentation can be helpful if you need to provide documentation to people who 
					don't have access to your source control for some reason, or if your documentation relates to 
					multiple apps in different repositories - like a collection of micro-frontends or micro-services.
					However, I would strongly recommend storing the documentation in source control (where it's easy for 
					devs to update) and linking to it from your README. Otherwise, in a month's time, it's going to be 
					out of date, and in two months' time, nobody is even going to know it exists.
				</p>

				<p>
					The exception to this, of course, is the kind of pointless documentation you're required to produce so 
					somebody can tick a box. Nobody's going to read it, so put in the minimum effort you can, and immediately 
					forget about it.
				</p>
			</aside s>
		</div>


		<h4>Use names that are descriptive, concise and unambiguous</h4>

		<ul>
			<li>
				<p><strong>Don't use acronyms or abbreviations.</strong> It might be obvious to you what you
				mean, but will it be obvious to the next developer? What if they're a junior? Or someone who
				is new to the domain? 
				</p>

				<p>
					Where I work, we have an ID field called <code>MIRN</code>. I've been there a year and a 
					half and I still have no idea what this stands for.
				</p>

				<p>
					But even in cases where someone could work out what the abbreviation stood for, you're 
					making them use extra brain-power. And they might need that brown-power for something 
					that actually needs to be difficult. Just use the whole word - your IDE can autocomplete 
					it for your if the typing gets too much.
				</p>
			</li>
			<li>
				<strong>Don't add superfluous junk to your names.</strong> Don't add type suffixes, like Obj, 
				Str, or Arr. For a start, they're abbreviations, and we already agreed not to use abbreviations.
				But also, your IDE knows the type. It can tell you everything you need to know. The suffix isn't 
				adding any useful information.
			</li>
			<li>
				<strong>Avoid generic names</strong>. Names like <code>data</code>, <code>items</code>, 
				<code>x</code> don't convey any meaning. Pick something descriptive. (I usually make an 
				exception to this rule for loop indices - I think <code>i</code> is commonly-enough understood 
				as a loop index to cause no confusion. That said, I rarely use loop indices, as we'll see later on.)
			</li>
			<li>
				<strong>Name things consistently.</strong> A <code>message</code> and a <code>notification</code> should 
				be different things. Using synonyms to refer to the same object just adds ambiguity to your code. It's 
				not clear to a new developer whether those things refer to the same thing, or which name they should use 
				for the new thing that they're creating.
			</li>
		</ul>

		<h4>Don't be surprising</h4>

		<ul>
			<li>
				<strong>Functions should do what they say they do.</strong> I shouldn't need to read through your 
				function to work out what it does. As we already discussed, it should have a descriptive, concise, 
				and unambiguous name. But you also need to make sure it doesn't do anything <i>else</i>.

				<pre><code class="js">
getStoredBankDetails() {
	if (this.activePaymentOption === PaymentOptions.BANK) {
		this.options.push(this.storedPayments.bankAccount);
	}
}
				</code></pre>
				
				<p>
					This function doesn't do what it says. I would expect a function named <code>getStoredBankDetails</code>,
					but what it actually does is add the bank account details to a list of options. It would be better named 
					<code>addBankDetailsToOptions</code>
				</p>

				<pre><code class="js">
hasAccountChanged(newAccount) {
	const currentAccount = this.activeAccount;
	const hasChanged = (
		currentAccount.accountName !== newAccount.accountName ||
		currentAccount.accountNumber !== newAccount.accountNumber ||
		currentAccount.bsb !== newAccount.bsb
	);
	this.isDirectDebitChanged = hasChanged;
	return this.isDirectDebitChanged;
}				
				</code></pre>

				<p>
					This function does what it says on the tin. But it also has an unexpected side effect - it updates the 
					value of <code>isDirectDebitChanged</code>. There are a couple of ways we could handle this better, 
					depending on what the original intent was. We could have the calling code set <code>isDirectDebitChanged</code>
					itself.
				</p>

				<pre><code>this.isDirectDebitChanged = this.hasAccountChanged(account)</code></pre>
				
				<p>
					Or, we could change the name of the function to <code>updateDirectDebitChanged</code>.
				</p>
			</li>

			<li>
				<p>
					<strong>Don't reuse variables</strong>, even if the two uses seem related. Discovering that a variable 
					suddenly refers to something else is surprising, and we already agreed not to be surprising. For example, if you have 
					a function named <code>element()</code> that returns an element, don't be tempted to do something like 
				</p>

				<pre><code>var element = element('div');</code></pre>

				<p>You've turned a function into an object and that's potentially going to confuse the hell out of someone later.</p>
			</li>
			
			<li>
				<strong>Follow established patterns.</strong> Human brains are good at optimising for patterns. Ensuring
				your code follows established patterns makes it easier to process. This could mean project-specific things,
				like following established punctation and indenting rules, or maintaing the existing file structure.
				But it can also mean following more generic patterns. If you have a status called <code>ENABLED</code>,
				then the opposite is <code>DISABLED</code>, not <code>OFF</code>, or <code>OUT</code> or anthing else. 
				Similarly, if you have function called <code>login()</code>, then its partner should be <code>logout()</code>,
				not <code>logOut()</code>, or <code>signout()</code>, or anything else.
			</li>
		</ul>

		<h3>Increase your signal-to-noise ratio</h3>

		<p>
			The signal-to-noise ratio refers to how much of your code conveys actual meaning to the reader, compared
			to the amount that is just boilerplate, or repeating something that's been conveyed elsewhere. 
			Meaningless code is all that stuff that you just skip over when you're reading the code, because it's
			not helpful.
		</p>

		<p>
			We can improve the signal-to-noise ratio by either increasing the signal (adding meaning), or reducing
			the noise (removing the useless stuff). (Or, ideally, both!)
		</p>

		<h4>Write less code</h4>

		<p>
			Often, you can increase the signal-to-noise ratio by reducing the amount of code that you write.
			Code like
		</p>

		<pre><code>
let isParentNode;
if (hasChildren(node)) {
	isParentNode = true;
} else {
	isParentNode = false;
}
		</code></pre>

		<p>can be greatly simplified down to</p>

		<pre><code>const isParentNode = hasChildren(node)</code></pre>

		<p>
			It's not always quite as obvious as this, but it's worth keeping an eye out for this pattern. 
			Often, your IDE or linter can spot (and autofix) things like this for you.
		</p>

		<h4>Extract "noise" away</h4>

		<p>
			Another way you can increase the signal to noise ratio, is by moving the "noise" away from the signal.
			For example, imagine we had a function like the following, which checks if a file is valid, and 
			then posts it to the server if it is:
		</p>

		<pre><code>
const match = file.name.match(/\.[a-z]+$/);
let extension;
if (match && match.length > 0) {
	extension = match[0];
} 
let valid;
if (extension === 'jpg' || extension === 'jpeg' || extension === 'png' || extension === 'svg') {
	valid = true;
}
if (file.size > MAX_SIZE) {
	valid = false;
}
if (valid) {
	const formData = new FormData();
	formData.append('files[]', file);
	fetch(URL, {
		method: 'POST',
		body: formData,
	})
}
		</code></pre>

		<p>
			You can probably make out what's going on, but it's not... great. We can improve it by moving the "noise"
			of the implementation details away from the main decision flow. Our main flow would contain only
		</p>

		<pre><code>
// ...

if (isFileValid(file.name, file.size)) {
	sendFile(file);
}

// ...			
		</code></pre>

		<p>
			And then we could put the implementation details later on, possibly even in another file or module.
		</p>

		<pre><code>

function isFileValid(name, size) {
	if (fileSize > MAX_SIZE) {
		return false;
	}


	const match = filename.match(/\.[a-z]+$/);
	let extension;
	if (match && match.length > 0) {
		extension = match[0];
	} 

	const validFileTypes = ['jpg', 'jpeg', 'png', 'svg'];
	return validFileTypes.includes(extension);
}

function sendFile(file) {
	const formData = new FormData();
	formData.append('files[]', file);
	fetch(URL, {
		method: 'POST',
		body: formData,
	})
}
		</code></pre>

		<p>
			Here, the function names act like a kind of outline of what's going on: if the file is valid, 
			then send it. If we need to know the details about how we determine if a file is valid, or how 
			we send a file, then we can look inside the functions. But generally, when you're reading code, 
			you're looking for a high level overview, then dipping into a deeper level when you get to the bit 
			that interests you. Structuring your code with functions that hide implementation details like this 
			makes that easier to do.
		</p>

		<p>
			We've also added meaning in the file validation code by replacing the lengthy if statement with 
		</p>

		<pre><code>
const validFileTypes = ['jpg', 'jpeg', 'png', 'svg'];
return validFileTypes.includes(extension);
		</code></pre>

		<p>
			Adding the <code>validFileTypes</code> variable adds extra meaning to our code, and the list check is 
			much shorter, and easier to read, than the if statement. Plus, it's now easier to add or remove valid
			file types.
		</p>

		<h4>Less nesting is best nesting</h4>

		<p>
			There are also a few techniques we can use to reduce the noise in our code. For example, heavy 
			indenting adds a lot of noise and makes your code harder to understand.
		</p>
		
		<p>
			This class is constructing the view for a component which offers a special offer to selected customers. It's not 
			written for any framework - we're just going to create an object that contains the details that 
			are going to be rendered somewhere else. We're going to show the customer the details of the offer, 
			or an error message if they are eligible for an offer, but we couldn't fetch the details for some reason.
		</p>

		<pre><code class="js">
export class SpecialOfferComponent {

	//...

	render(view) {
		//... code to render the view in HTML
	}

	createView(account) {
		const view = {};

		if (account) {
			view.accountType = account.type;
			const offerDetails = account.offerDetails;

			if (offerDetails) {
				const errorCode = offerDetails.error && offerDetails.error.code;
				view.title = null;
				view.errorText = null;
				const offerDetailsExist = offerDetails && !errorCode;
				if (offerDetailsExist) {
					view.offerAccepted = offerDetails.offerAccepted;
					view.title = view.offerAccepted ? TITLE_OFFER_ACCEPTED : TITLE_OFFER;
					view.amountSaved = offerDetails.potentialSavings;
					view.offerExpiry = offerDetails.expiryDate;
				} else {
					if (this.isBillingExceptionError(errorCode)) {
						view.errorText = TEXT_BILLING_EXCEPTION;
					} else if (this.isRecoverableError(errorCode)) {
						view.errorText = TEXT_RECOVERABLE_ERROR;
					} else if (this.isFatalError(errorCode)) {
						view.errorText = TEXT_FATAL_ERROR;
					}
				}
			}
		}

		return view;
	}

	isFatalError(errorCode) {
		return (
			this.errorCode === ErrorCode.FATAL_ERROR_CODE ||
			(!!errorCode && !this.isRecoverableError(errorCode) && !this.isBillingExceptionError(errorCode))
		);
	}

	isRecoverableError() {
		return this.errorCode === ErrorCode.RECOVERABLE_ERROR_CODE;
	}

	isBillingExceptionError() {
		return this.errorCode === ErrorCode.BILLING_EXCEPTION_CODE;
	}
}
		</code></pre>

		<p>
			While this code isn't super complicated, there is still a lot of noise - it's heavily indented, making it 
			harder to trace a path through the code, and the <code>else</code> block at the very end contains a lot 
			of repeated code. Let's see if we can clean it up a bit.
		</p>

		<p>
			If we start at the top of the <code>createView</code> function, we can see that basically all the 
			functionality is wrapped up in an if block that checks if the account exists. So, straight away we 
			can get rid of one whole level of indenting, by moving this to a guard at the top of the function, and 
			returning early if the guard fails. So instead of 
		</p>

		<pre><code>
	createView(account) {
		const view = {};

		if (account) {
			// all the functionality...
		}
	}
		</code></pre>

		<p>we can do</p>

		<pre><code>
	createView(account) {
		const view = {};

		if (!account) {
			return view;
		}

		// all the functionality
	}
		</code></pre>

		<p>
			A little further down, we can see a similiar situation - a large block of code is wrapped up in the check for 
			<code>offerDetails</code>. Again, we can remove a level of indenting, by returning early from the function.
			So instead of 
		</p>

		<pre><code>
	createView(account) {
		const view = {};

		if (!account) {
			return view;
		}

		view.accountType = account.type;
		const offerDetails = account.offerDetails;

		if (offerDetails) {
			// remaining functionality...
		}
	}
		</code></pre>

		<p>we can do</p>

		<pre><code>
	createView(account) {
		const view = {};

		if (!account) {
			return view;
		}

		view.accountType = account.type;
		const offerDetails = this.account.offerDetails;

		if (!offerDetails) {
			return view;
		}

		// remaining functionality...
	}
		</code></pre>

		<p>
			Already our code is looking a lot flatter.
		</p>
		
		<pre><code>
	createView(account) {
		const view = {};

		if (!account) {
			return view;
		}

		view.accountType = account.type;
		const offerDetails = account.offerDetails;

		if (!offerDetails) {
			return view;
		}

		const errorCode = offerDetails.error && offerDetails.error.code;
		view.title = null;
		view.errorText = null;
		const offerDetailsExist = offerDetails && !errorCode;
		if (offerDetailsExist) {
			view.offerAccepted = offerDetails.offerAccepted;
			view.title = view.offerAccepted ? TITLE_OFFER_ACCEPTED : TITLE_OFFER;
			view.amountSaved = offerDetails.potentialSavings;
			view.offerExpiry = offerDetails.expiryDate;
		} else {
			if (this.isBillingExceptionError(errorCode)) {
				view.errorText = TEXT_BILLING_EXCEPTION;
			} else if (this.isRecoverableError(errorCode)) {
				view.errorText = TEXT_RECOVERABLE_ERROR;
			} else if (this.isFatalError(errorCode)) {
				view.errorText = TEXT_FATAL_ERROR;
			}
		}

		return view;
	}
		</code></pre>

		<p>
			Now, the next <code>if</code> statement is actually taking alternate paths, so we can't 
			get rid of it by returning early. What we can do, however, is use a trick we learnt earlier - 
			extracting logic out into a function. We can extract the actual logic of updating the view details 
			to two separate functions - one for the normal view, and one for the error view, and replace the 
			<code>if</code> statement with a ternary operator (because it's a bit shorter. You could equally leave the 
			<code>if</code> in, if you felt it improved readability).
		</p>

		<pre><code>
	createView(account) {
		const view = {};

		if (!account) {
			return view;
		}

		view.accountType = account.type;
		const offerDetails = account.offerDetails;

		if (!offerDetails) {
			return view;
		}

		const errorCode = offerDetails.error && offerDetails.error.code;
		view.title = null;
		view.errorText = null;
		const offerDetailsExist = offerDetails && !errorCode;

		offerDetailsExist ? extendViewWithOfferDetails(view, offerDetails) : extendViewWithError(view, errorCode);

		return view;
	}
		</code></pre>

		<p>
			The <code>extendViewWithOfferDetails()</code> function isn't that interesting - we can just move the 
			existing logic into the new function.
		</p>

		<pre><code>
	extendViewWithOfferDetails(view, offerDetails) {
		view.offerAccepted = offerDetails.offerAccepted;
		view.title = view.offerAccepted ? TITLE_OFFER_ACCEPTED : TITLE_OFFER;
		view.amountSaved = offerDetails.potentialSavings;
		view.offerExpiry = offerDetails.expiryDate;

		return view;
	}
		</code></pre>

		<p>
			The <code>extendViewWithError()</code> function, on the other hand, could use a bit of 
			work. If we were to just lift and shift the contents of the <code>else</code> statement into the 
			new function, we'd get something like 
		</p>

		<pre><code>
	extendViewWithError(view, errorCode) {
		if (this.isBillingExceptionError(errorCode)) {
			view.errorText = TEXT_BILLING_EXCEPTION;
		} else if (this.isRecoverableError(errorCode)) {
			view.errorText = TEXT_RECOVERABLE_ERROR;
		} else if (this.isFatalError(errorCode)) {
			view.errorText = TEXT_FATAL_ERROR;
		}
	}

	isFatalError(errorCode) {
		return (
			this.errorCode === ErrorCode.FATAL_ERROR_CODE ||
			(!!errorCode && !this.isRecoverableError(errorCode) && !this.isBillingExceptionError(errorCode))
		);
	}

	isRecoverableError() {
		return this.errorCode === ErrorCode.RECOVERABLE_ERROR_CODE;
	}

	isBillingExceptionError() {
		return this.errorCode === ErrorCode.BILLING_EXCEPTION_CODE;
	}
		</code></pre>

		<p>
			Let's start by looking at that <code>isFatalErrorCode</code> function. It's saying that we should treat the 
			error code as a fatal error code if			
		</p>

		<ul>
			<li>It is actually or fatal error code; or</li>
			<li>An error code exists, and it's not a recoverable error, or a billing exception error</li>
		</ul>

		<p>
			So, any error that isn't a recoverable error, or a billing exception error should be treated as a fatal error.
			It's the default value! We don't need to do a check for that - we can just use a plain <code>else</code>
			statement.
		</p>

		<pre><code>
	extendViewWithError(view, errorCode) {
		if (!errorCode) {
			return view;
		}

		if (this.isBillingExceptionError(errorCode)) {
			view.errorText = TEXT_BILLING_EXCEPTION;
		} else if (this.isRecoverableError(errorCode)) {
			view.errorText = TEXT_RECOVERABLE_ERROR;
		} else {
			view.errorText = TEXT_FATAL_ERROR;
		}
	}

	isRecoverableError() {
		return this.errorCode === ErrorCode.RECOVERABLE_ERROR_CODE;
	}

	isBillingExceptionError() {
		return this.errorCode === ErrorCode.BILLING_EXCEPTION_CODE;
	}
		</code></pre>

		<p>
			That just leaves one more <code>if</code> statement! If we look carefully at this <code>if</code> we can 
			see that it's following a pattern - each branch is setting the <code>errorText</code>, based on the value 
			of the <code>errorCode</code>. This is exactly the kind of pattern that can be handled with a <code>switch</code>
			statement.
		</p>

		<pre><code>
	extendViewWithError(view, errorCode) {
		if (!errorCode) {
			return view;
		}

		switch (errorCode) {
			case ErrorCode.BILLING_EXCEPTION_CODE:
				view.errorText = TEXT_BILLING_EXCEPTION;
				break;
			case ErrorCode.RECOVERABLE_ERROR_CODE:
				view.errorText = TEXT_RECOVERABLE_ERROR;
				break;
			default:
				view.errorText = TEXT_FATAL_ERROR;
		}

		return view;
	}
		</code></pre>

		<p>
			This is a bit better, but JavaScript gives us an option that is one better again - we can store all the values
			in an object literal (or dictionary) and just look them up!
		</p>

		<pre><code>
	const ERROR_TEXTS = {
		[ErrorCode.BILLING_EXCEPTION_CODE]: TEXT_BILLING_EXCEPTION,
		[ErrorCode.RECOVERABLE_ERROR_CODE]: TEXT_RECOVERABLE_ERROR
	};

	extendViewWithError(view, errorCode) {
		if (!errorCode) {
			return view;
		}

		view.errorText = ERROR_TEXTS[errorCode] || TEXT_FATAL_ERROR;
		return view;
	}
		</code></pre>

		<p>
			This code says look up the text for the given <code>errorCode</code> in the <code>ERROR_TEXTS</code> dictionay. 
			If you don't find it, use <code>TEXT_FATAL_ERROR</code>. This code is shorter and easier to read than than the 
			<code>if</code> statement. It also makes it very easy to add a new error code - you just add it to the dictionary, 
			and it will work. This pattern shows up a lot in JavaScript code - I recommend keeping an eye out for it.
		</p>

		<p>
			Ok, so now how is our <code>createView</code> function looking?
		</p>

		<pre><code>
	const ERROR_TEXTS = {
		[ErrorCode.BILLING_EXCEPTION_CODE]: TEXT_BILLING_EXCEPTION,
		[ErrorCode.RECOVERABLE_ERROR_CODE]: TEXT_RECOVERABLE_ERROR
	};

	createView(account) {
		const view = {};

		if (!account) {
			return view;
		}

		view.accountType = account.type;
		const offerDetails = account.offerDetails;

		if (!offerDetails) {
			return view;
		}

		const errorCode = offerDetails.error && offerDetails.error.code;
		view.title = null;
		view.errorText = null;
		const offerDetailsExist = offerDetails && !errorCode;

		offerDetailsExist ? extendViewWithOfferDetails(view, offerDetails) : extendViewWithError(view, errorCode);

		return view;
	}

	extendViewWithOfferDetails(view, offerDetails) {
		view.offerAccepted = offerDetails.offerAccepted;
		view.title = view.offerAccepted ? TITLE_OFFER_ACCEPTED : TITLE_OFFER;
		view.amountSaved = offerDetails.potentialSavings;
		view.offerExpiry = offerDetails.expiryDate;

		return view;
	}

	extendViewWithError(view, errorCode) {
		if (!errorCode) {
			return view;
		}

		view.errorText = ERROR_TEXTS[errorCode] || TEXT_FATAL_ERROR;
		return view;
	}

		</code></pre>

		<p>
			This is looking pretty good! It's easier to follow a path through the main function, due to the lack of indenting. 
			We've increased the signal-to-noise ratio by extracting code out to functions with meaningful names, and removing 
			repetitive code. And we've made it easy to update by extracting configuration out into a dictionary. At this point, 
			there's just one more thing I would do, which is to remove these two lines:
		</p>

		<pre><code>
view.title = null;
view.errorText = null;
		</code></pre>

		<p>
			There is no reason to set either of these values to <code>null</code> explicitly. If we need to use them, they'll be set to
			some value. Otherwise, they can just remain <code>undefined</code>. As a general rule of thumb, you should never initialise 
			a variable to <code>null</code> or <code>undefined</code>. It just doesn't add any value. You can set your variables to 
			<code>null</code> or <code>undefined</code> if they've already been set to a value and you want to "unset" them. You can 
			even have a whole holy war about whether you should use <code>null</code> or <code>undefined</code>. You just don't need 
			to set them to that to start with.
		</p>

		<p>
			Ok, so the final version of our class.
		</p>


		<pre><code>
const ERROR_TEXTS = {
	[ErrorCode.BILLING_EXCEPTION_CODE]: TEXT_BILLING_EXCEPTION,
	[ErrorCode.RECOVERABLE_ERROR_CODE]: TEXT_RECOVERABLE_ERROR
};

export class SpecialOfferComponent {

	// ...

	render(view) {
		//... code to render the view in HTML
	}


	createView(account) {
		const view = {};

		if (!account) {
			return view;
		}

		view.accountType = account.type;
		const offerDetails = account.offerDetails;

		if (!offerDetails) {
			return view;
		}

		const errorCode = offerDetails.error && offerDetails.error.code;
		const offerDetailsExist = offerDetails && !errorCode;

		offerDetailsExist ? extendViewWithOfferDetails(view, offerDetails) : extendViewWithError(view, errorCode);

		return view;
	}

	extendViewWithOfferDetails(view, offerDetails) {
		view.offerAccepted = offerDetails.offerAccepted;
		view.title = view.offerAccepted ? TITLE_OFFER_ACCEPTED : TITLE_OFFER;
		view.amountSaved = offerDetails.potentialSavings;
		view.offerExpiry = offerDetails.expiryDate;

		return view;
	}

	extendViewWithError(view, errorCode) {
		view.errorText = ERROR_TEXTS[errorCode] || TEXT_FATAL_ERROR;
		return view;
	}
}
			</code></pre>

			<p>
				Compared with the original.
			</p>

			<pre><code>
export class SpecialOfferComponent {

	//...

	render(view) {
		//... code to render the view in HTML
	}

	createView(account) {
		const view = {};

		if (account) {
			view.accountType = account.type;
			const offerDetails = account.offerDetails;

			if (offerDetails) {
				const errorCode = offerDetails.error && offerDetails.error.code;
				view.title = null;
				view.errorText = null;
				const offerDetailsExist = offerDetails && !errorCode;
				if (offerDetailsExist) {
					view.offerAccepted = offerDetails.offerAccepted;
					view.title = view.offerAccepted ? TITLE_OFFER_ACCEPTED : TITLE_OFFER;
					view.amountSaved = offerDetails.potentialSavings;
					view.offerExpiry = offerDetails.expiryDate;
				} else {
					if (this.isBillingExceptionError(errorCode)) {
						view.errorText = TEXT_BILLING_EXCEPTION;
					} else if (this.isRecoverableError(errorCode)) {
						view.errorText = TEXT_RECOVERABLE_ERROR;
					} else if (this.isFatalError(errorCode)) {
						view.errorText = TEXT_FATAL_ERROR;
					}
				}
			}
		}

		return view;
	}

	isFatalError(errorCode) {
		return (
			this.errorCode === ErrorCode.FATAL_ERROR_CODE ||
			(!!errorCode && !this.isRecoverableError(errorCode) && !this.isBillingExceptionError(errorCode))
		);
	}

	isRecoverableError() {
		return this.errorCode === ErrorCode.RECOVERABLE_ERROR_CODE;
	}

	isBillingExceptionError() {
		return this.errorCode === ErrorCode.BILLING_EXCEPTION_CODE;
	}
}	
			</code></pre>
			
		<p>
			The new version isn't the only way we could have cleaned up this code. It's not even necessarily the best 
			way. But, hopefully you agree that the new version is much easier to read, and it's going to be easier to 
			modify, if we ever need to. It's also going to be easier to track bugs through, as there aren't really any 
			branches - just dead ends.
		</p>
		
		<h4>Use idioms</h4>

		<p>
			Using JavaScript idioms is another way to potentially reduce noise in code. For example, something 
			like 
		</p>

		<pre><code>
let name = user.getName();
if (name === undefined) {
	name = 'hey you';
}
		</code></pre>

		<p>
			can be simplified to
		</p>

		<pre><code>
const name = user.getName() || 'hey you';
		</code></pre>

		<p>
			(If you're not familiar with the <code>||</code> shortcut, in JavaScript: <code>||</code> returns the first truthy value,
			or the last value, if none of them are truthy. In this case, if <code>user.getName()</code> returns a value, then we'll get that 
			value. Otherwise, we'll get 'hey you'.)
		</p>

		<p>
			A couple of things to keep in mind when using idioms like this though:
		</p>
		<ul>
			<li>
				The two code snippets aren't exactly equivalent. The second version will replace any falsey value with 'you' - including null, or 
				empty string. In this case, this is probably the behaviour that you want, and the second version is actually more robust. This 
				won't always be the case though.
			</li>
			<li>
				You're aiming to make the code easier to understand. Sometimes there is a fine line between idiomatic code and "clever" code, which 
				is short, but difficult to understand. For example, nested ternary operators might make your code shorter than using if statements, 
				but they're almost certainly more difficult to understand. If you're not sure - ask someone else to have a look!
			</li>
		</ul>

		<p>
			Here are a few JavaScript idioms you should be familiar with:
		</p>

		<ul>
			<li>Using <code>||</code> to set defaults (like we did above)</li>
			<li>
				<p>
					Using <code>&&</code> for null-checking. <code>&&</code> will return the first falsey value, or the last value if all values are truthy.
					So, we can do null-checking like
				</p>

				<pre><code>const name = user && user.name && user.name.firstName;</code></pre>

				<p>
					If either <code>user</code> or <code>user.name</code> are null or undefined, then <code>name</code> will be null or undefined. Otherwise, 
					it will have the value of <code>user.name.firstName</code>	
				</p>
			</li>
			<li>
				Convert to boolean via <code>!!</code>. The negation operator (<code>!</code>) converts a value to boolean. So 
				<code>!someTruthyValue</code> equals <code>false</code>. <code>!!</code> sets it back to the boolean equivalent of its initial value.
				So <code>!!someTruthyValue</code> equals <code>true</code>.
			</li>
			<li>
				You can convert a string to a number using unary <code>+</code>.
				<pre><code>const age = +document.getElementById('age').value;</code></pre>
				Converting a non-numeric value will result in <code>NaN</code>, so make sure your code includes the appropriate checks.
			</li>
			<li>
				<p>
				Creating a copy via JSON. You can create a deep copy of an object using <code>JSON.parse()</code> and <code>JSON.stringify()</code>.
				</p>

				<pre><code>const copy = JSON.parse(JSON.stringify(objectToCopy))</code></pre>

				<p>
					In fact, it's often the fastest way to create a deep copy. However, there are a few things you should 
					be aware of before using it.
				</p>

				<p>
					Firstly, it will only work if your object contains nothing but strings, booleans, dates, and numbers. Functions, regexes and other 
					special values will either be lost, or magically turned into a different value. A regex, for example, will end up as an empty 
					object, and <code>Nan</code> gets converted to <code>null</code>. So you need to be very sure about what's in your object before 
					copying it this way.
				</p>

				<p>
					Secondly, because JavaScript doesn't natively support deep copies (without resorting to hacks), some people consider deep copies 
					to be a code smell - an indication that there are other problems with your code. When you find yourself trying to perform a 
					deep copy, it's probably a good idea to ask yourself if that's really what you want to do, if there's some other way you could 
					structure the code to avoid doing it. If you actually want to create a shallow copy, there are a couple of ways to do that 
					- you can use <code>Object.assign()</code>, or array or object destructuring. (We will go into the details of array and object 
					destructuring later on.)

					<pre><code>
const objectCopy1 = Object.assign({}, objectToCopy);
const objectCopy2 = {...objectToCopy};

const arrayCopy1 = Object.assign([], arrayToCopy);
const arrayCopy2 = [...arrayToCopy];
					</code></pre>

					<p>
						So, while I definitely recommend that you make sure you understand how the <code>JSON.parse(JSON.stringify())</code> trick 
						works - because you're definitely going to see it in other people's code - I would think twice before using it yourself.
					</p>
				</p>
			</li>
		</ul>

		<h3>Don't repeat yourself</h3>

		<p>
			Perhaps the most effective way you can reduce noise in your code, though, is by DRYing it out. If you've not heard of DRY before, it stands 
			for "Don't Repeat Yourself". At its most fundamental, this means that you shouldn't implement the same logic twice in your code. Instead, factor 
			the repeated logic out into a function, class, or module.
		</p>

		<p>
			There are several reasons why you want to avoid repeated logic in your code.
		</p>

		<ul>
			<li>More code means more things that can go wrong</li>
			<li>Having logic implemented in multiple places means it's more work to update it when things change</li>
			<li>Similarly, it's more work to fix bugs, as they will need to be fixed multiple times</li>
			<li>
				There is a high risk that your implementations will get out of sync. This is particularly problematic, as there is 
				no way for future devs to know which implementation is correct, or why they're different.
			</li>
		</ul>

		<p>
			For example, imagine we're dealing with credit card payments. We want to be able to display credit cards that a user has 
			previously stored with us. We want to show the type of the card, but we don't store that, so we need to calculate it from 
			the card number each time. This logic turns out to be slightly complicated, so let's use the <code>card-validator</code>
			NPM package. The code looks something like this.
		</p>

		<pre><code>
import { cardValidator } from 'card-validator';

function getCardType(cardNumber) {
	return cardValidator.number(cardNumber).card.niceType;
}
		</code></pre>

		<p>
			The <code>card-validator</code> library returns a <code>niceType</code> of "American Express" for American Express 
			cards. However, our designers would prefer that we displayed American Express cards as "AMEX". (Based on a true story.)
			We can add a little conversion into our function. (The <code>credit-card-type</code> package provides the type strings used 
			by <code>card-validator</code>.)
		</p>

		<pre><code>
import { types } from 'credit-card-type';
import { cardValidator } from 'card-validator';

function getCardTypeForDisplay(cardNumber) {
	const card = cardValidator.number(cardNumber).card;
	return card.type === types.AMERICAN_EXPRESS ? 'AMEX' : card.niceType;
}
		</code></pre>

		<p>
			Great. But we also have a form where the user enters their credit card details. On this form, we want to 
			display the card type, as the user types the number. And we also want to display "AMEX" instead of "American Express".
			(The <code>card-validator</code> library can determine the card type based on a partial number as the user types.)
			We also want to display an error if the user enters a card type that we don't support.
		</p>

		<pre><code>
import { types } from 'credit-card-type';
import { cardValiator } from 'card-validator';

const allowedTypes = [types.AMERICAN_EXPRESS, types.MASTERCARD, types.VISA];
function updateCardType(cardNumber) {
	const card = cardValidator.number(cardNumber).card;

	if (!allowedTypes.includes(card.type)) {
		throw new Error('Card type not allowed');
	}

	return card.type === types.AMERICAN_EXPRESS ? 'AMEX' : card.niceType;
}
		</code></pre>

		<p>
			Ok. Now what happens if the designers decide to change "AMEX" to "Amex"? We have to change it in two places. Two might not seem like many, 
			but there could easily be way more than two places that we display credit card types. And what if we forget one of them? I mean, it's not 
			a huge deal - our labels will just be a little different. Eventually someone will notice and fix it. But how will they know how to fix it?
			Are the labels supposed to have different values? If not, then which label is the correct one?
		</p>

		<p>
			It's much better to keep this kind of information in a single, centralised location.
		</p>

		<pre><code>
import { types } from 'credit-card-type';
import { cardValidator } from 'card-validator';

export function getCardType(cardNumber) {
	const card = cardValidator.number(cardNumber).card;
	
	const cardType = {
		type: card.type,
		niceType: card.niceType
	};

	if (card.type === types.AMERICAN_EXPRESS) {
		cardType.niceType = 'AMEX';
	}

	return cardType;
}
		</code></pre>

		<p>
			We can then use this new function everywhere that we need to display card types.
		</p>

		<pre><code>
import { getCardType } from '../card-utils';

function getCardTypeForDisplay(cardNumber) {
	return getCardType(cardNumber).niceType;
}
		</code></pre>

		<pre><code>
import { getCardType } from '../card-utils';

const allowedTypes = [types.AMERICAN_EXPRESS, types.MASTERCARD, types.VISA];
function updateCardType(cardNumber) {
	const cardType = getCardType(cardNumber);

	if (!allowedTypes.includes(cardType.type)) {
		throw new Error('Card type not allowed');
	}

	return cardType.prettyType;
}
		</code></pre>

		<p>
			Yes, this logic is a bit longer to implement. However, it's much shorter to <i>use</i>. And, it hides the 
			details of the library used to fetch the name. We could easily swap out the library if something newer and 
			shinier came along, without needing to change it in multiple places.
		</p>

		<p>
			This is the kind of trade-off you need to think about when DRYing out your code. Is the increase in implementation 
			effort going to be offset by the ease of use? Is hiding implementation details going to make life easier for 
			someone in the future. Often, the answer will be yes, but that's not always going to be the case.
		</p>

		<p>
			Dan Abramov describes <a href="https://overreacted.io/goodbye-clean-code/">a time when he DRYed out some code and 
			it didn't go so well</a> on his blog. It's important to remember that when DRYing code, we really want to remove 
			repeated <i>logic</i>, not just code that looks similar. And it's far more important to have code that is easy 
			to understand and maintain, than to have code that never repeats a line.
		</p>

		<h3>Design your code with humans in mind</h3>

		<p>
			Most studies show that humans can really only hold 4-5 things in our working memory at a time
			(<a href="https://en.wikipedia.org/wiki/Working_memory#Capacity">Working memory capacity on Wikipedia</a>).
			This means that we can really only keep track of that many things easily. However, we also have the ability to "chunk" data - that is to 
			group a number of pieces of data together, and think of them as a single piece. For example, most people would struggle a bit 
			remembering a list of eight single-digit numbers. But remembering two 4-digit years is fairly trivial.
		</p>

		<h4>Chunks</h4>

		<p>
			How can this help us write code? We break our code up into chunks - where a chunk is a function, a class, or a module.
			Each chunk should have a single, unifying purpose - something you can describe in two or three words. Chunks can be made 
			of smaller chunks, but each chunk should consist of no more than 4-5 smaller units.
		</p>

		<p>
			The idea that each class should do only one thing comes from object-oriented programming, and is called the Single Responsiblity 
			Principle. More formally stated, the Single Responsibility Principle states that a class should only have one reason to change.
			I don't find that definition particularly helpful - but classes (and functions) that do more than one thing do tend to be more 
			difficult to remember how to use.
		</p>

		<p>
			Take, for example, the built-in JavaScript function <code>Array.prototype.splice</code>. 
		</p>

		<pre><code>let arrDeletedItems = array.splice(start[, deleteCount[, item1[, item2[, ...]]]])</code></pre>
		<div>Source: <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice">MDN</a></div>

		<p>	
			It takes a start index and a number of things to be deleted. It also takes an optional list of things to be added to the array.
			(Except it's not a list, you just add the other things to the end of the parameter list.) It deletes the number of things to be 
			deleted, starting from the start index, adds in all the things from the end of the parameter list, and returns the list of things 
			that were deleted. 	
		</p>

		<p>
			This function does two things - it deletes items, and it adds them. And because it does two things, it has a name that isn't very
			descriptive. So, it's easily confused with the similarly named <code>Array.prototype.slice</code>. It's also the only way to delete 
			items from an array. Wouldn't it be easier if we had a function named <code>removeItems</code>?
		</p>

		<pre><code>const updatedArray = array.removeItems(start, deleteCount)</code></pre>

		<p>We could have another function that added items in, if we really needed it.</p>

		<pre><code>const updatedArray = array.addItems(start, itemsToAdd)</code></pre>

		<p>
			Unfortunately, I can't really give you a hard and fast rule for what constitutes "one thing", but there are some 
			red flags that you can keep an eye out for.
		</p>
		<ul>
			<li>
				Is your function/class difficult to name? Is it difficult to find a name that covers all the functionality (like <code>splice</code>)?
				Have you ended up with a very generic class name, like <code>System</code> or <code>Manager</code>? Does your function name 
				have a conjunction in it (like 'and', 'or', 'if', or 'when')?
			</li>
			<li>
				Is your function long? If it doesn't fit on a screen, it's going to be hard to keep track of.
				Does it have more than four or five variables? (Remember humans can only keep up with four or fives things at once).
				Does your function have more than four or five public methods?
			</li>
			<li>
				Is your code deeply nested? As we discussed earlier, more than one or two levels of nesting is a good sign that you should 
				consider factoring out some functionality into another function, with a nice, descriptive name.
			</li>
		</ul>

		<h4>Parameters</h4>

		<p>
			Parameters are something else that we need to keep track of when understanding a function. So it probably won't suprise you when I 
			say the fewer parameters the better. The ideal number of parameters for a function is zero. A function that takes zero parameters and 
			always produces the same results is very easy to understand! Of course, writing all our functions with no parameters kind of limits 
			what we can do, so functions with one or two parameters are ok too. Three, at a pinch. Using more than three parameters greatly increases 
			the cognitive load of using your function though. For a start, it's harder to remember what all the parameters do!
		</p>
		
		<pre><code>
function createUser(firstName, lastName, emailAddress, phoneNumber, githubUser, twitterHandle) {
	...
}
		</code></pre>

		<p>
			If you do find yourself needing to pass a lot of parameters into a function though, then don't forget that we can use chunking to help.
			Can the parameters be grouped together into a single cohesive object? Well, that only counts as one parameter!
		</p>

		<pre><code>
function createUser(name, contactDetails) {
	...
}
		</code></pre>

		<h3>Refactoring code & testing</h3>

		<p>
			One last note on the topic of clean code: keeping your code clean is going to require frequent refactoring. And reliable 
			refactoring requires good tests. Good tests mean tests that test the <i>intent</i> of your code, <i>not</i> the implementation 
			details.
		</p>

		<pre><code>
it('sets the valid flag when the phone number is changed to an invalid value', () => {
	const INVALID_PHONE_NUMBER = '12345';

	spyOn(component, 'validatePhoneNumber').and.returnValue(false);
	spyOn(component, 'setFormValidity');

	component.onChange(INVALID_PHONE_NUMBER);

	expect(component.validatePhoneNumber).toHaveBeenCalled();
	expect(component.setFormValidity).toHaveBeenCalledWith(false);
});
		</code></pre>

		<p>
			This test is testing that the component checks the validity of a phone number, when it changes. It tests that the 
			component calls its own <code>validatePhoneNumber</code> function, then calls the <code>setFormValidity</code> function
			with a value of false. This is not really the ideal way to test this.
		</p>
		<ul>
			<li>
				We've coupled the test with the component's internal API. If we change the name of the <code>validatePhoneNumber</code> method,
				our test will fail, even if the component continues to work correctly. Tests should really only text public APIs - the things 
				that are going to break stuff if they change.
			</li>
			<li>
				We've decoupled two related calls. The value returned by <code>validatePhoneNumber</code> is the one that should be passed into 
				<code>setFormValidity</code>. Our test isn't testing this, so we'd need to write another test. Plus, we could potentially end up
				wasting time testing scenarios that can't acutally happen!
			</li>
			<li>
				We're testing that the functions are called, rather than that their outcomes are correct. We don't really care which functions get 
				called - we really only care that the <code>valid</code> flag on the form gets set to <code>false</code> when the input is invalid.
			</li>
		</ul>

		<p>A better test for this functionality would be</p>

		<pre><code>
it('sets the valid flag when the phone number is changed to an invalid value', () => {
	const INVALID_PHONE_NUMBER = '12345';

	component.onChange(INVALID_PHONE_NUMBER);

	expect(component.form.valid).toBe(false);
});
		</code></pre>

		<p>
			This test tests the <i>outcome</i> or our action. It tells us everything we need to know. It's much shorter. And it's not 
			tied to a specific internal implementation of our component.
		</p>

		<p>
			One thing that can help with writing more helpful tests is using Test Driven Development (TDD). If you've not heard of TDD, the idea is that you 
			write tests based on your acceptance criteria, and <i>then</i> write the code to pass the tests. If you've never tried TDD before, 
			I highly recommend giving it a try, at least for a little while. I personally find it very helpful when fixing bugs, and writing 
			"utility" code, like state management, or transformations. I find it less helpful for writing component code.
		</p>

		<p>
			"Uncle" Bob Martin is a huge proponent of TDD. You can find a bunch of articles about it on his blog, including 
			<a href="https://blog.cleancoder.com/uncle-bob/2016/03/19/GivingUpOnTDD.html">this one on designing tests</a>.
		</p>

		<p>
			When it comes time to actually do the refactoring, smaller is better. Refactor a small piece of code, and check that it still works. Then do 
			another small piece. Once you've done a few small pieces you can combine them into a larger refactor. Ideally though, you should be able to 
			drop your refactoring work at just about any point, and still have functioning code.
		</p>

		<p>
		 And finally, make deliberate decisions about what code you're going to refactor. Generally speaking, only refactor code that you're actually 
		 touching. It might be tempting to re-write that 1000-line component written in archaic JavaScript with inconsistent naming everywhere, but if 
		 it's actually working ok, then you're more likely to just introduce bugs. If you find yourself needing to make changes to it, then feel free to 
		 factor out parts of it, but don't try and do the whole thing. Our goal is to create code that is easy to reason about and change, but not at the 
		 cost of breaking existing functionality.
		</p>
	</section>
	
	<section>
		<h2 id="modern-javascript">Modern JavaScript</h2>

		<p>
			JavaScript underwent a fairly serious update in 2015, which introduced a lot of new features into the language. Since then, it has 
			had incremental additions every year, to ensure the language continues to update and evolve without the significant overhead of 
			the 2015 update. Some of these new features add brand new functionality to the language, but many of them are actually intended to 
			make it easier to follow the clean code principles we just discussed - making our code easier to reason about by making it less 
			surprising, and increasing the signal-to-noise ratio by removing boilerplate and introducing standard methods to do things.
		</p>

		<p>Today, we're going to have a look at a few of these new features, and how how they can help us write cleaner code.</p>

		<h3>Declaring variables</h3>

		<p>
			ES6 (the 2015 version of JavaScript) introduced two new ways to declare variables, bringing the total to three: <code>let</code>,
			<code>const</code>, and <code>var</code>. Each declaration type has different properties.
		</p>

		<table class="variables">
			<tr>
				<td></td><th>Mutable</th><th>Scoping</th>
			</tr>
			<tr>
				<th><code>var</code></th><td>✔️</td><td>function</td>
			</tr>
			<tr>
				<th><code>let</code></th><td>✔️</td><td>block</td>
			</tr>
			<tr>
				<th><code>const</code></th><td>❌</td><td>block</td>
			</tr>
		</table>

		<h4>Mutability</h4>

		<p>
			Both <code>var</code> and <code>let</code> allow you to change what your variable refers to after declaration.
		</p>
		
		<pre><code>
var favouriteNumber = 4;
favouriteNumber = 6; // perfectly OK.

let count = 0;
count++; // also completely alright.
		</code></pre>

		<p>
			<code>const</code>, on the other hand, doesn't.
		</p>

		<pre><code>
const quest = "seek the Holy Grail";
quest = "run away"; // TypeError: invalid assignment to const 'quest'
		</code></pre>

		<p>
			It's important to realise that it's the variable <i>reference</i> that's immutable though, not the 
			variable itself. If your variable refers to an object, you can't change it to refer to another object, 
			but you <i>can</i> change the properties of the object.
		</p>

		<pre><code>
const lancelot = {
	favouriteColour: 'blue'
};
const galahad = {
	favouriteColour: 'blue'
}

galahad = lancelot; // TypeError: invalid assignment to const 'galahad'
galahad.favouriteColour = 'yellow'; // Quite alright
		</code></pre>

		<p>
			So when should you use <code>const</code>? I would suggest using it everywhere that you can. If you default to declaring 
			your variables <code>const</code>, then you're never going to accidentally forget to do it when you need to. If, on the other 
			hand, you declare a variable as <code>const</code> when it needs to be mutable, then your IDE will tell you straight away, so 
			you're not going to introduce any weird bugs.
		</p>

		<p>
			There are plenty of people who would disagree with this assessment though. There is an argument that declaring everything as 
			<code>const</code> dilutes its meaningfulness. Instead you should declare everything as <code>let</code>, unless you specifically 
			need <code>const</code>. And there are people who don't care either way - just pick one and stick with it. Dan Abramov summarises
			the arguments for both sides in <a href="https://overreacted.io/on-let-vs-const/">a blog post on the topic</a>, if you're interested.
			When it comes down to it, it's unlikely that it's going to make a huge difference which you choose, so just pick one and go with it.
		</p>

		<h4>Scoping</h4>

		<p>
			The other factor we have to consider when deciding how to declare variables is whether we want function scoping, or block scoping.
			Fortunately, this one has an easy answer. You want block scoping. Function scoping is weird and scary.
		</p>

		<p>
			To put it bluntly, <strong>don't use <code>var</code></strong>. Like, ever.
		</p>

		<p>
			What do I mean when I say function scoping is weird and scary? It means your variable can keep on living outside of the curly 
			braces where it's declared. So you can do stuff like
		</p>

		<pre><code>
for (var i = 0; i < 10; i++) {
	try {
		processItem(items[i]);
	} catch (e) {
		break;
	}
}
console.log(`Successfully processed ${i} items`);
		</code></pre>

		<p>or</p>

		<pre><code>
var hour = (new Date()).getHours();
if (hour < 13) {
	var greeting = 'Good morning!';
} else {
	var greeting = 'Good afternoon!';
}
console.log(greeting);
		</code></pre>

		<p>
			In the first example, we're declaring the variable <code>i</code> inside the <code>for</code> loop, then accessing it outside 
			the loop. In the second example, we're declaring the variable <code>greeting</code> in two different places.
		</p>

		<p>
			This might seem like a handy feature. (I know I find the second one tempting when I'm building strings conditionally!) However, this isn't how 
			variables work in most languages, so it makes our code a little more suprising. More importantly though, it's confusing because variables appear 
			to be being used in higher scopes than the one they were declared in. Especially in the second example, you have to read what's going on 
			inside the conditional blocks to be able to understand what's going on outside, which is the inverse of how clean code should work.
		</p>

		<p>
			<code>let</code> and <code>const</code> remove the possibility of doing this.
		</p>

		<pre><code>
for (let i = 0; i < 10; i++) {
	try {
		processItem(items[i]);
	} catch (e) {
		break;
	}
}
console.log(`Successfully processed ${i} items`); // Uncaught ReferenceError: i is not defined
		</code></pre>

		<p>
			Instead, we'd have to do something like
		</p>

		<pre><code>
let i;
for (i = 0; i < 10; i++) {
	try {
		processItem(items[i]);
	} catch (e) {
		break;
	}
}
console.log(`Successfully processed ${i} items`); 
		</code></pre>

		<p>
			In the second example, using <code>const</code> forces us to rethink how we're writing our code,
			resulting in something that is actually a bit cleaner.
		</p>

		<pre><code>
const hours = (new Date()).getHours();
const isMorning = hours < 13;
const greeting = isMorning ? 'Good morning!' : 'Good afternoon!';
		</code></pre>

		<h3>Array functions</h3>

		<p>
			ES6 also added a bunch of new functions to <code>Array.prototype</code>, for looping through and manipulating data. These functions 
			let us write cleaner code by allowing us to write more declarative code. Declarative code describes <i>what</i> the code should do,
			rather than <i>how</i> to do it. CSS and SQL are both examples of declarative coding taken to the extreme - 100% declarative languages.
		</p>

		<p>
			The advantage of declarative code is that it hides the implementation details that we're not interested in. For example, 
			<code>Array.protoype.forEach</code> allows us to do something for each item in an array, without worrying about the details of how
			the loop actually works. Or, to put it another way, it increases the signal-to-noise ratio.
		</p>
			
		<p>
			Of course, there is also a downside to declarative programming - you have less control. In the case of <code>forEach</code>, you 
			can't have a loop counter that is incremented by 2 each time, for example. 
		</p>

		<p>
			Let's have a look at some examples of declarative coding using JavaScript's array functions, and why they're nicer than the traditional 
			way of doing things. We'll start with <code>Array.prototype.forEach</code>, as it's conceptually the simplest.
		</p>

		<h4><code>Array.prototype.forEach</code></h4>
		
		<pre><code>myList.forEach((item, index, list) => ...do something... )</code></pre>

		<p>
			<code>Array.prototype.forEach</code> is a generic loop that will call your callback function once for each item in the given list.
			The callback function will be passed the current item, the index of the current item, and the list itself. You <i>can</i> change 
			the list from within the loop, but I strongly recommend against it, as it makes your code more difficult to understand.
		</p>

		<p>
			So, how does it work? Imagine we have a list of results.
		</p>

		<pre><code>
const results = ['pass', 'pass', 'fail', 'pass'];
		</code></pre>

		<p>
			And we want to log them to the console. In traditional JavaScript, we might do something like this...
		</p>
		 
		<pre><code>
for (let i = 0; i < results.length; i++) {
	const result = results[i];
	console.log(result);
}
		</code></pre>

		<p>Using <code>forEach</code>, that would look like...</p>

		<pre><code>
results.forEach(result => console.log(result));
		</code></pre>

		<p>
			You can see we get as much signal as the first example, but with much less noise. 
		</p>

		<p>
			Now, this is a super-contrived example. The reason for this is that <code>forEach</code> is a very generic function, which returns nothing.
			The only thing it can do is produce side-effects. While this might be useful for something like logging, in most cases you're going to want 
			to use one of the other functions.
		</p>

		<h4><code>Array.prototype.map</code></h4>

		<pre><code>myList.map((item, index, list) => ... return a boolean ...)</code></pre>

		<p>
			<code>Array.prototype.map</code> gives us the ability to convert each item in an array into a new item, while leaving the original 
			array untouched. React apps use <code>map</code> extensively to convert objects into HTML elements. You can also use it to extract 
			specific properties from objects in an array.
		</p>

		<p>
			Say we had a function for creating a new element.
		</p>

		<pre><code>
function createDiv(animal) {
	const element = document.createElement('div');
	element.innerText = animal;
	return element;
}
		</code></pre>

		<p>
			And a list of animal names to be converted to divs.
		</p>

		<pre><code>
const animals = ['bear', 'cat', 'giraffe'];
		</code></pre>

		<p>In traditional JavaScript, we could do

		<pre><code>
const elements = [];
for (let i = 0; i < animals.length; i++) {
	const animal = animals[i];
	const div = createDiv(animal);
	elements.push(div);
}
		</code></pre>

		<p>But, using <code>map</code>, we can just do</p>
		<pre><code>
const elements = animals.map(animal => createDiv(animal));
		</code></pre>

		<p>
			As another example, imagine we had a list of people, and we wanted 
			a list of their names.
		</p>

		<pre><code>
const users = [
	{ givenName: 'Phillip', familyName: 'Fry', occupation: 'delivery boy' },
	{ givenName: 'Turunga', familyName: 'Leela', occupation: 'captain' },
	{ givenName: 'Bender', familyName: 'Rodrigues', occupation: 'bending robot' }
];
		</code></pre>

		<p>Traditional JavaScript</p>
		<pre><code>
const names = [];

for (let i = 0; i < users.length; i++) {
	const user = users[i];
	const name = `${user.givenName} ${user.familyName}`;
	names.push(name);
}
		</code></pre>

		<p>Using <code>map</code></p>
		<pre><code>
const names = users.map(user => `${user.firstName} ${user.lastName}`);
		</code></pre>

		<p>We can actually simplify this even more, using object destructuring (which we'll go into shortly)</p>
		<pre><code>const names = users.map(({firstName, lastName}) => `${firstName} ${lastName}`)</code></pre>

		<h4><code>Array.prototype.find/findIndex & Array.prototype.filter</code></h4>

		<pre><code>myList.find((item, index, list) => ... return a boolean ...)</code></pre>
		<pre><code>myList.findIndex((item, index, list) => ... return a boolean ...)</code></pre>
		<pre><code>myList.filter((item, index, list) => ... return a boolean ...)</code></pre>

		<p>
			A super common task in JavaScript is to search for a particular item an array. Imagine we had list of accounts and we wanted 
			to find the one belonging to a particular user. In traditional JavaScript, we could do something like...
		</p>

		<pre><code>
let userAccount;
for (let i = 0; i < accounts.length; i++) {
	const account = accounts[i];
	if (account.name === name) {
		userAccount = account;
		break;
	}
}
		</code></pre>

		<p><code>Array.prototype.find</code> greatly simplifies this.</p>

		<pre><code>const userAccount = accounts.find(account => account.name === name)</code></pre>

		<p>Similarly, if you would prefer to find the index of an item, rather than the item itself, you can use <code>findIndex</code>.</p>

		<pre><code>
function removeAccountById(accounts, id) {
	const index = accounts.findIndex(item => item.id === id);
	accounts.splice(index, 1);
}
		</code></pre>

		<p>
			Sometimes, you don't just want to find the first item that matches your criteria - you want to find all the matching items.
			For example, rather than finding an account that matches a particular name, we might want to find all the accounts that are 
			currently active.
		</p>

		<p>In traditional JavaScript, we could do this something like...</p>

		<pre><code>
const activeAccounts = [];
for (let i = 0; i < accounts.length; i++) {
	const account = accounts[i];
	if (account.status === ACTIVE) {
		activeAccounts.push(account);
	}
}
		</code></pre>

		<p>Or we could do the same thing with <code>Array.prototype.filter...</code></p>

		<pre><code>const activeAccounts = accounts.filter(account => account.status === ACTIVE);</code></pre>

		<p>Or, with object destructuring</p>

		<pre><code>const activeAccounts = accounts.filter(({status}) => status === ACTIVE);</code></pre>

		<h4><code>Array.prototype.some and Array.prototype.every</code></h4>

		<pre><code>myList.some((item, index, list) => ... return a boolean ...)</code></pre>
		<pre><code>myList.every((item, index, list) => ... return a boolean ...)</code></pre>

		<p>
			Often, you want to check whether any item in an array meets a specific criterion. For example, imagine you have a form where the 
			user needs to enter some contact details. They can add a physical address, an email address, a phone number, or a Twitter handle.
			You want to check that they've entered at least one before you submit the form.
		</p>

		<p>In traditional JavaScript, that usually looks something like this</p>

		<pre><code>
const inputs = document.querySelectorAll('.contact');

let hasContactMethod = false;
for (let i = 0; i < inputs.length; i++) {
	const input = inputs[i];
	if (input.value) {
		hasContactMethod = true;
		break;
	}
}
		</code></pre>

		<p>We can simplify this using <code>Array.prototype.some</code></p>

		<pre><code>
const inputs = document.querySelectorAll('.contact');
const hasContactMethod = Array.from(inputs).some(input => !!input.value);
		</code></pre>

		<p>
			Note we're using <code>Array.from</code> to convert the <code>NodeList</code> returned by <code>document.querySelectorAll</code>
			into an actual array. Array functions will only work on true arrays, but just about anything that looks like an array can be converted to one.
		</p>

		<p>
			On the other hand, sometimes we want to check that <i>everything</i> in the array meets the criterion. For example, imagine we have 
			an order that contains a list of books. If all the books are digital, then we don't want to go through the shipping flow.
		</p>

		<p>In traditional JavaScript...</p>

		<pre><code>
let allDigital = true;

for (let i = 0; i < items.length; i++) {
	const item = items[i];
	if (!isDigitalMedia(item)) {
		allDigital = false;
		break;
	}
}
		</code></pre>

		<p>
			You might notice that this is essentially the same loop as the previous example, with all the trues and falses around the other way.
			As such, we could implement it using an inversion of <code>some</code>.
		</p>

		<pre><code>
const allDigital = !items.some(item => !isDigitalMedia(item));
		</code></pre>

		<p>
			This is pretty confusing though. Having to keep track of multiple negations usually makes code more difficult to understand.
			 <code>Array.prototype.every</code> lets us do the same thing, without all the the <code>!</code>s.
		</p>

		<pre><code>
const allDigital = items.every(item => isDigitalMedia(item));
		</code></pre>

		<p>Or, even better</p>

		<pre><code>const allDigital = items.every(isDigitalMedia)</code></pre>

		<p>
			Remember, you don't need to define your callbacks inline. You can always define them somewhere else and just pass in the function name.
		</p>

		<h4><code>Array.prototype.includes</code></h4>

		<pre><code>myList.includes(myItem)</code></pre>
		<pre><code>myString.includes(substring)</code></pre>

		<p>
			We've already seen a couple of ways to check whether an item exists in an array, but here's another one.
			This one is often preferable, because it's much simpler. However, it does have a drawback. It uses reference equality to check 
			whether the item you're searching for is the same as the one in the array. This means it's going to work great for strings and 
			numbers, and not so much for objects.
		</p>

		<p>Imagine that we want to check whether a user has a specific role. In traditional JavaScript, you might do something like...</p>

		<pre><code>
const isAdmin = user.roles.indexOf(Roles.ADMIN) > -1;
		</code></pre>

		<p>Using <code>includes</code> allows us to tidy this up a bit</p>

		<pre><code>const isAdmin = user.roles.includes(Roles.ADMIN)</code></pre>

		<p>This function can be particularly useful when combined with <code>map</code> extracting a primitive value, as in the following example.</p>

		<pre><code>
const someoneHasACat = users.map(user => user.pet).includes('cat');
		</code></pre>

		<p>
			And it also exists on <code>String.prototype</code>, so you can use it check for the existence of substrings. The String protoype also 
			includes new methods to check specifically whether the substring occurs at the start or end of the string.
		</p>

		<pre><code>
'elephant'.includes('ant'); // true 
'elephant'.startsWith('ant'); // false
'elephant'.endsWith('ant'); // true
		</code></pre>

		<h4><code>Array.prototype.reduce</code></h4>

		<pre><code>myList.reduce((acc, curr) => { ... do stuff ... }, startingValue);</code></pre>

		<p>
			This is the most flexible of the array functions - all the others can actually be implemented using <code>reduce</code>.
			Unfortunately, it's also a little tricky to understand.
		</p>

		<p>
			Unlike the other array functions, <code>reduce</code> takes two parameters: a callback, which is called for every item in the 
			list, and a starting value, which is passed into the callback on the first call.
		</p>

		<p>
			The callback also takes two parameters: the accumulated value, and the current value. The current value is the next item in the list.
			The first time the callback is called, the accumulated value is the starting value passed into <code>reduce</code>. Every other time, 
			it's the value returned from the previous pass of the callback.
		</p>

		<p>The traditional example for demonstrating <code>reduce</code> is to sum the values in an array, so let's look at that.</p>

		<pre><code>
const numbers = [2, 7, 3];
const total = numbers.reduce((sum, number) => sum + number, 0); // 12
		</code></pre>

		<p>Let's break it down step by step</p>

		<ol>
			<li>The callback is called with the starting value and the first number: (0, 2) => 0 + 2, which returns 2</li>
			<li>The callback is called with the previous returned value, and the second number: (2, 7) => 2 + 7, which returns 9</li>
			<li>The callback is called with the previous returned value, and the third number: (9, 3) => 9 + 3, which returns 12, our final value</li>
		</ol>

		<p>
			It turns out that summing the contents of an array isn't actually a thing that comes up that often though. Luckily, <code>reduce</code>
			can be used for other things! The most common is turning an array "inside out". Say we had an API that returned a list of hospitals 
			that a doctor had shifts at. And for each hospital, it had a list of shifts at that hospital. We could find a list of all the 
			shifts the doctor had at all hospitals using <code>reduce</code>.
		</p>

		<pre><code>
const shifts = getHospitals((shifts, hospital) => shifts.concat(hospital.shift), []);
		</code></pre>

		<p>
			While <code>reduce</code> is an undeniably powerful operator, it's important to remember that it can be quite difficult to 
			understand. A lot of the time it's going to be simpler to use a combination of other operators, even if it's more verbose.
		</p>

		<p>
			Take this example (based on a true story). We've got a list of devices. 
			We've also got a form with a list of checkboxes. Each checkbox correlates to a device in the list - so the first 
			checkbox is for the first device, the second checkbox is for the second device, and so on. We want to get the list of 
			codes belonging to the devices that the user has selected.
		</p>

		<pre><code>
const selectedDeviceCodes = checkboxes.reduce((codes, checkbox, index) => {
	if (checkbox.selected) {
		codes.push(devices[index].code);
	}
	return codes;
}, []);
		</code></pre>

		<p>
			Alternatively, we could have implemented the same logic using a combination of <code>filter</code> and <code>map</code>.
		</p>

		<pre><code>
const selectedDeviceCodes = devices.filter((device, index) => checkboxes[index].selected)
															 .map(device => device.code)
		</code></pre>

		<p>
			Here, we start with the list of devices. We filter the list by checking if the corresponding checkbox has been checked. 
			Then we map the list of devices to their values. I certainly find this logic to be much easier to follow, but your 
			mileage may vary.
		</p>

		<p>
			Now, I'm not saying don't use <code>reduce</code> at all, just make sure you've considered all options first.
			And get someone else to have a look at your implementation, if you can.
		</p>

		<h4>Async array functions</h4>

		<p>
			While these new array functions provide a fantastic way to write cleaner code, there is one small gotcha you should be aware of:
			using array functions with <code>async/await</code>.
		</p>

		<p>
			When you use <code>async/await</code> in a traditional loop, like this...
		</p>

		<pre><code>
async function setPrices(items) {
	for (let i = 0; i < items.length; i++) {
		const item = items[i];
		const price = await getPrice(item.id);
		item.price = price;
	}
}
		</code></pre>

		<p>
			...the loop will pause on each iteration, wait for the price to be returned, and then continue.
		</p>

		<p>
			We can try and do the same thing using <code>forEach</code>
		</p>

		<pre><code>
function setPrices(items) {
	items.forEach(async (item) => {
		const price = await getPrice(item.id);
		item.price = price;
	});
}
		</code></pre>

		<p>
			You'll notice that it's the callback function that is <code>async</code> in this case - not the <code>setPrices</code> function. 
			This is because 
			<code>await</code> can only be used immediately inside an <code>async</code> function. This means that 
			the callback function will fire off the request to fetch the price, and then immediately continue to the 
			next item, without waiting for the response to come back.
		</p>

		<p>
			Now, in this particular situation, that's probably the behaviour that you want. This code is going to fetch all the 
			prices in parallel, which is going to be faster than fetching them one-by-one, as in the traditional loop.
			However, you've got no way of knowing when all the prices have finished being fetched!
		</p>

		<p>
			If we do need to know when the prices have all been fetched, we can take advantage of the fact that an 
			<code>async</code> function always returns a Promise, which resolves when the function returns.
		</p>

		<pre><code>
async function setPrices(items) {
	const promises = items.map((item) => {
		const price = await getPrice(item.id);
		item.price = price;
	});

	await Promise.all(promises);
}
		</code></pre>

		<p>
			This code will 
		</p>
		<ol>
			<li>Generate a promise for each item in the list, and add it to the <code>promises</code> array</li>
			<li>Wait until all of the promises in the <code>promises</code> array have been resolved before returning</li>			
		</ol>

		<p>And, at the same time</p>
		<ol>
			<li>Fetch all of the prices in parallel</li>
			<li>Resolve each promise in the <code>promises</code> array, once the price has been set for the related item</li>
		</ol>

		<p>
			However, sometimes this parallel behaviour isn't what you want. Instead, you want to wait for each request 
			to return before making the next request. In these cases, you're better off using a more traditional loop. However,
			there is a more declarative version of the <code>for</code> loop available in JavaScript.
		</p>

		<pre><code>
for (const item of items) {
	try {
		await placeOrder(item);
	} catch (e) {
		console.log('Couldn\'t place all orders. Giving up.');
		break;
	}
}
		</code></pre>

		<p>
			This code will wait until each order has been successfully placed before placing the next order. If any order fails, it will 
			give up. This type of loop still removes some of the boilerplate associated with your basic <code>for</code> loop, and will 
			work with anything array-like (including our <code>NodeList</code> from above).
		</p>

		<p>Two things to note, in order of importance</p>
		<ol>
			<li>
				This is a <code>for ... of</code> loop. It is a different beast from a <code>for ... in</code> loop, and should not be confused with
				it. The <code>for ... of</code> loop iterates through the items in an array-like thing. The <code>for ... in</code> loop iterates 
				through the properties of an object. If you can think of a way to remember which is which, I'd love to hear it.
			</li>
			<li>
				You can declare your <code>item</code> using <code>const</code>, if you want. This is due to the way scope works in <code>for</code>
				loops in JavaScript. Check out this <a href="https://www.youtube.com/watch?v=Nzokr6Boeaw">HTTP203 video on for loops</a> if you're 
				interested in understanding why.
			</li>
		</ol>

		<h3>Other ways to reduce noise</h3>

		<p>
			Modern JavaScript also has a bunch of "shorthand" features - essentially ways to increase the signal-to-noise ratio of your code 
			by removing boilerplate and repetition. Some of them can seem a little hard to wrap your head around at first. I strongly encourage 
			you to learn how they work though, and then decide for yourself whether using them makes your code cleaner or not. If you do decide 
			you like them, you might also want to consider adding linter rules enforcing their usage.
		</p>

		<h4>Object property shorthand</h4>

		<p>
			Probably the simplest to wrap your head around, the object property shorthand can be used when you have an object property whose 
			name and value are the same. It allows you to omit the value, leading to less repeated code.
		</p>

		<pre><code>
const name = 'Leia Organa';

// old JavaScript
const request = { name: name };

// with shorthand 
const request = { name };
		</code></pre>

		<p>
			While this shorthand is usually straightforward to understand, it can get confusing when you're using a mixture of 
			shorthand and non-shorthand values. In these cases, a bit of formatting can be very helpful.
		</p>

		<pre><code>
// a bit confusing
const request = { method: 'GET', name, birthDate, accountNumber: accountId, accountType };

// better 
const request = {
	method: 'GET',
	name,
	birthDate,
	accountNumber: accountId,
	accountType
};
		</code></pre>

		<h4>Object destructuring</h4>

		<p>
			While the object property shorthand makes it easier to create objects, object destructuring makes it easier to extract things 
			out of objects. Imagine that we have an account object like so...
		</p>

		<pre><code>
const account = {
	name: 'Ellen Ripley',
	type: 'PHONE',
	number: '34352';
}
		</code></pre>

		<p>In old school JavaScript, you could extract the properties into their own variables like so.</p>

		<pre><code>
const name = account.name; // 'Ellen Ripley'
const type = account.type; // 'PHONE'
const number = account.number; // '34352'
		</code></pre>

		<p>Modern JavaScript, however, let's us do this!</p>

		<pre><code>
const { name, type, number } = account;

console.log(name); // 'Ellen Ripley'
console.log(type); // 'PHONE'
console.log(number); // '34352'
		</code></pre>

		<p>
			This code will create three new variables - <code>name</code>, <code>type</code>, and <code>number</code>. It will set the value of these 
			variables to the values of the properties of <code>account</code> which have the same names. 
		</p>

		<p>
			We can also use destructuring when the property name is not the same as the variable name we want to use.
		</p>

		<pre><code>
const { number: id } = account;

console.log(id); // '34352'
		</code></pre>

		<p>
			Note that the property name goes first, the variable being declared second. So here, we are declaring a variable named <code>id</code>, which is 
			taking the value of <code>account.number</code>. I personally find this a little confusing, and would think twice about using it.
		</p>

		<p>
			We can also extract properties that are nested inside the target object.
		</p>

		<pre><code>
const user = {
	name: 'Princess Zelda',
	contactDetails: {
		type: 'TWITTER'
		value: '@zelda'
	}
};

const { contactDetails: { value }} = user;
console.log(value); // '@zelda'
		</code></pre>

		<p>You can even combine nested values with renaming values.</p>

		<pre><code>
const { contactDetails: { value: twitterHandle }} = user;

console.log(twitterHandle); // '@zelda'
		</code></pre>

		<p>However, at this point, I would be seriously considering if this is really better than just using </p>

		<pre><code>
const twitterHandle = user.contactDetails.value;
		</code></pre>

		<p>
			One place, however, where I think object destructuring is particularly useful, is in function parameters.
			Imagine we have a function that receives a config option like so...
		</p>

		<pre><code>
function makeRequest(config) {
	const method = config.method;
	const url = config.url;

	const request = { method, url };

	if (method === 'POST') {
		request.body = config.body;
	}
}
		</code></pre>

		<p>We can simplify this using object destructuring!</p>

		<pre><code>
function makeRequest({ method, url, body }) {
	const request = { method, url };

	if (method === 'POST') {
		request.body = body;
	}
}
		</code></pre>

		<p>
			Not only does this save us from assigning the variables manually, it also makes it clear 
			which properties the config object should have.
		</p>

		<h4>Array destructuring</h4>

		<p>
			But wait - there's more! Objects aren't the only thing that can be destructured: we can do the same thing with arrays!
			For example, the new <code>Object.entries</code> function returns the properties of an object as a array of arrays 
			containing the property name and value.
		</p>

		<pre><code class="js">
const account = {
	name: 'Ellen Ripley',
	type: 'PHONE',
	number: '34352';
}

const properties = Object.entries(account);
console.log(properties); // [['name', 'Ellen Ripley'], ['type', 'PHONE'], ['number', '34352']];
		</code class="js"></pre>

		<p>Array destructuring can make processing these properties simpler.</p>
		
		<pre><code>
const firstProperty = properties[0]; // ['name', 'Ellen Ripley']
const [name, value] = firstProperty;

console.log(name); // 'name'
console.log(value); // 'Ellen Ripley'
		</code></pre>

		<p>We can use array destructuring on function parameters as well.</p>

		<pre><code>
const copyOfAccount;

properties.forEach(([name, value]) => {
	copyOfAccount[name] = value;
});
		</code></pre>

		<p>Array destructuring can also be used to swap variables without using a temp variable.</p>

		<p>Traditional JavaScript...</p>
		<pre><code>
let leftPane = viewport;
let rightPane = devTools;

// traditional swap 
let temp = leftPane;
leftPane = rightPane;
rightPane = leftPane;

console.log(leftPane); // devTools
console.log(rightPane); // viewport;
		</code></pre>

		<p>With array destructuring...</p>
		
		<pre><code>
let leftPane = viewport;
let rightPane = devTools;

[leftPane, rightPane] = [rightPane, leftPane]
		</code></pre>

		<p>I don't think I've ever run into an actual use case for this, but you can totally do it, if you need to.</p>

		<h4>Rest parameters & the spread operator</h4>

		<p>
			Rest and spread are essentially the same operator, used in different situations. They're used for converting groups of things into 
			arrays or objects, and vice versa. Both are represented by three dots (...).
		</p>

		<p>
			Rest parameters are used to convert an array into a list of arguments, or to convert a list of arguments into an array. This is helpful 
			when dealing with functions which can accept any number of arguments. For example, the built-in function <code>Math.min()</code> takes 
			any number of numbers and returns the lowest.
		</p>

		<pre><code>console.log(Math.min(4, 63, -2, 0, -79)) // -79</code></pre>

		<p>
			Historically, this was pretty limiting. For example, you couldn't use <code>Math.min()</code> to find the smallest of an array of numbers.
			Instead, it was necessary to wrap the function up using <code>apply</code>.
		</p>

		<pre><code>
const numbers = [4, 63, -2, 0, -79];
const smallest = Math.min.apply(undefined, numbers);
		</code></pre>

		<p>
			(If you're not familiar with <code>apply</code>, its primary purpose is to define the value of <code>this</code> when a function 
			is called. For more information on <code>apply</code> - and its close relative <code>call</code> - check out 
			<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/apply">MDN's article 
			on Function.prototype.apply</a>. For more information on <code>this</code> and how <code>this</code>-binding works, wait for the next 
			section!)
		</p>

		<p>
			Now, while using <code>apply</code> certainly works, it's not exactly the most elegant code. What is that <code>undefined</code> doing 
			in the middle there? (We actually don't care about the value of <code>this</code> in this example, so we could have passed anything in 
			as that first argument, which is even more confusing).
		</p>

		<p>
			Rest parameters make this much nicer.
		</p>

		<pre><code>
const numbers = [4, 63, -2, 0, -79];
const smallest = Math.min(...numbers);
		</code></pre>

		<p>
			Rather than stuffing around with esoteric functions on the <code>Function</code> prototype, we can just use the <code>...</code>
			operator to convert the array into a list of arguments.
		</p>

		<p>
			Rest parameters also work the other way - to convert a list of arguments into an array. For example, we could define a <code>sum</code>
			function, which takes any number of arguments, and returns the sum of all of them.
		</p>

		<pre><code>
function sum(...numbers) {
	numbers.reduce((total, number) => total + number, 0);
}

console.log(sum(4, 9, 17, 23)); // 53
		</code></pre>

		<p>
			Generally speaking, I think rest parameters are more useful in the first case - passing an array into an existing function that doesn't 
			accept an array. The second case essentially takes a function that works with an array, and makes it look like it doesn't work with an 
			array. You'd want to think very carefully about why you're doing that.
		</p>

		<p>
			The other thing that <code>...</code> can do is act as a spread operator. The spread operator converts an array into a kind of "array fragment"
			that can then be used inside another array. We can use this for concatenating arrays, or for adding new values to an array.
		</p>

		<pre><code>
const cats = ['Burmese', 'Siamese', 'Ragdoll'];
const dogs = ['Labrador', 'Husky', 'Kelpie'];

const pets = [...cats, ...dogs];
console.log(pets); /// ['Burmese', 'Siamese', 'Ragdoll', 'Labrador', 'Husky', 'Kelpie'];

const moreDogs = [...dogs, 'Shiba Inu', 'Beagle'];
console.log(moreDogs); // ['Labrador', 'Husky', 'Kelpie', 'Shiba Inu', 'Beagle'];
		</code></pre>

		<p>
			If it helps, you can think of the spread operator as creating a copy of your array, and stripping off the brackets, allowing you 
			to stick multiple arrays together without ending up with them all nested.
		</p>

		<p>
			The spread operator can also be used on objects. In that case, it essentially creates a copy and removes the curly braces.
			You can use this for extending objects with more properties.
		</p>

		<pre><code>
const person = {
	name: 'Amy Wong',
	birthday: '2978-12-03'
};

const employee = {
	...person,
	role: 'intern'
};

console.log(employee); // { name: 'Amy Wong', birthday: '2978-12-03', role: 'intern' }
		</code></pre>

		<p>
			And, if you recall from the section on using idioms, the other thing you can use the spread operator for is 
			creating copies! Just remember that it creates a shallow copy, with the nested objects passed as references.
		</p>

		<pre><code>
// Array destructuring
const birbs = ['Canary', 'Rosella', 'Galah'];
const copyOfBirbs = [...birbs];

birbs.push('Cockatoo');
console.log(birbs); // ['Canary', 'Rosella', 'Galah', 'Cockatoo']
console.log(copyOfBirbs); // ['Canary', 'Rosella', 'Galah']

// Object destructuring
const postageDetails = {
	height: 47,
	width: 23,
	cost: {
		amount: 10,
		currency: 'AUD'
	}
};
const copyOfPostageDetails = {...postageDetails};

postageDetails.width = 58;
postageDetails.cost.amount = 22;

console.log(postageDetails); // { height: 47, width: 58, cost: { amount: 22, currency: 'AUD' } }
console.log(copyOfPostageDetails); // { height: 47, width: 23, cost: { amount: 22, currency: 'AUD' } }
		</code></pre>

		<p>
			<code>copyOfPostageDetails</code> is a copy, so altering the <code>width</code> of <code>postageDetails</code>
			doesn't affect <code>copyOfPostageDetails</code>. However, it's only a shallow copy, so <code>copyOfPostageDetails</code>
			gets a reference to <code>postageDetail</code>'s <code>cost</code>. As a result, changes to
			<code>postageDetails.cost</code> also appear in <code>copyOfPOstageDetails.cost</code>.
		</p>

		<h4>Default parameter values</h4>

		<p>
			The last topic I wanted to touch on in this section is default parameter values. Due to the nature of JavaScript, all function
			parameters are essentially optional. If a function expects an argument, and you don't pass anything in, it's simply undefined.
		</p>
		
		<pre><code>
function sayHello(name) {
	console.log('Hello', name);
}

sayHello(); // Hello undefined
		</code></pre>

		<p>
			As a result, it's usually a good idea to check that arguments have been set. If they haven't, you can either set them to some 
			sensible default, or throw an exception.
		</p>

		<pre><code>
function sayHello(name) {
	name = name || 'world';
	console.log('Hello', name);
}

sayHello('Captain Janeway'); // Hello Captain Janeway
sayHello(); // Hello world
		</code></pre>

		<p>
			Setting a bunch of default values can get a bit cumbersome, so modern JavaScript gives us a simpler way to do it.
		</p>

		<pre><code>
function sayHello(name = 'world') {
	console.log('Hello', name);
}

sayHello(); // Hello world
		</code></pre>

		<p>
			One small thing to remember - parameters with default values need to appear at the end of the argument list. Of course,
			this won't be that much of a problem, as we only write functions with one or two parameters, right?
		</p>

		<p>
			Also, your default values absolutely can refer to previous parameters.
		</p>

		<pre><code>
function registerUser(name, preferredName = name) {
	createUser(name);
	printNameBadge(preferredName);
}
		</code></pre>

		<h3>This binding & how arrow functions can help</h3>

		<p>
			The final part of modern JavaScript I wanted to talk about is arrow functions. By this point you've seen me using them all over the place.
			They provide a nice way to write callbacks inline - they're a little shorter to declare than normal functions, and a single line 
			arrow function has an implicit return, saving even more characters.
		</p>

		<pre><code>
const evenNumbersNormalFunction = numbers.filter(function (number) {
	return number % 2 === 0;
});

const evenNumbersArrowFunction = numbers.filter(number => number % 2 === 0);
		</code></pre>

		<p>
			As you can see, the arrow function is shorter, and has a greater signal-to-noise ratio. However, arrow functions are special for another 
			reason too. To understand this, we need to look at the <code>this</code> keyword in JavaScript.
		</p>

		<p>
			Understanding how <code>this</code> works can be one of the most challenging parts of learning JavaScript. The rules themselves aren't 
			super complicated, it's just that there are a lot of them. Often, you'll see people working around <code>this</code> by using code like 
		</p>

		<pre><code>
const that = this;
		</code></pre>

		<p>
			While this hack works (and is used a lot), it's not really clean code. We're adding variables that don't add any meaning. And, in older code, 
			before the introduction of <code>const</code>, there was nothing stopping us from assigning <code>that</code> to something else. Today,
			there are plenty of ways to manage <code>this</code> without resorting to hacks.
		</p>

		<p>
			So how does <code>this</code> work? As a general rule, in JavaScript, <code>this</code> refers to the object that called the function.
			However, there are a few ways to override that. Also, it's important to remember that <code>this</code> refers to the object that 
			<i>called</i> the function, not the object that defined it.
		</p>

		<pre><code>
const uhura = {
	givenName: 'Nyota',
	familyName: 'Uhura',
	sayHello: function () {
		console.log('hello', this.givenName, this.familyName);
	}
};

const scully = {
	givenName: 'Dana',
	familyName: 'Scully',
	sayHello: uhura.sayHello
};

uhura.sayHello(); // Hello Nyota Uhura
scully.sayHello(); // Hello Dana Scully
		</code></pre>

		<p>
			You'll notice that even though <code>scully.sayHello</code> calls <code>uhura.sayHello</code>, <code>this</code> refers to 
			<code>scully</code>, <strong>not</strong> <code>uhura</code>. This can be confusing, especially if you've come from a language 
			that doesn't work this way, but it makes a lot of sense in a language that deals with event handlers.
		 </p>
		 
		 <pre><code>
const button = document.getElementById('special-button');
button.addEventListener('click', function () {
	console.log(this); // button
});
		 </code></pre>

		<p>However, like I said, there are a bunch of ways to override this default behaviour.</p>
		<ol>
			<li>
				If the function is called from the global scope, with no caller object, <code>this</code> refers to the <code>window</code> object.
				<pre><code>
window.name = 'Global demo';
const person = {
	name: 'Sarah Connor',
	sayHello: function () {
		console.log('Hello', this.name);
	}
}

const sayHello = person.sayHello;
sayHello(); // Hello Global demo
				</code></pre>
				I mean, this isn't really overriding the default behaviour, just kind of dealing with a situation where the default 
				behaviour is unclear, because there is no obvious caller.
			</li>
			<li>
				If the function is called from a strict global context, <code>this</code> is undefined. Any code written inside a module 
				is in strict mode, as is any code with a <code>'use strict';</code> declaration.

				<pre><code>
const person = {
	name: 'Sarah Connor',
	sayHello: function () {
		'use strict';
		console.log('Hello', this.name);
	}
}

const sayHello = person.sayHello;
sayHello(); // Uncaught TypeError: Cannot read property 'name' of undefined
				</code></pre>
			</li>
			<li>
				If the function is called via <code>call</code> or <code>apply</code>, then <code>this</code> refers to the first argument 
				of <code>call</code> or <code>apply</code>.

				<pre><code>
const person = {
	name: 'Sarah Connor',
	sayHello: function () {
		console.log('Hello', this.name);
	}
};

const anotherPerson = {
	name: 'Katniss Everdeen'
};

person.sayHello.call(anotherPerson); // Hello Katniss Everdeen
				</code></pre>
			</li>
			<li>
				If the function was created via <code>bind</code>, then <code>this</code> refers to the first argument of <code>bind</code>.
				This can't be overridden via <code>call</code> or <code>apply</code>

				<pre><code>
const person = {
	name: 'Sarah Connor',
	sayHello: function () {
		console.log('Hello', this.name);
	}
};

const anotherPerson = {
	name: 'Katniss Everdeen'
};

const boundHello = person.sayHello.bind(anotherPerson);

boundHello(); // Hello Katniss Everdeen 
boundHello.call(person); // Hello Katniss Everdeen
				</code></pre>
			</li>
			<li>
				And finally, if the function is called with the <code>new</code> keyword, then <code>this</code> refers to a brand new object, 
				that will be returned by the function. This can't be overridden by binding the function.

				<pre><code>
function Ship(name) {
	this.name = name;
}

// 1
const objectShip = Ship('Planet Express');
console.log(objectShip.name); // Uncaught TypeError: Cannot read property 'name' of undefined

// 2
const constructedShip = new Ship('Planet Express');
console.log(constructedShip.name); // Planet Express

// 3
const boundShip = Ship.bind({ name: 'Millenium Falcon' });
const constructedBoundShip = new boundShip('Planet Express');
console.log(constructedBoundShip.name); // Planet Express
				</code></pre>

				<p>
					In the first example, we didn't use the <code>new</code> keyword, so within <code>Ship()</code>, <code>this</code> refers to 
					<code>window</code>. Additionally, <code>Ship()</code> doesn't actually return anything.
				</p>

				<p>
					In the second example, using the <code>new</code> keyword turns <code>Ship</code> into a constructor. Constructors create a brand new 
					object, and return it implicitly. (You don't need to have an explicit return statement in a constructor.) Within a constructor,
					<code>this</code> refers to the newly created object. 
				</p>

				<p>
					In the third example, we create a new function, <code>boundShip</code>, but calling <code>bind</code> on <code>Ship</code>.
					We call <code>boundShip</code> as a constructor. Within the constructor, <code>this</code> still refers to the newly 
					constructed object - not the object we passed into <code>bind</code>.
				</p>
			</li>
		</ol>

		<p>
			All of this changes with arrow functions though. Arrow functions essentially don't bind <code>this</code>.
		</p>

		<pre><code>
const uhura = {
	givenName: 'Nyota',
	familyName: 'Uhura',
	sayHello: () => {
		console.log('hello', this.givenName, this.familyName);
	}
};

uhura.sayHello(); // Hello undefined undefined
		</code></pre>

		<p>Instead, they'll use the <code>this</code> from the context that they're declared in.</p>

		<pre><code>
class Person {
	constructor(name) {
		this.name = name;
		this.sayHello = () => console.log('Hello', this.name);
	}
}

const uhura = new Person('Uhura');
uhura.sayHello(); // Hello Uhura
		</code></pre>

		<p>So how does <code>this</code>-binding in arrow functions behave in our exceptional circumstances?</p>
		<ol>
			<li>
				In global context, it works the same as in normal functions. <code>this</code> will refer to the window object in 
				non-strict contexts, and be <code>undefined</code> in strict contexts.
			</li>
			<li>
				Calling an arrow function via <code>call</code> or <code>apply</code> has no effect. <code>this</code> will refer to the same 
				thing it would have referred to if you didn't use <code>call</code> or <code>apply</code>

				<pre><code>
class Person {
	constructor(name) {
		this.name = name;
		this.sayHello = () => console.log('Hello', this.name);
	}
}

const uhura = new Person('Uhura');
const katniss = { name: 'Katniss' };

uhura.sayHello.call(katniss); // Hello Uhura
				</code></pre>
			</li>
			<li>
				Creating a function from an arrow function with <code>bind</code> also has no effect.
				<pre><code>
class Person {
	constructor(name) {
		this.name = name;
		this.sayHello = () => console.log('Hello', this.name);
	}
}

const katniss = { name: 'Katniss' };
const boundPerson = Person.bind(katniss);

const uhura = new boundPerson('Uhura');
uhura.sayHello.call(katniss); // Hello Uhura
				</code></pre>
			</li>
			<li>
				And finally, you can't use <code>new</code> on an arrow function.

				<pre><code>
const Person = (name) => ({ name });
const person = new Person('Uhura'); // Uncaught TypeError: Person is not a constructor
				</code></pre>
			</li>
		</ol>

	</section>
	
	<section class="incomplete"><h2 id="architecting-applications">Architecting applications</h2></section>
	<section class="incomplete"><h2 id="testing">Testing</h2></section>

	<section>
		<h2 id="semantic-html">Semantic HTML & accessibility</h2>

		<p>
			Semantic HTML refers to HTML that uses elements that have intrinsic meaning. For example, if you're creating something for a user 
			to click on, then you should use a <code>&lt;button&gt;</code>, rather than a <code>&lt;div&gt;</code>. It's often spoken about in 
			the context of accessibility, but it's important to remember that accessible code isn't just about making your code work with a 
			screen reader.
		</p>

		<ul>
			<li>
				Using semantic HTML adds meaning to your code, increasing the signal-to-noise ratio. It's far easier to understand as a developer.
			</li>
			<li>
				Web page users expect certain types of elements to behave in certain ways. If you use the correct semantic element, you
				get a lot of this behaviour for free. This means you don't have to write as much code, and you're less likely to introduce 
				bugs.
			</li>
			<li>
				You don't know what type of device a user is going to use to interact with your app. It could be a mouse and keyboard, or a touch-screen,
				or a less common device like a watch, a gaming controller, or a screen reader.  Using semantic HTML means your app follows 
				a standard that will help it work correctly on all those devices - as well as a bunch that haven't been invented yet!
			</li>
		</ul>

		<aside style="margin: calc(var(--margin-size) * 1.5) 0">
			<h3>What about ARIA?</h3>

			<p>
				ARIA is a set of attributes that you can add to your HTML elements to provide hints to the browser for building the accessibility tree.
				The accessibility tree is used by screen readers to provide information to screen reader users that sighted users can get visually.
			</p>
			
			<pre><code>
&lt;label&gt;Please send me spam&lt;/label&gt;
&lt;input type="checkbox" aria-label="please send me spam"&gt;
			</code></pre>

			<p>
				A screen reader encountering the above <code>&lt;input&gt;</code> element will read out that it has a label of <code>please send me spam</code>.
			</p>

			<p>
				The thing about ARIA though, is that it's actually quite difficult to get right. And the majority of the time, you can accomplish the 
				same thing just using plain HTML. For example...
			</p>

			<pre><code>
&lt;label for="spam"&gt;Please send me spam&lt;/label&gt;
&lt;input id="spam" type="checkbox"&gt;
			</code></pre>

			<p>
				...achieves the exact same thing, from the screen reader's point of view. It also has the added bonus of linking the <code>&lt;label&gt;</code>
				to the <code>&lt;input&gt;</code> without needing to maintain two versions of the label text.
			</p>

			<p>
				Furthermore, ARIA doesn't add the functionality that you get from using semantic HTML. An HTML <code>&lt;button&gt;</code> element can be 
				tabbed to, and activated via pressing the enter key or space bar. Adding <code>role="button"</code> to a <code>&lt;div&gt;</code> does not 
				bestow these abilities on it. Similarly, in the first example above (the one using <code>aria-label</code>), the user must click on the 
				<code>&lt;input&gt;</code> element to change the value of the checkbox. In the second example, the user can click on the <code>&lt;label&gt;</code>
				element as well, greatly increasing the clickable area, and improving usability.
			</p>

			<p>
				Generally speaking, compared to using semantic HTML, using ARIA is far more difficult, and provides benefits to far fewer of your users.
			</p>

			<p>
				Now, that doesn't mean you're never going to need ARIA. Sometimes there are just things that work well for sighted users that aren't going 
				to work well with a screen reader. For example, if you update part of a page after a screen-reader user as already read it, then you 
				need a way to notify the user of the change. ARIA is perfect for this.
			</p>

			<p>
				Just remember that while ARIA <i>is</i> important, it shouldn't be the first tool that you reach for when building accessible apps.
			</p>			
		</aside>

		<p>So what does semantic HTML look like?</p>

		<h3>Landmarks & descriptions</h3>

		<p>
			Every page should contain some landmarks. Landmarks are things like headings, sections, navigation, and sidebars. Using these types of 
			elements is generally essential for good design - imagine trying to read this page if it wasn't broken up into sections, 
			or didn't have any headings!
		</p>
		
		<p>If we use semantic HTML to demark these elements, then our page will still be 
			navigable in situations where we can't rely on CSS - such as with a screen reader; but also on a slow internet connection, where the 
			CSS hasn't loaded, in a browser's Reader mode, or when user is otherwise using custom stylesheets, or when the next developer is reading the
			HTML in an IDE.
		</p>

		<figure class="example">
			<img src="images/no-css.png" alt="The current page, with no CSS. The browser default styles mean it is still quite readable.">
			<figcaption>
				The current page, without CSS. As you can see, it's still quite readable. The headings, paragraphs, lists, and links are all 
				clearly marked. Even the quote from Martin Fowler has a special "quote" style.
			</figcaption>
		</figure>

		<p>
			Landmark HTML elements include heading tags (<code>&lt;h1&gt; - &lt;h6&gt;</code>), <code>&lt;header&gt;</code>, <code>&lt;footer&gt;</code>,
			<code>&lt;nav&gt;</code>, <code>&lt;main&gt;</code>, and <code>&lt;aside&gt;</code> elements. Not every page is going to have all of 
			these features, but if your page has any of them, then you should use the appropriate element.
			This fits with the clean coding principles we were discussing earlier - communicate your intent by using meaningful names.
		</p>

		<h4>Titles</h4>

		<p>
			If you're building a SPA with multiple logical pages, then you should give each page a distinct title via the 
			<code>&lt;title&gt;</code> element, within <code>&lt;head&gt;</code>. For example, on Twitter, the feed page has the title <code>Latest Tweets / Twitter</code>, while the 
			notifications page is <code>Notifications / Twitter</code>. These titles help screen reader users know when they've navigated to a new 
			page, but they also help sighted users distinguish between browser tabs, as the <code>&lt;title&gt;</code> element is used as the tab 
			title. The title should include the specific page name, followed by your app name. (Put the app name last. The tab title is likely to be 
			truncated, and sighted users can use the favicon to distinguish between apps.)
		</p>

		<img src="images/twitter-titles.png" alt="each page on Twitter has a distinctive title, displayed in the tab heading">

		<h4>Describing inputs</h4>

		<p>
			As well as having some landmarks, we should make sure we have appropriate descriptions for our elements. This is most relevant for 
			<code>&lt;input&gt;</code> elements (where we're asking the user to do something), and images (which might not be available, due to network
			conditions, or device restrictions, or might not be visible, due to the user's vision, or lighting, or screen glare).
		</p>

		<p>
			Every <code>input</code> element should have an obvious label that remains visible while the user is interacting with the element.
			This means that placeholder text that disappears when the input has focus is not enough. Disappearing labels can be particularly 
			difficult for users with cognitive difficulties, but they also make life harder for users who are using your app while distracted 
			by something else. If you are particularly enamoured of inline labels, try something like Google's Material Design labels, which 
			start inline, but move above the input once you start typing.
		</p>

		<figure class="example">

			<style>
				#md-label-example {
					position: relative;
					padding: 20px 0;
					margin-top: 10px;
				}
				#md-label-example label {
					left: 5px;
					top: 25px;
					position: absolute;
					font-size: 18px;
					transition: all .5s;
					font-weight: bold;
				}
				#md-label-example input:focus + label, #md-label-example input:valid + label {
					top: -5px;
					left: 0;
					font-size: 16px;
				}
			</style>

			<div id="md-label-example">
				<input id="md-name" required>
				<label for="md-name">Name</label>
			</div>
			<figcaption>
				Interactive demo of a material-design-style input and label. While you're welcome to use the code for this demo, just bear 
				in mind that it relies on the input field being <code>required</code>, and probably isn't suitable for production.
			</figcaption>
		</figure>

		<p>
			Ideally, you should use a <code>&lt;label&gt;</code> element to label your <code>&lt;input&gt;</code> element. The <code>&lt;input&gt;</code>
			should be a child of the <code>&lt;label&gt;</code> <i>or</i> they should be linked via <code>for</code> and <code>id</code> attributes.
		</p>

		<pre><code>
&lt;label&gt;
	&lt;input type="checkbox"&gt; Yes! Please send me spam!
&lt;/label&gt;

&lt;label for="favourite-book"&gt;What is your favourite book?&lt;/label&gt;
&lt;input type="text" id="favourite-book"&gt;
		</code></pre>

		<p>
			Linking labels and inputs like this means that a click on the <code>&lt;label&gt;</code> is treated like a click on the 
			<code>&lt;input&gt;</code>. For checkboxes and radiobuttons, this means the item will be selected just by clicking the label. 
			This increases the clickable area, which is particularly helpful on small screens. It also provides us with opportunities to style 
			our radiobuttons and checkboxes in an accessible way, as we can add the styling to the label.
		</p>

		<figure class="example">

			<style>
				#power-button {
					--diameter: 40px;
					width: var(--diameter);
					height: var(--diameter);
					border: 4px solid;
					border-radius: 50%;
					position: relative;
					border-color: grey;
					margin-left: .7em;
					transition: all .5s;
				}

				#power-button::before {
					--background: #333;
					content: '';
					height: 20px;
					border: 2px solid;
					border-color: inherit;
					position: absolute;
					transform: translate(-50%);
					left: 50%;
					top: -25%;
					box-shadow: 
						3px 3px var(--background),
						-3px 3px var(--background),
						3px -3px var(--background),
						-3px -3px var(--background);
				}

				#styled-checkbox {
					opacity: 0;
					position: fixed;
				}
				#styled-checkbox + label {
					display: flex;
					background-color: #333;
					color: #ddd;
					align-items: center;
					font-size: 30px;
					font-family: sans-serif;
					padding: 20px;
					cursor: pointer;
					border: 1px solid #aaa;
					border-radius: 8px;
					width: max-content;
					margin: auto;
					box-shadow: 
						inset 1px 1px 2px 1px #ccc,
						inset -1px -1px #888,
						1px 1px 3px 1px hsla(0, 0%, 20%, .3);
					transition: all .5s;
				}

				#styled-checkbox:checked + label {
					box-shadow: none;
				}

				#styled-checkbox:checked + label #power-button {
					border-color: greenyellow;
					filter: drop-shadow(0 0 10px rgba(64, 245, 47, 0.377));
				}
			</style>
			<input type="checkbox" id="styled-checkbox">
			<label for="styled-checkbox">Power <div id="power-button"></div></label>
			<figcaption>
				Interactive demo of a checkbox styled to look like a power button.
			</figcaption>
		</figure>

		<h4>Describing images</h4>

		<p>
			Images are the other types of element that are super important to describe. The rules for describing them are a bit more complicated 
			though. First of all, <strong>all</strong> <code>&lt;img&gt;</code> elements should have an <code>alt</code> attribute. Sometimes this 
			attribute will be empty, but it's still important to include it. Otherwise, screen readers will read out the filename. 
		</p>

		<p>
			If your image is illustrating a point, or providing information, then it needs a description. That description can be in the 
			text of your page. If there is no descriptive text on the page, then you need to provide a description in the <code>alt</code>
			attribute. This isnt just for accessibility either - it also helps with search engine optimisation.
		</p>

		<div class="example">
			<p>As seen in the image below, giraffes must bend down awkwardly to drink.</p>
			<img src="images/giraffe-drinking.jpg" alt="">
			<p>Horses, on the other hand, don't have that problem</p>
			<img src="images/horse-drinking.jpg" alt="horse drinking from beer glass by picking the glass up in its teeth">
		</div>

		<pre><code class="html">
...
&lt;img src="images/giraffe-drinking.jpg" alt=""&gt;
...
&lt;img src="images/horse-drinking.jpg" alt="horse drinking from beer glass by picking the glass up in its teeth"&gt;
		</code></pre>

		<p>
			(<a href="https://www.flickr.com/photos/tambako/47572147022">Giraffe drinking from the pond</a> 
			flickr photo by <a href="https://www.flickr.com/photos/tambako/">Tambako The Jaguar</a> 
			shared under a <a href="https://creativecommons.org/licenses/by-nd/2.0/">Creative Commons (BY-ND) license</a>.)
		</p>
		
		<p>
			Make sure your description describes what the picture is about <i>in the context that it's being used in</i>. In our horse example above,
			the important part is that the horse isn't bending down to drink - it's picking up the glass in its teeth. If this picture appeared in 
			a bunch of pictures from a party, it might have been important to mention that it was a horse drinking beer (as opposed to a human drinking beer).
		</p>

		<p>
			As well as being descriptive, your <code>alt</code> text also needs to be succinct (which can seem like a tall order!). Screen readers will only 
			read out 125 characters, so make sure you don't waste any! Especially make sure that you don't start your descriptions with "image of" or 
			"picture showing". The screen reader will announce that it's an image, and a search engine bot will know from the <code>img</code> tag. Adding this 
			information to the <code>alt</code> text is repetitive and boring.
		</p>

		<p>
			On the other hand, if your image is purely decorative, it doesn't need a description.
		</p>

		<figure class="example">
			<p>And that's all I have to say on that topic.</p>
			<img style="width: 30vw; margin: auto; border: 0" src="images/divider.svg" alt="">
			<p>But on this kind of related topic, I have a bunch more things to say.</p>
			<figcaption>
				If the image isn't adding any information, it doesn't need a description, but it 
				does still need an alt tag.
			</figcaption>
		</figure>

		<pre><code class="html">
&lt;img src="images/divider.svg" alt=""&gt;
		</code></pre>

		<p>
			(It would be even better to add this divider as a background image of an <code>hr</code> element.)
		</p>

		<p>
			Icons are a kind of special case that kind of crosses the line between informative and descriptive.
			While icons <i>can</i> convey meaning, you usually shouldn't rely on them by themselves. Instead, icons should 
			be accompanied by descriptive text, that is visible to all users. The reason for this is that icons are not 
			really very good at adding meaning. They usually rely on a picture of a physical object to convey an abstract 
			concept. And, they're often so highly stylised, that it's not obvious what it's actually a picture <i>of</i>,
			unless you already know.
		</p>

		<figure class="example">
			<img src="images/save-icon.png" alt="A tweet in Japanese, with a picture of the Excel save icon, which looks like a floppy disk">
			<figcaption>The Japanese reads "Why is the Excel save icon a vending machine?"</figcaption>
		</figure>

		<p>
			I'd recommend that you treat icons like acronyms in writing - only use them if you've already defined what they mean.
			In writing, this means that you should provide the expanded version of the acronym the first time you use it. For example, 
			we might say "In order to render a page, the browser constructs the DOM (document object model)".
			Unfortunately, in an app, there's no real way to know where a user is going to encounter your icon first. So, best practice is 
			to include text with them everywhere.
		</p>

		<figure class="example">
			<img src="images/icons-with-labels.png" alt="icon buttons with text labels">
			<figcaption>Icons from <a href="https://css-tricks.com/">CSS Tricks website</a></figcaption>
		</figure>

		<p>
			Sometimes though, it's not going to be practical to add the text. In these cases, you'll need to use your best judgement.
			It's more ok to leave off the labels when space is extremely limited, or you're dealing with expert users. So, if you're 
			building a game, with limited space for controls, and users who are going to invest time in learning the controls, and 
			who play frequently enough to remember them, you can go to town with icon-only buttons. A banking app, which users are 
			only going to interact with a few times a month - not so much.
		</p>

		<style>
			.example.game-vs-bank {
				display: grid;
				grid-template-columns: 17fr 6fr;
				align-items: center;
				grid-gap: 10px;
			}

			.example.game-vs-bank img {
				border: 0;
				padding: 0;
			}

			.example.game-vs-bank figcaption {
				grid-column: 1 / -1;
			}
		</style>

		<figure class="example game-vs-bank">
			<img src="images/angrybirds.jpg" alt="Angry birds game, using icon-based controls">
			<img src="images/ing.png" alt="ING bank menu, showing icons with text labels">
			<figcaption>
				The Angry Birds game (left) relies entirely on non-text-based controls. The ING banking app (right)	opts for a slide-out 
				menu on smaller screens, so there's enough space to add text along with the icon images.		
			</figcaption>
		</figure>

		<p>
			For more information on the topic (including some pratical exercises) check out <a href="https://webaim.org/techniques/alttext/">
			WebAIM page on Alternative Text</a>.
		</p>

		<h4>Tricky labels</h4>

		<p>
			Finally, sometimes there's just no good way to convey information non-visually. For example, HTML doesn't provide us with 
			an obvious way to associate a label with a group of radio buttons.
		</p>
		
		<figure>
			<div>Tacos!</div>
			<div class="controls" style="margin: auto">
				<input type="radio" name="tacos" id="soft-shell">
				<label for="soft-shell">Soft shell</label>
				<input type="radio" name="tacos" id="hard-shell">
				<label for="hard-shell">Hard shell</label>
				<input type="radio" name="tacos" id="why-not-both">
				<label for="why-not-both">Why not both?</label>
			</div>
		</figure>

		<p>
			This is the kind of thing we need ARIA for! We can use an ARIA role, and the <code>aria-labelledby</code> property to 
			provide a couple of extra hints to our radio buttons, just for screen readers.
		</p>

		<pre><code>
&lt;div id="tacos-label"&gt;Tacos&lt;/div&gt;
&lt;ul role="radiogroup" aria-labelledby="tacos-label"&gt;
	&lt;input type="radio" name="tacos" id="soft-shell"&gt;
	&lt;label for="soft-shell"&gt;Soft shell&lt;/label&gt;
	&lt;input type="radio" name="tacos" id="hard-shell"&gt;
	&lt;label for="hard-shell"&gt;Hard shell&lt;/label&gt;
	&lt;input type="radio" name="tacos" id="why-not-both"&gt;
	&lt;label for="why-not-both"&gt;Why not both?&lt;/label&gt;
&lt;/ul&gt;
		</code></pre>

		<p>
			For more information about <code>aria-labelledby</code>, and a tonne of use cases and examples, check out
			<a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/ARIA_Techniques/Using_the_aria-labelledby_attribute">
			MDN's page on aria-labelledby</a>.
		</p>

		<h3>Navigation</h3>

		<p>
			Accessibility isn't just about semantic HTML though. You also need to think about how users navigate around your app. 
			Most apps are designed with a user using a computer with a mouse in mind. Designs for mobile phones and tablets are 
			tacked on as an afterthought (or not at all). This probably isn't the best approach to take though, as most websites get 
			more traffic from users on phones (and tablets) than traditional desktop and laptop machines.
		</p>

		<figure class="example">
			<img 
				src="images/worldwide-usage-stats.png"
				alt="Graph of usage over the last 12 months. Mobile increases: 49%-53%. 
				Desktop drops: 47%-44%. Tablet stays around 3%">
			<figcaption>Source: https://gs.statcounter.com/platform-market-share/desktop-mobile-tablet</figcaption>
		</figure>

		<p>
			As you can see, mobile usage accounted for almost 10% more users than desktop usage worldwide in December last year, and the gap is 
			widening. In Australia, the picture is a little different, but not significantly.
		</p>

		<figure class="example">
			<img
				src="images/australian-usage-stats.png"
				alt="Graph of ussage in the Australian market. Mobile increases: 38%-47%. Desktop drops: 52%-45%. Tablet drops: 10%-7%.">
			<figcaption>Source: https://gs.statcounter.com/platform-market-share/desktop-mobile-tablet/australia</figcaption>
		</figure>

		<p>
			While desktop usage is a bit higher in Australia, it's still dropping. And tablet usage is also much higher than the global 
			average. Combining mobile and tablet usage, touchscreen devices still account for around 10% more of the market than 
			traditional computers.
		</p>

		<p>
			On top of this, there is an unknown number of users employing non-standard input devices, such as accessibility devices, 
			game controllers, or even watches.
		</p>

		<figure class="example">
			<img src="images/Accessible gaming controller.jpg" alt="accesible gaming control pad">
			<figcaption>Accessible gaming control pad. Source: https://mediaaccess.org.au/latest_news/gaming-is-growing-more-accessible-0</figcaption>
		</figure>

		<p>
			The good news is that most non-standard devices function like keyboards. So if you can get your site working for touchscreens and 
			keyboards, you should be OK for the vast majority of people. (Honestly, I wouldn't even bother too much with mouse users, as an
			app which works for keyboards and touchscreens will work with a mouse. Maybe just add some hover states.)
		</p>

		<p>So what are the things you should keep in mind when designing for keyboard and touchscreen users?</p>

		<h4>Keyboard users</h4>
		<ul>
			<li>
				<p>You need some kind of indicator of which element currently has focus. The browser will give you this one for free.</p>
				
				<figure class="example">
					<img src="images/focus-indicators.png" alt="default focus indicator in Safari, Chrome, and Firefox">
					<figcaption>Default focus indicator in Safari, Chrome, and Firefox</figcaption>
				</figure>

				<p>
					The HTML standard recommends just using the browser default indicators, but I find there are a couple of problems with this 
					advice. For a start, most designers don't like them - they appear differently on different browsers, and they don't match 
					with the site's theming. They're also completely inaccessible if your site happens to use background colours that are similar 
					to the focus indicator colour (and the colour changes between different versions of the same browser, and even between 
					different input types in the same version of the same browser).
				</p>

				<p>
					The good news is that you can fairly easily replace the default indicators with your own. You can use an outline, like the 
					browsers do, or change the border or colour of the element. Just make sure you're not relying solely on changing the hue 
					of the colour, as this won't be visible to colour-blind users. For inputs, I find adding a thicker border usually works 
					well.
				</p>
					
				<figure class="example">
					<style>
						#focus-example {
							transition: border-width .2s, border-color .2s;
						}
						#focus-example:focus {
							border: 2px solid currentColor;
						}	
					</style>
					<input type="text" id="focus-example">
					<figcaption>
						Click in the input to see the focus style.
					</figcaption>
				</figure>
					
					
				<p>
					For links, my usual go-to is a dashed outline in the current colour.
				</p>

				<pre><code class="css" tabindex="-1">
/* New focus style will replace the default style in Chrome and Safari */
.link:focus {
	outline: 1px dashed currentColor;
	outline-offset: 2px;
}
/* You need to remove the Firefox focus indicator manually */
.link:-moz-focusring {
	outline: none;
}
				</code></pre>

				<p>
					<code>currentColor</code> is a CSS variable that references the <code>color</code> attribute of the current element.
				</p>

				<figure class="example">
					<style>
						#focus-indicator-demo {
							display: flex;
						}
						#focus-indicator-demo a {
							font-size: 36px;
							margin-right: 1em;
						}
						#focus-indicator-demo a:nth-child(2) {
							color: hsl(12, 80%, 40%);
						}
						#focus-indicator-demo a:nth-child(3) {
							background-image: linear-gradient(yellow, fuchsia);
							-webkit-background-clip: text;
							-webkit-text-fill-color: transparent;
						}
						#focus-indicator-demo a:focus {
							outline: 1px dashed currentColor;
							outline-offset: 3px;
						}
					</style>

					<div id="focus-indicator-demo" aria-describedby="demonstration of focus styles using a 1px dashed currentColor outline">
						<a href="https://css-tricks.com/">CSS Tricks</a>
						<a href="https://css-tricks.com/">CSS Tricks</a>
						<a href="https://css-tricks.com/">CSS Tricks</a>
					</div>
					<figcaption>
						Click in the input above, then use tab to see the focus indicators of the links.
					</figcaption>
				</figure>
			</li>
			<li>
				<p>
					Users should be able to navigate between interactive elements using the <kbd>tab</kbd> key. By default, this will Just Work 
					with the native interactive elements - <code>&lt;a&gt;</code>, <code>&lt;input&gt;</code>, <code>&lt;button&gt;</code>, 
					<code>&lt;select&gt;</code>, and <code>&lt;formarea&gt;</code>.
				</p>

				<p>
					When building custom controls, the ideal approach is to construct them out of native elements that have similar functionality
					(like our power button above). Sometimes, though, your control just isn't going to map well to existing HTML controls. In those 
					cases, you can use <code>tabindex="0"</code> to add an element to the tab order. Just make sure you don't add it to elements that 
					aren't interactive!
				</p>
			</li>
			<li>
				<p>
					If you have a multi-page SPA (which, yes, sounds like an oxymoron) you need to move the focus back to the top of the page 
					manually when the user navigates to a new route. Otherwise, the next tab will just continue on from where you were. And, given that
					the rest of that particular page no longer exists, that's probably going to be the footer.
				</p>
				<p>
					My recommendation would be to have an <code>&lt;h1&gt;</code> element at the start of each page. (I mean this is just good design, 
					but is also helpful here). Give your <code>&lt;h1&gt;</code> a <code>tabindex</code> of -1, so it can be focussed with JavaScript, 
					but can't actually be tabbed to. Then, have some kind of interceptor that moves the focus to the <code>&lt;h1&gt;</code> whenever
					the route changes.

					<pre><code class="html">
&lt;h1 tabindex="-1"&gt;Notifications&lt;/h1&gt;
					</code></pre>

					<pre><code>
// On route change
const heading = document.querySelector('h1');
heading.focus();
					</code></pre>
				</p>
			</li>
			<li>
				When using modals, you need to move the focus to the modal when it opens. Then you need to ensure that focus is trapped inside the
				modal. As long as the modal is open, the user shouldn't be able to tab to anything outside of it. If they tab to the last item in 
				the modal, then the next tab should take them back to the first item. (And don't forget your modal needs to be closeable via keyboard,
				preferably via a close button (which is tabbable), or by hitting <kbd>esc</kbd>) 

				<figure class="example" style="text-align: center">
					<button id="open-modal">Open Modal</button>
					<div id="modal-overlay">
						<div id="modal">
							<h2 id="modal-title" tabindex="-1">This is a modal</h2>
							<button id="close-modal" class="close-modal" aria-describedby="close"></button>
							<div id="modal-content">Choose how this modal goes away</div>
							<button id="burn-out" class="close-modal">Burn out</button>
							<button id="fade-away" class="close-modal">Fade away</button>
						</div>
					</div>
					<figcaption>
						Focus moves to the modal header when you open it. You can close it by pressing Escape, clicking on the background overlay,
						or clicking the close button. Focus is trapped inside the modal while it's open.
					</figcaption>
				</figure>

				<style>
					#modal-overlay {
						display: none;
						opacity: 0;
						transition: opacity .5s;

						width: 100vw;
						height: 100vh;
						background: hsla(250, 100%, 0%, 0.5);
						position: fixed;
						top: 0;
						left: 0;
					}

					#modal-overlay.open {
						opacity: 1;
					}

					#modal {
						position: fixed;
						top: 50%;
						background: white;
						left: 50%;
						transform: translate(-50%, -50%);
						padding: 30px;
						border-radius: 20px;
						display: grid;
					  grid-template-areas: 't t' 'c c' 'burn fade';
						transition: filter 3s, .2s opacity 2s;
					}
					#modal.burn {
						filter: brightness(255);
						opacity: 0;
					}

					#modal-title {
						grid-area: t;
					}

					#close-modal {
						grid-area: x;
						background: 0;
						border: 0;
						box-shadow: none;
						color: hsl(212, 100%, 10%);
						font-family: 'League Gothic';
						font-weight: normal;
						width: min-content;
						align-self: flex-start;
						justify-self: flex-end;
						padding: 0;
						display: flex;
						flex-direction: column;
						line-height: .8;
						color: hsl(250, 0%, 40%);
						text-transform: uppercase;
						position: absolute;
						top: 7px;
						right: 18px;
					}
					#close-modal::before {
						content: 'x';
						font-family: Raleway;
						font-size: 53px;
						font-weight: bold;
						opacity: .6;
						text-transform: none;
					}

					#modal-content {
						grid-area: c;
						height: 60px;
					  padding: 0 10px;
					}

					#burn-out {
						grid-area: burn;
					}

					#fade-away {
						grid-area: fade;
					}
				</style>

				<script>
					const modal = document.getElementById('modal');
					const modalTitle = document.getElementById('modal-title');
					const modalOverlay = document.getElementById('modal-overlay');

					const modalButton = document.getElementById('open-modal');
					modalButton.addEventListener('click', () => {
						modalOverlay.style.display = 'block';

						document.body.addEventListener('keyup', closeOnEscape);

						requestAnimationFrame(() => {
							requestAnimationFrame(() => {
								modalOverlay.classList.add('open');
								modalTitle.focus();
							});
						});
					});

					function closeOnEscape (event) {
						if (event.key === 'Escape') {
								closeModal();
							}
					}

					function closeModal() {
						modalOverlay.classList.remove('open');
						modalOverlay.addEventListener('transitionend', () => {
							modalOverlay.style.display = 'none';
						}, { once: true });

						document.body.removeEventListener('click', closeOnEscape);
					}

					document.getElementById('close-modal').addEventListener('click', closeModal);
					modalOverlay.addEventListener('click', closeModal);
					modal.addEventListener('click', (event) => event.stopPropagation());

					const fadeButton = document.getElementById('fade-away');
					fadeButton.addEventListener('click', () => {
						const duration = getComputedStyle(modalOverlay).transitionDuration;
						modalOverlay.style.transitionDuration = '5s';
						modalOverlay.addEventListener('transitionend', () => {
							modalOverlay.style.transitionDuration = duration;
						}, { once: true });
						closeModal();
					});

					const burnButton = document.getElementById('burn-out');
					burnButton.addEventListener('click', () => {
						modal.classList.add('burn');
						setTimeout(() => {
							closeModal();
							requestAnimationFrame(() => {
								modal.classList.remove('burn');
							})
						}, 3000);
					});
 
					const firstTabbable = document.getElementById('close-modal');
					const lastTabbable = document.getElementById('fade-away');
					lastTabbable.addEventListener('keydown', (event) => {
						if (event.key === 'Tab') {
							event.preventDefault();
							firstTabbable.focus();
						}
					});
				</script>
			</li>
		</ul>

		<h4>Touchscreen users</h4>

		<ul>
			<li>
				<p>
					Remember, there is no way to hover on a touchscreen! While it's great to add hover styles for mouse users (and focus states 
					for keyboard users), you need to make sure these are not the only way of indicating that something can be interacted with.
					Links, for instance, should also be underlined. And buttons should... look buttony? Design trends are kind of all over the 
					place on this one, but, at a minimum, your buttons should all look similar, and they should look different from things that 
					aren't buttons.
				</p>

				<p>
					On top of this, you can't rely on hover to activate things like menus and tooltips. They also need to work on click.
					In fact, I would recommend always using click and ditching hover altogether. Not only does it not work on touchscreens, or 
					with a keyboard, it can be difficult to use for people 
				</p>
				<ul style="margin-bottom: 20px">
					<li>with motor difficulties</li>
					<li>using a device with a small screen</li>
					<li>using a device with an awkward mouse input (like a trackpoint)</li>
					<li>using a perfectly standard mouse, while sitting on a couch</li>
					<li>using a standard trackpad, but on a train, or a bus, or a plane</li>
				</ul>

				<figure class="example" style="margin-bottom: 20px">
					<img src="images/lenovo-trackpoint.png" alt="" style="border: 0; padding: 0; margin-top: 0">
					<figcaption>
						Lenovo keyboard with trackpoint. (It's the red dot between the <kbd>G</kbd> and <kbd>H</kbd> keys, if you're not familiar with 
						them.) If you can navigate accurately with one of these things, then you're doing better than me!
					</figcaption>
				</figure>
							</li>
			<li>
				Make sure you're not assuming whether or not someone is using a touchscreen based on their screen size. Devices with large screens 
				can have touch interfaces (2-in-1 laptops, touch-based whiteboards, etc), and some small devices don't have touch-screens 
				(watches, portable gaming devices, e-readers). If you must, you can detect whether a device has "hover capability" via 
				the <code>hover</code> media query. It's not supported in IE, but I don't think it's going to matter that much if your IE 
				users just get the non-hover version of your site.
			</li>
			<li>
				A person's finger is much less precise than a mouse cursor. Make sure that your touch targets are large enough. The 
				<a href="https://developer.apple.com/design/human-interface-guidelines/">Apple Human 	Interface Guide</a>
				suggests a minimum of 44px by 44px. Google's <a href="https://developer.android.com/design">Android design guide</a>
				recommends 48px by 48px. Some people who actually 
				conducted a <a href="https://dl.acm.org/doi/10.1145/1152215.1152260">study into touch target sizes</a>, recommend a minimum size 
				of 1cm squared. That's a bit hard to specify in CSS though, so you're going to need to experiment a little to work out how 
				big your touch targets end up.
			</li>
		</ul>

		<h3>Standards</h3>

		<p>
			Finally, the web has been around for over 30 years now. There are well-established conventions for interacting with pages.
			If you use semantic HTML, you will follow these conventions automatically, and users will learn how to use your app far more 
			quickly. And they'll probably enjoy it more. Some examples of these things are:
		</p>

		<ul>
			<li>
				If you use an <code>&lt;a&gt;</code> element for links, the cursor will automatically change to a hand, and the link destination 
				will appear in the browser status bar on hover. The user can open the link in a new tab by ctrl-clicking, or using the context 
				menu. Pressing <kbd>enter</kbd> while the link is focussed will activate it. (Furthermore, pressing <kbd>space</kbd> will
				 <i>not</i> open the link. This behaviour is not preserved if you use a <code>&lt;button&gt;</code> for your link.)
			</li>
			<li>
				If you use a <code>&lt;button&gt;</code> element, the <code>onclick</code> handler will be fired if the user presses <kbd>enter</kbd> or 
				<kbd>space</kbd> while the button has focus, so it's automatically usable by a keyboard user.
			</li>
			<li>
				When an element inside a <code>&lt;form&gt;</code> element has focus, pressing <kbd>enter</kbd> or <kbd>space</kbd> will 
				submit the form.
			</li>
			<li>
				As mentioned previously, a click on a <code>&lt;label&gt;</code> element is treated as a click on the linked <code>&lt;input&gt;</code>
				element.
			</li>
		</ul>

		<p>
			When writing HTML, it is important to remember to choose your HTML element based on the <i>functionality</i> of the element, not its 
			appearance. For example, for some reason, designers really like styling links as buttons (and vice versa). I'm sure they have their 
			reasons, and that's fine. Let them have at it. You, however, should still use <code>&lt;a&gt;</code> elements for links, and just 
			CSS the heck out of them. HTML describes what our app does. CSS describes how it looks.
		</p>

		<p>
			And finally, I hope I've convinced you that accessibility isn't some annoying thing you do at the end to cater for some small segment 
			of the population. It's about building an app that works well for all your users, in all the situations they find themselves in. 
			Furthermore, building accessibilty through semantic HTML isn't just good for users - it's good for developers as well. It results in 
			code that is cleaner, and easier to understand. Building an accessible website doesn't have to be time-consuming or expensive - 
			it can actually be <i>faster</i> than the alternative.
		</p>
	</section>

	<section>
		<h2 id="understanding-css">Understanding CSS</h2>

		<p>
			Out of CSS, HTML, and JavaScript, I think CSS is the thing people struggle with most. If you're looking for 
			work as a frontend developer, strong JavaScript skills are important, but mastery of CSS and HTML is what 
			will make you really stand out.
		</p>

		<p>
			Part of the reason that CSS is so difficult is that it's a completely different paradigm to most programming 
			languages. While knowing C++ or Java will give you a huge leg-up with learning JavaScript, it won't help at 
			all with learning CSS.
		</p>

		<p>
			Another factor is the fact that CSS seems to lack underlying principles. Learning CSS often feels like just 
			memorising property names and allowed values, then learning a bunch of tricks to achieve what you want. This 
			makes learning CSS very time consuming, but also very tedious.
		</p>

		<p>
			Luckily, modern CSS is much more systematic than earlier versions. Rather than just adding new features willy-nilly, 
			modern CSS has underlying models that are shared between different properties. This makes learning new CSS 
			features much quicker and easier.
		</p>

		<p>
			So today, rather than just explaining how to achieve various effects with CSS, we're going to have a look 
			under the covers at the principles and models that make CSS work.
		</p>

		<h3>The box model</h3>

		<p>
			In CSS, everything is a box. Boxes are rectangular. They have a width and a height. Boxes are divided into 
			four areas:
		</p>
		<ul>
			<li>The content goes in the innermost part of the box</li>
			<li>The padding surrounds the content</li>	
			<li>The border goes around the content and padding</li>
			<li>
				The box is surrounded by the margin. The margin isn't technically part of the box - it's the space around
				it. The margin isn't counted in the width or height, and backgrounds don't cover any of the margin.
			</li>
		</ul>

		<img src="images/box-model.png" alt="dev tools diagram of box model">

		<p>
			A box also has a <code>box-sizing</code>, which determines how the width and height are calculated. The allowed values 
			are <code>border-box</code> and <code>content-box</code>.
		</p>

		<dl style="margin-bottom: var(--margin-size)">
			<dt><code>border-box</code></dt>
			<dd>
				The width and height refer to the total size of the box, including the border and padding
			</dd>
			<dt><code>content-box</code></dt>
			<dd>
				The width and height refer to the size of the <i>content</i>. The padding and border are added on top of this.
			</dd>
		</dl>
		
		<figure class="example grid box-sizing">
			<pre><code class="css">
.element {
	width: 100px;
	height: 100px;
	padding: 20px;
	border: 4px solid black;
}
			</code></pre>

			<style>
				.example.box-sizing {
					grid-template-rows: min-content min-content 150px 1fr;
					justify-items: center;
					grid-gap: 10px;
				}
				.example.box-sizing pre {
					margin-top: 0;
				}
				.example.box-sizing .label {
					justify-self: flex-start;
				}

				.box-sizing .element {
					width: 100px;
					height: 100px;
					padding: 20px;
				}
			</style>

			<fieldset>
				<legend><code>box-sizing</code></legend>
				<div class="controls" style="margin: 0">
					<input type="radio" id="border-box" name="box-sizing" checked>
					<label for="border-box"><code>border-box</code></label>
					<input type="radio" id="content-box" name="box-sizing">
					<label for="content-box"><code>content-box</code></label>		
				</div>
			</fieldset>

			<div class="element"></div>

			<script>
				const boxSizingElement = document.querySelector('.box-sizing .element');
				document.querySelectorAll('.box-sizing input[type=radio]').forEach((radiobutton, index) => {
					if (index === 0) {
						radiobutton.checked = true;
					}
					radiobutton.addEventListener('change', function () {
						if (this.checked) {
							boxSizingElement.style.boxSizing = this.id;
						}
					})
				})
			</script>
			
			<figcaption>
				Adjust the size of the box by changing the <code>box-sizing</code>. When <code>border-box</code> is selected, the total 
				width of the box is 100px: 2 * 4px of border + 2 * 20px of padding + 52px of content. When <code>content-box</code> is 
				selected, the content is 100px wide. 2 * 4px of border + 2 * 20px of padding are added on top of this, giving a total width of 
				148px. You can find this information in the CSS section of your browser dev tools.
			</figcaption>
		</figure>

		<p>
			By default, all elements have <code>box-sizing: content-box</code>. Except in IE, which uses <code>box-sizing: border-box</code>,
			because of course it does. Because of this, it's a good idea to set the box-sizing manually on any project you're working on.
			What might be surprising is that most people actually follow IE's example and use <code>box-sizing: border-box</code>. You usually 
			care about the total size of an element, regardless of how much padding it has, and <code>border-box</code> makes the 
			calculations a bit easier. You can override the browser's default box-sizing with the following bit of code.
		</p>

		<pre><code>
			*, *::before, *::after {
				box-sizing: border-box;
			}
		</code></pre>

		<p>
			Overriding the browser's default styling like this is called a CSS reset. Resets are commonly used to ensure defaults
			are consistent across browsers. The selectors used are as generic as possible, so that you can easily override them in your 
			application if you need to. You can write your own CSS resets, or you can just grab one someone else has created. To see the 
			kind of thing that normally goes in them, check out <a href="https://dev.to/hankchizljaw/a-modern-css-reset-6p3">Andy Bell's 
			CSS reset</a> on dev.to.
		</p>


		<h3>Normal flow</h3>

		<p>
			In CSS, individual elements are placed on the page according to normal flow. Each element is placed immediately adjacent to 
			its previous sibling (respecting margins) in one of the two directions - inline, or block.
		</p>

		<p>
			The inline direction is the direction that you write words in a sentence. On a page written in English, the inline direction 
			is left to right, across the page. On an Arabic page, it's right to left. On a Japanese page, it's top to bottom, down the page.
		</p>

		<figure class="example normal-flow">
			<div id="inline-arrow"></div>
			<figcaption>
				<input type="radio" name="inline-script" id="inline-ltr" value="ltr">
				<label for="inline-ltr">Horizontal, left-to-right script (Latin, Cyrillic)</label>
				<input type="radio" name="inline-script" id="inline-rtl" value="rtl">
				<label for="inline-rtl">Horizontal, right-to-left script (Arabic, Urdu)</label>
				<input type="radio" name="inline-script" id="inline-ttb" value="ttb">
				<label for="inline-ttb">Vertical, top-to-bottom script (Chinese, Japanese)</label>
				<input type="radio" name="inline-script" id="inline-btt" value="btt">
				<label for="inline-btt">Vertical, bottom-to-top (Ancient Berber, Batak)</label>

			</figcaption>
		</figure>
		<style>
			#inline-arrow, #block-arrow {
				width: 80%;
				padding-top: 100%;
				margin: auto;
				position: relative;
			}
			#inline-arrow::before, #block-arrow::before {
				content: '';
				transition: transform 2s;
				background-repeat: no-repeat;
				background-position: 50% 50%;
				background-size: contain;
				width: 100%;
				height: 100%;
				position: absolute;
				top: 0;
			}
			#inline-arrow::before {
				background-image: url('images/arrow.png');
			}
			#block-arrow::before {
				background-image: url('images/block-arrow.png');
			}
			#inline-arrow.rtl::before, #block-arrow.bottom-to-top::before {
				transform: rotate(2.5turn);
			}
			#inline-arrow.btt::before, #block-arrow.ltr::before {
				transform: rotate(1.75turn);
			}
			#inline-arrow.ttb::before, #block-arrow.rtl::before {
				transform: rotate(1.25turn);
			}

			.normal-flow figcaption, .flex-axes figcaption {
				display: grid;
			  grid-template-columns: repeat(4, 1fr);
  			background: transparent;
  			padding: 0;
			}
			.flex-axes figcaption {
			  grid-template-columns: repeat(2, 1fr);
			}
			.normal-flow [type="radio"], .flex-axes [type="radio"] {
				width: 0;
			  height: 0;
				opacity: 0;
  			position: fixed;
			}
			.normal-flow label, .flex-axes label {
				border-top: 2px solid var(--main-colour);
				padding: 10px 20px;
			  color: var(--main-colour);
  			font-style: normal;
				cursor: pointer;
			}
			.normal-flow label:not(:last-of-type), .flex-axes label:not(:last-of-type) {
				border-right: 2px solid var(--main-colour);
			}
			.normal-flow input:checked + label, .normal-flow label:hover,
			.flex-axes input:checked + label, .flex-axes label:hover {
				background: var(--main-colour);
			  color: white;
			}
		</style>
		<script>
			const inlineArrow = document.getElementById('inline-arrow');
			document.querySelectorAll('[name="inline-script"]').forEach((input, index) => {
				if (index === 0) {
					input.checked = true;
				}
				input.addEventListener('change', function(event) {
					inlineArrow.classList.remove('rtl');
					inlineArrow.classList.remove('ttb');
					inlineArrow.classList.remove('btt');
					inlineArrow.classList.add(this.value);
				});
			});
		</script>

		<p>
			The block direction is the direction that you add paragraphs to the page. On a page written in English or Arabic, it's top 
			to bottom, down the page. In Japanese, it's right-to-left, across the page.
		</p>

		<figure class="example normal-flow">
			<div id="block-arrow"></div>
			<figcaption style="grid-template-columns: 1fr 1fr 1fr">
				<input type="radio" name="block-script" id="block-horizontal" value="horizontal">
				<label for="block-horizontal">Horizontal, top-to-bottom script (Latin, Cyrillic, Arabic, Urdu)</label>
				<input type="radio" name="block-script" id="block-ltr" value="ltr">
				<label for="block-ltr">Vertical, left-to-right script (Mongolian, Uyghur)</label>
				<input type="radio" name="block-script" id="block-rtl" value="rtl">
				<label for="block-rtl">Vertical, right-to-left script (Chinese, Korean)</label>
			</figcaption>
		</figure>
		<script>
			const blockArrow = document.getElementById('block-arrow');
			document.querySelectorAll('[name="block-script"]').forEach((input, index) => {
				if (index === 0) {
					input.checked = true;
				}
				input.addEventListener('change', function(event) {
					blockArrow.classList.remove('ltr');
					blockArrow.classList.remove('rtl');
					blockArrow.classList.add(this.value);
				});
			});
		</script>

		<p>
			Why do we use the terms inline and block, rather than just saying across and down? Because we want CSS to be as language-agnostic 
			as possible. It's not actually that good at it currently - just ask anyone who's ever tried to internationalise a page to a
			non-left-to-right script. But we are moving towards a more language-agnostic CSS, and it's good to get the hang of these things 
			sooner rather than later.
		</p>

		<p>
			So how do we know if an element should be added in the inline direction, or the block direction? Each element has a <code>display</code>
			property of either <code>block</code> or <code>inline</code>. (Technically, there are a few more <code>display</code> properties, as 
			we'll see shortly. But they can all be thought of as a type of <code>block</code>, or a type of <code>inline</code>). Elements with 
			<code>display: inline</code> are added in the inline direction. Elements with <code>display: block</code> are added in the block 
			direction. <code>span</code> is your default inline element, with no other semantics. <code>div</code> is your default block element.
			The <code>displ</code> can be overridden in CSS.
		</p>

		<div class="example add-block-inline">
			<button onclick="addElement('inline-block')">Add inline element</button>
			<button onclick="addElement('block')">Add block element</button>
			<div id="block-inline-demo" style="margin-top: 30px; min-height: 400px"></div>
		</div>

		<style>
			.add-block-inline .element {
				width: 100px;
				height: 100px;
			}
		</style>

		<script>
			const blockInlineContainer = document.getElementById('block-inline-demo');
			function addElement(display) {
				const div = document.createElement('div');
				div.style.display = display;
				div.classList.add('element');
				blockInlineContainer.append(div);
			}
		</script>

		<h3>Block layout</h3>

		<p>
			The display property controls more than just how the element is placed on the page though. Block and inline elements have 
			other distinct properties and behaviours. Block elements are a little easier to understand conceptually, so let's 
			start with them.
		</p>

		<p>
			As we already discussed, block elements are added in the block direction. Each block element is on a row by itself - 
			the next element will be placed below the block element, whether it is block or inline.
		</p>

		<p>
			The size of a block element is determined by its width and height (plus the padding and border, if you're still using 
			<code>content-sizing</code>, despite everything we just discussed). If the width of the element is <code>auto</code>
			(which is the default value), then the element will be as wide as its parent element. If the height is <code>auto</code>,
			then the element will be as tall as it needs to be to fit all its content, given the current width.
		</p>

		<figure class="example">
			<fieldset style="margin-bottom: 20px;">
				<legend>Element width</legend>
				<div class="controls" style="margin: 0">
					<input type="radio" name="block-width" id="block-width-auto" onchange="selectWidth('auto')" checked><label for="block-width-auto">auto</label>
					<input type="radio" name="block-width" id="block-width-100px" onchange="selectWidth('200px')"><label for="block-width-auto">200px</label>	
				</div>
			</fieldset>
			<div class="element" id="block-auto" contenteditable="true" style="width: 100%">
				some example content
			</div>
			<figcaption>
				Type in the box to add content and see how the size is affected.
			</figcaption>
		</figure>

		<script>
			const blockWidthElement = document.getElementById('block-auto');
			function selectWidth(width) {
				blockWidthElement.style.width = width;
			}
		</script>


		<p>
			If you give your element a width and height that is too small to fit the contents, then it'll overflow, and probably look 
			terrible. This overflowed contents won't affect the placement of the next element though - it'll just get covered up.
		</p>

		<figure class="example overflow-demo">
			<div id="overflow-demo" class="element" contenteditable="true">
				I already have some content, but I'd love some more. Type in me and see what happens!
			</div>
			<div class="element" style="width: auto; height: auto">
				I have a width & height of auto, so my content fits fine.
			</div>
			<button onclick="clearContent()" style="margin-top: 20px;">Clear content</button>
			<figcaption>
				Type in the box. Add heaps of content so it can't all fit. It'll be fun!
			</figcaption>
		</figure>

		<style>
			.example.overflow-demo .element {
				width: 200px;
				height: 200px;
			}
		</style>

		<script>
			const overflowDemoElement = document.getElementById('overflow-demo');
			function clearContent() {
				overflowDemoElement.textContent = '';
			}
		</script>

		<p>
			One small gotcha with block layout is margin-collapse. In some situations, the margins of two adjacent block
			elements will overlap, resulting in a single margin that is the same size as the larger one. This is due to HTML's 
			origins as a document delivery system - author's didn't want to end up with double margins around headings, or the 
			last paragraph on a page. It also means that an empty element will disappear completely, rather than hanging 
			around as a margin-ghost.
		</p>

		<figure class="example margin-ghost">
			<div id="margin-ghost">
				<p>A paragraph immediately before an empty element.</p>
				<p style="padding: 1px"></p>
				<p>A paragraph immediately after an empty element.</p>
			</div>
			<div>
				<p>A paragraph immediately before an empty element.</p>
				<p></p>
				<p>A paragraph immediately after an empty element.</p>
			</div>
			<figcaption>
				Left: empty element without margin collapse; Right: with margin collapse.
			</figcaption>
		</figure>
		<style>
			.example.margin-ghost {
				padding-top: 0;
				display: grid;
				grid-template-columns: 1fr 1fr;
				grid-gap: 0 20px;
			}

			#margin-ghost {
				border-right: 1px solid var(--main-colour);
			}
			#margin-ghost:hover {
				background: url('images/ghost.png'), var(--main-colour);
				background-size: contain;
				background-repeat: no-repeat;
				background-position: 50%;
				margin-left: -20px;
			}

			.margin-ghost figcaption {
				grid-column: span 2;
				margin-top: 0;
			}
		</style>

		<p>
			If you think you've been affected by margin-collapse, or you just want to know more about it, check out 
			<a href="https://www.smashingmagazine.com/2019/07/margins-in-css/">Rachel Andrew's article on CSS margins</a>.
		</p>

		<h3>Inline layout</h3>

		<p>
			Inline layout is a bit more complicated than block layout. Inline elements behave like text - they are laid out side-by-side 
			in the inline direction, until they get to the end of the line, and then they wrap to the next line.
		</p>

		<h4>Line boxes</h4>

		<p>
			In order to layout inline elements (and text), the browser creates a line box. The line box is a container that the 
			browser uses to place elements - it doesn't appear in the DOM, and it can't be styled. It's kind of like adding pencil 
			lines, that you erase once you've finished writing. Inline elements (and text) are placed in the line box, until the next element won't fit. 
			Then the browser creates a new linebox, directly below the previous one, and adds the remaining elements to the new line box.
		</p>

		<p>
			The width of the line box is the width of the parent element's content box. (In vertical scripts, this will actually be the 
			height. I'm just going to assume a horizontal script here though, because, honestly, this stuff is already confusing enough.)
			The height of the line box is determined by its content. If the line box only contains text, it'll be based on the font size. If
			it contains non-text elements, it'll be based on the height of the elements. If it contains a mixture or text and non-text, or 
			a number of different font sizes, then it's up to the browser to decide what height to use. It'll probably pick something slightly 
			bigger than the biggest thing in the line box.
		</p>

		<figure class="example linebox">
			<button onclick="addToLinebox()">Add an inline element</button>
			<div class="container" id="linebox"></div>
			<figcaption>
				The shaded area between the grey lines represents the line box. Notice that the line box is very slightly bigger than its content.
			</figcaption>
		</figure>

		<style>
			.example.linebox .container {
				--linebox: hsla(254, 30%, 50%, .2);
				--line-width: 2px;
				--total-height: 105px;
				padding: 20px;
				min-height: 140px;
				background-image: repeating-linear-gradient(grey, grey var(--line-width), 
																										var(--linebox) var(--line-width), var(--linebox) calc(var(--total-height) - var(--line-width)), 
																										grey calc(var(--total-height) - var(--line-width)), grey var(--total-height));
			  background-clip: content-box;
				background-origin: content-box;
				margin-top: 20px;
			}
			.example.linebox .element, .example.line-height .element {
				display: inline-block;
				width: 100px;
				height: 100px;
			}
		</style>

		<script>
			const lineboxContainer = document.getElementById('linebox');
			function addToLinebox() {
				const element = document.createElement('span');
				element.classList.add('element');
				lineboxContainer.append(element);
			}
		</script>

		<p>
			If you need to, you can set the height of the line box yourself, using the <code>line-height</code> property. If you set the 
			<code>line-height</code> of a block element, it will set the <i>minimum</i> height of all line boxes inside that element.
		</p>

		<figure class="example line-height">
			<label for="line-height"><code>line-height</code> </label><input type="number" id="line-height" onchange="updateLineHeight()" value="1.2" step="0.1">
			<div class="container">
				<span class="element"></span>
				<span class="element"></span>
				<span class="element"></span>
				<span class="element"></span>
				<span class="element"></span>
				<span class="element"></span>
				<span class="element"></span>
				<span class="element"></span>
				<span class="element"></span>
				<span class="element"></span>
			</div>
		</figure>

		<style>
			.example.line-height {
				width: 420px;
			}
			.example.line-height .container {
				margin-top: 10px;
			}
		</style>

		<script>
			const lineHeightContainer = document.querySelector('.example.line-height .container');
			const lineHeightInput = document.getElementById('line-height');
			lineHeightInput.value = 1.2;
			function updateLineHeight() {
				lineHeightContainer.style.lineHeight = lineHeightInput.value;
			}
		</script>
		
		<p>
			If you set <code>line-height</code> on an inline element, then that height will be used in the line box height calculation, along with all the 
			fonts and stuff. In the example below, you can see that changing the line-height for one of the elements doesn't change the 
			height of any elements, but it changes the spacing between the lines. You can also see that the line-height of each line box 
			is calculated independently, depending only on the elements in that particular line box. Because of this, getting the line spacing 
			you really want can be surprisingly difficult in CSS.
		</p>

		<figure class="example inline">
			<label for="words-height"><code>line-height</code> for the medium font</label>
			<input type="number" id="words-height" onchange="updateWordsLineHeight()" step="0.1" value="1.2">
			<div style="margin: auto; margin-top: 20px; width: 200px">
				<span class="words">
					<span style="font-size: 10px">some words in a small font</span>
					<span style="font-size: 20px; color:hsl(12, 80%, 40%)">some words in a medium font</span>
					<span style="font-size: 30px">some words in a large font</span>
				</span>
			</div>
		</figure>

		<style>
			.words {
				border: 1px solid blue;
			}
		</style>

		<script>
			const wordsHeightElement = document.getElementById('words-height');
			wordsHeightElement.value = 1.2;
			const mediumElement = document.querySelector('.words :nth-child(2)');
			function updateWordsLineHeight() {
				mediumElement.style.lineHeight = wordsHeightElement.value;
			}
		</script>
			
		<h4>Inline size</h4>

		<p>
			The width and height of an inline element are determined by the content of the element. You can't set them manually. You can,
			however, add padding and margins. Paddings and margins in the inline direction will add space around the element, as you would 
			expect. Paddings in the block direction will actually add space around the element, but if it makes the element taller than the 
			line box, it will overflow. As a result, you won't be able to see the padding, unless you add a border or a background colour.
			Margins in the block direction have no effect.
		</p>

		<figure class="example inline-padding">
			<div class="controls">
				<div>
					<label for="inline-padding"><code>padding</code></label>
					<input id="inline-padding">
				</div>
				<div>
					<label for="inline-margin"><code>margin</code></label>
					<input id="inline-margin">
				</div>
			</div>
			<div class="container">
				normal text normal text <span id="inline-padding-demo">adjust my margin and padding!</span>
				normal text normal text normal text
			</div>
			<figcaption>
				You can add padding and margin to the outlined words. I suggest you start with very small values, like <code>1px</code>.
			</figcaption>
		</figure>

		<style>
			.example.inline-padding .controls {
				display: flex;
				flex-wrap: wrap;
				justify-content: center;
			}
			.example.inline-padding .controls input {
				width: 100px;
				margin-right: 10px;
			}

			.example.inline-padding .container {
				max-width: 200px;
				margin: auto;
				margin-top: 10px
			}

			#inline-padding-demo {
				outline: 2px dashed currentColor;
			}
		</style>

		<script>
			const inlinePadding = document.getElementById('inline-padding-demo');
			document.querySelectorAll('.example.inline-padding .controls input').forEach((input) => {
				input.value = '';
				input.addEventListener('change', function () {
					const property = this.id.replace('inline-', '');
					inlinePadding.style[property] = this.value;
				});
			});
		</script>

		<p>
			If the line box is a different size than the height of your element, you can control whether your element is aligned to the top, 
			middle, or bottom of the line box using the <code>vertical-align</code> property. (And yes, it's called <code>vertical-align</code>
			even in situations where it's controlling the horizontal alignment. I told you CSS wasn't quite there yet with internationalisation.)
			The <code>vertical-align</code> property is only going to have an effect on inline elements, in a line box that isn't the same size 
			as their own height. This is why it never actually does what anyone wants it to when they're trying to centre-align things.
		</p>

		<div class="example vertical-align">
			<div class="controls">
				<label for="vertical-align">vertical-align</label>
				<select id="vertical-align" onchange="updateVerticalAlign()">
					<option value="top">top</option>
					<option value="middle">middle</option>
					<option value="bottom">bottom</option>
				</select>	
			</div>
			<div class="container">
				<span class="large-text">large text</span>
				<span class="small-text">small text</span>
				<span class="large-text">large text</span>
			</div>
		</div>

		<style>
			.example.vertical-align .large-text {
				font-size: 40px;
			}
			.example.vertical-align .small-text {
				font-size: 15px;
			}
		</style>

		<script>
			const verticalAlignElement = document.querySelector('.example.vertical-align .small-text');
			const verticalAlignSelect = document.getElementById('vertical-align');
			verticalAlignSelect.value = 'top';
			verticalAlignElement.style.verticalAlign = 'top';
			function updateVerticalAlign() {
				console.log(this.value)
				verticalAlignElement.style.verticalAlign = verticalAlignSelect.value;
			}
		</script>

		<h3>New display values</h3>

		<p>
			Now, you might have noticed that there are some disadvantages to the inline/block system. It conflates the sizing with the 
			layout. What if you want elements to sit side-by-side in the inline direction, but you <i>also</i> want to control their size?
		</p>

		<p>
			<code>display: inline-block</code> was introduced to deal with this situation. An inline-block element is laid out like an 
			inline element, but can be sized like a block element. 
		</p>

		<p>
			Over time, other <code>display</code> properties were added too. <code>table</code> lays out an element like a table, 
			<code>flex</code> gives us a flexible one-dimensional layout, and <code>grid</code> gives a flexible two-dimensional layout.
			Of course, it's possible you might want any of these to exist in an inline context, so we also have <code>inline-table</code>,
			<code>inline-flex</code>, and <code>inline-grid</code>.
		</p>

		<p>
			At some point, someone realised that it was kind of silly to define two new display properties any time we wanted to add new 
			display functionality. It makes a lot more sense just to treat how the element is laid out and how it behaves internally as 
			two different things. So now, the <code>display</code> property can take <i>two</i> values - the outer display value, and 
			the inner display value.
		</p>

		<p>
			The outer value determines how the element itself is placed in the flow. The inner value determines how the element's children 
			are laid out. So <code>display: block</code> is now <code>display: block flow</code> and <code>display: inline-flex</code> would be 
			<code>display: inline flex</code>.
		</p>

		<p>
			No browsers actually support the new two-value syntax yet, so don't go using it. However, it is a good model of how they 
			implement the existing values, so I think it's a good thing to understand.
		</p>

		<h3 class="incomplete">CSS is recursive</h3>

		<p class="incomplete">something about how children are laid out inside their parents</p>

		<h3 class="incomplete">CSS in three dimensions</h3>

		<p class="incomplete">
			Ok, so now we understand how an individual element behaves, and how elements are laid out in two dimensions. But CSS actually 
			allows us to lay things out in <i>three</i> dimensions.
		</p>

		<h3 class="incomplete">CSS selectors & specificity</h3>

	</section>
	
	<section>
		<h2 id="css-layouts">CSS layouts</h2>

		<p>
			Everything we've just talked about allows you to do some pretty nifty stuff. But there are some serious limitations to the 
			normal flow. Elements can really only be positioned relative to their parent, or their immediately previous sibling.
			There's no way to co-ordinate the layout of several elements at once.
		</p>

		<img src="images/css-can-kill-you.png" 
			alt="an airplane seating diagram, with the seats overflowing out of the plane and the words CSS can kill you">

		<p>
			In the early days of CSS (and even before CSS was invented), we got around this by using <code>table</code> elements.
			More recently, we've moved to 12-column CSS layout tools, like Bootstrap's grid. Both of these have some serious disadvantages 
			though. Tables are not even a bit semantic, and require you to add <i>a heap</i> of extra HTML. They're also not responsive 
			(beyond being able to specify column widths in percentages). Bootstrap requires you to add a bit less extra HTML, and it 
			adds the ability to adjust the layout based on screen size. You're still limited to percentage widths though, you can only 
			change the layout based on the viewport size (not based on the size of the parent container), and it only supports layouts 
			at five different viewport sizes.
		</p>

		<figure class="example bootstrap">
			<img src="images/bootstrap-1000px.png" alt="bootstrap column layout on a 1000px wide viewport">
			<img src="images/bootstrap-600px.png" alt="bootstrap column layout on a 600px wide viewport">
			<figcaption>
				Bootstrap layout on a 1000px wide viewport (left); and a 600px wide viewport (right).
			</figcaption>
		</figure>
		<style>
			.example.bootstrap {
				display: grid;
				grid-template-columns: 5fr 2fr;
			}

			.example.bootstrap figcaption {
				grid-column: 1 / -1;
			}
		</style>

		<p>
			But don't stress - modern CSS now gives us a bunch of different options for controlling layouts. These options are pure CSS 
			(you don't need to add extra HTML), and they are completely responsive.
		</p>

		<p>
			One thing we should note before we start though. These new layout properties do not give you complete control over how your 
			page is laid out. Instead, it gives you a way to communicate some guidelines to the browser, and the browser will work out 
			the best layout, based on your requirements. This, in fact, is how all CSS works - it was never intended for specifying pixel-perfect 
			layouts. Which makes a lot of sense - you have no way of knowing what kind of device your page is going to be displayed on, and 
			it would be very tedious to try and specify every possible layout. Your time writing CSS is going to be a lot happier if you 
			remember that the web is a dynamic medium, and that CSS is specifically designed to support that dynamicism.
		</p>

		<h3>Flexbox</h3>

		<p>
			<code>display: flex</code> creates a flexible, one-dimensional layout. Setting <code>display: flex</code> on an element 
			creates a flexbox inside that element. A flexbox is kind of like a line box, but with super powers.
		</p>

		<img src="images/she-ra.jpeg" alt="She Ra, the best super hero">

		<h4>Changing direction</h4>

		<p>
			You can control the direction that your flexbox runs using the <code>flex-direction</code> property. There are four possible 
			values.
		</p>
		<dl>
			<dt><code>row</code></dt>
			<dd>Items will be placed in the inline direction. So, if our page is in English, left to right, across the page.</dd>
			<dt><code>row-reverse</code></dt>
			<dd>
				Items will be placed along the inline axis, but in the opposite direction to the way text goes.
				On our hypothetical English-speaking page, that would be right to left, across the page.
			</dd>
			<dt><code>column</code></dt>
			<dd>Items will be placed in the block direction. So on our page, from top to bottom, down the page.</dd>
			<dt><code>column-reverse</code></dt>
			<dd>
				Items will be placed along the block axis, but in the opposite direction to the way the text goes.
				On our page, that's bottom to top, up the page.
			</dd>
		</dl>

		<p>
			Why do we use <code>row</code> and <code>column</code> instead of <code>block</code> and <code>inline</code>?
			I have no idea. I suspect it's because the spec was written before the serious efforts at standardising CSS properties 
			began.
		</p>

		<h4>Wrapping</h4>

		<p>
			By default, the browser will try to fit all your items into a single flex box. (We'll go into how it does this in a bit).
			If you would prefer it to wrap (like a line box), then you can set <code>flex-wrap: wrap</code>.
		</p>

		<div class="example grid flex-wrap">
			<label for="flex-wrap-direction">flex direction</label>
			<select id="flex-wrap-direction" onchange="updateFlexWrapDirection()">
				<option value="row">row</option>
				<option value="row-reverse">row-reverse</option>
				<option value="column">column</option>
				<option value="column-reverse">column-reverse</option>
			</select>
			<label for="flex-wrap">wrap</label>
			<input type="checkbox" id="flex-wrap" onchange="updateFlexWrap()">
			<div class="container">
				<div class="element numbered">1</div>
				<div class="element numbered">2</div>
				<div class="element numbered">3</div>
				<div class="element numbered">4</div>
				<div class="element numbered">5</div>
				<div class="element numbered">6</div>
			</div>
		</div>

		<style>
			div.example.flex-wrap {
  			grid-template-columns: repeat(3, auto) 1fr;
				align-items: center;
				grid-gap: 0 10px;
			}

			.example.flex-wrap .container {
				display: flex;
				width: 500px;
				max-height: 500px;
				align-items: center;
				grid-column: 1 / -1;
				height: 500px;
				justify-self: center;
			}
			.example.example.flex-wrap .element {
				flex-basis: 100px;
				height: 100px;
				width: 100px;
			}
			#flex-wrap {
				justify-self: flex-start;
			}
		</style>

		<script>
			const flexWrapContainer = document.querySelector('.example.flex-wrap .container');
			const flexWrapSelect = document.getElementById('flex-wrap-direction');
			flexWrapSelect.value = 'row';
			const flexWrapCheckbox = document.getElementById('flex-wrap');
			flexWrapCheckbox.checked = false;
			function updateFlexWrapDirection() {
				flexWrapContainer.style.flexDirection = flexWrapSelect.value;
			}
			function updateFlexWrap() {
				const wrap = flexWrapCheckbox.checked;
				flexWrapContainer.style.flexWrap = wrap ? 'wrap' : 'nowrap';
			}
		</script>

		<h4>Line height & line spacing</h4>

		<p>
			For the purposes of this discussion, let's assume we're working with a row. We'll be 
			calculating the height of a row, and the spacing between rows. If we were working with 
			a column, then we could use the same rules to calculate the width of the column and the 
			spacing between columns. 
		</p>

		<p>
			Things start out relatively simple - by default, each row will get the same fraction of 
			the height of the flex container. If all your items fit in one row, that row will be 
			100% of the height of the container. If you need two rows, then each row will be 50% of 
			the height of the container. And so on, and so forth.
		</p>

		<p>
			There are two ways to change this. Firstly, if an item is too tall for its row, then its 
			row will grow taller, and the other rows will shrink. An item could be too tall because 
			it has a height set on it, or because it has a lot of content.
		</p>

		<p>
			The second way is to change the <code>align-content</code> property of the flex-container.
			By default, <code>align-content</code> is <code>stretch</code>, meaning each row will 
			stretch to fill up the available space.
		</p>
			
		<figure class="example flex default-align-content">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</figure>

		<style>
			.flex {
				display: flex;
			}
			.example.default-align-content {
				flex-wrap: wrap;
				width: 350px;
				height: 450px;
			}
			.flex.default-align-content .element {
				width: 100px;
				height: auto;
			}

			.flex .element {
				width: 100px;
				height: 100px;
			}
		</style>
			
		<p>
			If we change it to any other value, then the height 
			of each row will be the height of the tallest element in that row. The rows will then be 
			spaced according to the following table.
		</p>
			
		<table class="align-content-values">
			<thead>
				<th>Value</th><th>Effect</th><th>Diagram</th>
			</thead>
			<tbody>
				<tr>
					<td>flex-start/start</td>
					<td>Rows will be placed towards the start of the container</td>
					<td>
						<div class="example" style="align-content: start">
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
						</div>
					</td>
				</tr>
				<tr>
					<td>flex-end/end</td>
					<td>Rows will be placed towards the end of the container</td>
					<td>
						<div class="example" style="align-content: end">
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
						</div>
					</td>
				</tr>
				<tr>
					<td>center</td>
					<td>Rows will be placed in the centre of the container</td>
					<td>
						<div class="example" style="align-content: center">
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
						</div>
					</td>
				</tr>
				<tr>
					<td>space-between</td>
					<td>
						The first row will be at the start of the container, the last row will be at the end of the container.
						The remaining rows will be spaced evenly between them.
					</td>
					<td>
						<div class="example" style="align-content: space-between">
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
						</div>
					</td>
				</tr>
				<tr>
					<td>space-around</td>
					<td>
						Rows are spaced evenly in the container. The space between the container and the first row, and the container and 
						the last row, is <i>half</i> of the space between adjacent rows.
					</td>
					<td>
						<div class="example" style="align-content: space-around">
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
						</div>
					</td>
				</tr>
				<tr>
					<td>space-evenly</td>
					<td>
						Rows are spaced evenly in the container. The space between the container and the first row, and the container and
						the last row, is the <i>same</i> as the space between adjacent rows.
					</td>
					<td>
						<div class="example" style="align-content: space-evenly">
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
						</div>
					</td>
				</tr>
				<tr>
					<td>stretch</td>
					<td>
						If none of the elements have a height specified, then all the rows will 
						be of equal height, stretched to fill up the available space. If any elements 
						have a height specified, then those elements will have their given height, and 
						the remaining space will be spread out equally between all rows, including the 
						ones that already have some height. This can lead to some unpredictable 
						behaviour (try adding heights to the example via dev tools).
					</td>
					<td>
						<div class="example stretch" style="align-content: stretch">
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
							<div class="element"></div>
						</div>
					</td>
				</tr>
			</tbody>
		</table>

		<style>
			.align-content-values {
				border: 2px solid currentColor;
				border-collapse: collapse;
			}

			.align-content-values th, .align-content-values td {
				padding: 10px;
				border: 1px solid currentColor;
			}
			.align-content-values td {
				vertical-align: top;
			}

			.align-content-values .example {
				display: flex;
				flex-wrap: wrap;
				border-style: dashed;
				width: 120px;
				height: 120px;
				padding: 0;
			}
			.align-content-values .element {
				width: 30px;
				height: 30px;
				border-width: 1px;
				border-radius: 3px;
				padding: 0;
			}
			.align-content-values .stretch .element {
				height: auto;
			}
		</style>

		<p>
			Remember, terms like start and end are dependent on the <code>flex-direction</code>.
		</p>
		<div style="display: flex; align-items: center">
			<label for="flex-direction-table" style="margin-right: 10px">flex-direction </label>
			<select name="flex-direction-table" id="flex-direction-table">
				<option value="row">row</option>
				<option value="row-reverse">row-reverse</option>
				<option value="column">column</option>
				<option value="column-reverse">column-reverse</option>
			</select>
		</div>
		<script>
			const alignContentExamples = document.querySelectorAll('table.align-content-values .example');
			const directionSwitcher = document.getElementById('flex-direction-table');
			directionSwitcher.value = 'row';
			directionSwitcher.addEventListener('change', function () {
				alignContentExamples.forEach((example) => {
					example.style.flexDirection = this.value;
				})
			});
		</script>

		<p>
			<code>start</code> and <code>end</code> are new values, intended to replace <code>flex-start</code> and <code>flex-end</code>,
			to give us a more flexible way of defining alignment and justification (ie so we can use them in grid too!). They're currently 
			only supported by Firefox.
		</p>

		<p>
			<code>stretch</code> isn't supported in IE and some versions of Edge.
		</p>

		<p>
			Check <a href="https://developer.mozilla.org/en-US/docs/Web/CSS/align-content">the MDN article on <code>align-content</code></a>
			for up-to-date browser compatiblity data.
		</p>

		<h4>Alignment</h4>

		<p>
			Just like we can use <code>vertical-align</code> to place an item relative to a line box, we can use <code>align-self</code> to
			place an item relative to the flex-box. By default, <code>align-self</code> is <code>stretch</code>, which means the item 
			will stretch to fill the height (or width) of the entire flexbox. You can also set it to <code>flex-start/start</code>, 
			<code>flex-end/end</code>, or <code>center</code>.
		</p>

		<div class="example align-self">
			<label for="align-self">align-self</label>
			<select id="align-self" onchange="changeAlignSelf()">
				<option value="stretch">stretch</option>
				<option value="flex-start">flex-start</option>
				<option value="flex-end">flex-end</option>
				<option value="center">center</option>
			</select>
			<div class="container flex">
				<div class="element"></div>
				<div class="element highlight"></div>
				<div class="element"></div>	
			</div>
		</div>

		<style>
			.example.align-self .element {
				margin-right: 10px;
				padding: 0;
			}
			.example.align-self .highlight {
				width: auto;
				height: auto;
			}
			.example.align-self .highlight::before {
				content: '';
				display: block;
				width: 50px;
				height: 50px;
			}
		</style>

		<script>
			const alignSelfSelect = document.getElementById('align-self');
			alignSelfSelect.value = 'stretch';
			const alignSelfElement = document.querySelector('.example.align-self .highlight');
			function changeAlignSelf() {
				alignSelfElement.style.alignSelf = alignSelfSelect.value;
			}
		</script>

		<p>
			And if you don't want to set the alignment on every item individually, you can use <code>align-items</code> on the flex container 
			to align all the children at once.
		</p>

		<div class="example align-items">
			<div class="controls">
				<label for="align-items">align-items</label>
				<select id="align-items" onchange="changeAlignItems()">
					<option value="stretch">stretch</option>
					<option value="flex-start">flex-start</option>
					<option value="flex-end">flex-end</option>
					<option value="center">center</option>
				</select>	
			</div>
			<div class="container flex">
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>	
			</div>
		</div>

		<style>
			.example.align-items .container {
				height: 100px;
			}
			.example.align-items .element {
				margin-right: 10px;
				width: auto;
				height: auto;
				padding: 0;
			}
			.example.align-items .element::before {
				content: '';
				display: block;
				width: 50px;
				height: 50px;
			}
		</style>

		<script>
			const alignItemsSelect = document.getElementById('align-items');
			alignItemsSelect.value = 'stretch';
			const alignItemsElement = document.querySelector('.example.align-items .container');
			function changeAlignItems() {
				alignItemsElement.style.alignItems = alignItemsSelect.value;
			}
		</script>

		<p>
			While it might seem like <code>align-content</code> and <code>align-items</code> do the same thing, there is an important difference. 
			<code>align-content</code> adjusts the spacing <i>between</i> the flexboxes (like line-height for line boxes). <code>align-items</code> (and 
			<code>align-self</code>) controls the placement of the items <i>within</i> the flexbox (like <code>vertical-align</code>, except 
			that it will actually do that centre-alignment for you).
		</p>

		<h4>Justification</h4>

		<p>
			We can also control how the flex items are laid out in the inline direction. We can do this via the <code>justify-content</code> property. 
			<code>justify-content</code> takes the same values as <code>align-content</code>, and has similar browser support.
		</p>

		<div class="example justify-content">
			<div class="controls">
				<label for="justify-content">justify-content</label>
				<select id="justify-content" onchange="changeJustifyContent()">
					<option value="flex-start">flex-start</option>
					<option value="flex-end">flex-end</option>
					<option value="center">center</option>
					<option value="space-between">space-between</option>
					<option value="space-around">space-around</option>
					<option value="space-evenly">space-evenly</option>
				</select>	
			</div>
			<div class="container flex">
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>	
			</div>
		</div>

		<style>
			.example.justify-content .container {
				height: 100px;
				width: 100%;
			}
			.example.justify-content .element {
				width: 100px;
				height: 100px;
			}
		</style>

		<script>
			const justifyContentSelect = document.getElementById('justify-content');
			justifyContentSelect.value = 'flex-start';
			const justifyContentElement = document.querySelector('.example.justify-content .container');
			function changeJustifyContent() {
				justifyContentElement.style.justifyContent = justifyContentSelect.value;
			}
		</script>

		<p>
			Are all these align and justify properties confusing? Yes. Do I have a good way of remembering them, other than just practice? 
			Not really. You can try to remember that "justify" is like justifying text, and goes in the same direction. And "align" is like 
			<code>vertical-align</code>? I guess? I can't help you with "content" and "items", except to say that "x-items" can be overridden 
			by "x-self", because it refers to the items individually. "x-content" refers to the items as a whole, so a single one can't be set
			differently. <code>flex</code> lacks a <code>justify-items/justify-self</code>, because it only operates in one dimension. 
			If you find yourself needing to do that, then you should think about using <code>grid</code>.
		</p>

		<p>
			And, if you want to practice using these properties, I recommend checking out <a href="https://flexboxfroggy.com/">
			Flexbox Froggy</a> - it's a cute game where you use <code>flex</code> properties to position frogs on lilypads. 
		</p>

		<h4>Flex sizing - cross axis</h4>

		<p>
			So far, we've looked at positioning things with <code>flex</code>. However, the real magic of <code>flex</code> comes from how 
			items within a flexbox are sized. And I'm not going to lie, it involves a bit of browser voodoo.
		</p>

		<p>
			First up, let's have a look at size in the cross-axis direction. The cross-axis direction means the direction perpendicular to 
			the flow of text. If we're working with a row going across the page, then we're talking about the height. If we're working with 
			a column going down the page, then we're talking about the width. For the sake of simplicity, let's assume it's a row, and we're 
			talking about height. 
		</p>

		<figure class="example flex-axes" style="position: relative">
			<img src="images/arrows.png">
			<div class="axis-label" id="cross-axis">cross axis</div>
			<div class="axis-label" id="main-axis">main axis</div>
			<figcaption>
				<input type="radio" name="flex-axes" id="axes-row" value="row">
				<label for="axes-row">Row</label>
				<input type="radio" name="flex-axes" id="axes-column" value="column">
				<label for="axes-column">Column</label>
			</figcaption>
		</figure>

		<style>
			.flex-axes .axis-label {
				--shadow: hsla(0, 0%, 100%, .9);
				font-family: Kalam;
				font-size: 45px;
				position: absolute;
				filter: drop-shadow(4px 4px 4px var(--shadow)) drop-shadow(-4px -4px 4px var(--shadow));
				transition: all 2s;
			}
			#cross-axis, .flipped #main-axis {
				left: 30%;
				top: 10%;
			}
			#main-axis, .flipped #cross-axis {
				left: 10%;
				top: 45%;
			}
		</style>

		<script>
			const axesContainer = document.querySelector('.flex-axes');
			const rowAxes = document.getElementById('axes-row');
			const columnAxes = document.getElementById('axes-column');
			rowAxes.checked = true;
			rowAxes.addEventListener('change', function() {
				if (this.checked) {
					axesContainer.classList.remove('flipped');
				} 
			});
			columnAxes.addEventListener('change', function() {
				if (this.checked) {
					axesContainer.classList.add('flipped');
				} 
			});
		</script>

		<p>
			Luckily, this one isn't <i>too</i> complicated. </p>
		<ul>
			<li>
				If you've set a height, and an alignment (<code>align-items</code> or <code>align-self</code>), then your item 
				will have the given height and alignment.
			</li>
			<li>
				If you've set a height, but not an alignment, your item will have the given height, and be aligned to the start of the container.
			</li>
			<li>
				If you've set an alignment, but not a height, your item will have the given alignment, and be as tall as it needs to be to 
				fit its contents.
			</li>
			<li>
				If you haven't set an alignment <i>or</i> a height, your item will default to an alignment of <code>stretch</code> and fill 
				the entire height of the container.
			</li>
		</ul>
		
		<div class="example flex vertical-sizing" style="min-height: 400px; margin-top: 20px;">
			<div class="element" style="height: 200px; align-self: flex-end">
				<code>height: 200px; align-self: flex-end</code>
			</div>
			<div class="element" style="height: 200px">
				<code>height: 200px</code>
			</div>
			<div class="element" style="align-self: center">
				<code>align-self: center</code> with lots and lots and lots and lots and lots and lots of content.
			</div>
			<div class="element" style="align-self: center">
				<code>align-self: center</code> and a small bit of content
			</div>
			<div class="element">
				no height, no alignment
			</div>
		</div>

		<style>
			.example.vertical-sizing .element {
				width: 200px;
				height: auto;
			}
		</style>

		<p>
			If your item contains dynamic content (ie, you don't know how big it needs to be in advance), then I recommend setting 
			the alignment to whatever you like, and letting the browser work out the height. It will almost certainly do a good job.
		</p>

		<p>
			You should also make sure that you set the alignment if your element is an image. Otherwise, the default alignment of 
			<code>stretch</code> is going to completely trash the aspect ratio.
		</p>

		<div class="example flex borked-ratio">
			<div>
				Whenever Pikachu comes across something new, it blasts it with a jolt of electricity. 
				If you come across a blackened berry, it's evidence that this Pokémon mistook the intensity of its charge. 
			</div>
			<img src="images/pikachu.png" alt="pikachu">
			<div>
				This Pokémon came from the future by crossing over time. 
				It is thought that so long as Celebi appears, a bright and shining future awaits us. 
			</div>
			<img src="images/celebi.jpeg" alt="celebi">
			<div>
				Eevee has an unstable genetic makeup that suddenly mutates due to the environment in which it lives. 
				Radiation from various stones causes this Pokémon to evolve. 			</div>
			<img src="images/eevee.jpeg" alt="eevee">
		</div>

		<style>
			.example.borked-ratio div, .example.fixed-ratio div, .example.borked-ratio img, .example.fixed-ratio img {
				width: 15%;
				margin: 0;
				border: 0;
			}
			.example.borked-ratio div:not(:first-child), .example.fixed-ratio div:not(:first-child) {
				margin-left: 20px;
			}
		</style>

		<p>
			This is easily corrected by adding <code>align-self: flex-start</code>.
		</p>

		<div class="example flex fixed-ratio">
			<div>
				Whenever Pikachu comes across something new, it blasts it with a jolt of electricity. 
				If you come across a blackened berry, it's evidence that this Pokémon mistook the intensity of its charge. 
			</div>
			<img src="images/pikachu.png" alt="pikachu">
			<div>
				This Pokémon came from the future by crossing over time. 
				It is thought that so long as Celebi appears, a bright and shining future awaits us. 
			</div>
			<img src="images/celebi.jpeg" alt="celebi">
			<div>
				Eevee has an unstable genetic makeup that suddenly mutates due to the environment in which it lives. 
				Radiation from various stones causes this Pokémon to evolve. 			</div>
			<img src="images/eevee.jpeg" alt="eevee">
		</div>

		<div>Source: <a href="https://www.pokemon.com/us/pokedex/">Pokedex</a></div>

		<style>
			.example.fixed-ratio div {
				width: 200px;
			}
			.example.fixed-ratio img {
				align-self: flex-start;
				margin: 0;
			}
		</style>

		<h4>Flex sizing - main axis</h4>

		<p>
			The size along the main axis is a lot more complicated to work out, but you also have more control over what happens. So I guess 
			it balances out? Assuming we're still working on a horizontal row, this is going to be the width of the elements.
		</p>

		<p>
			The width of a flex item depends on 
		</p>
		<ul>
			<li>its contents</li>
			<li>its flex-basis property</li>
			<li>whether it's allowed to grow or shrink</li>
			<li>the size of its flex container</li>
			<li>how much other stuff is in the container</li>
		</ul>

		<p>
			For the sake of simplicity, let's start with a flexbox with a single item in it. The flexbox is much bigger than the item.
		</p>

		<div class="example flex fitting">
			<div class="element">A element with some content in it</div>
		</div>
		<style>
			.example.fitting {
				min-width: 35em;
				max-width: 400px;
			}
			.example.fitting .element {
				width: unset;
				height: unset;
			}
		</style>

		<p>
			The element will stretch out as big as it can get, without wasting any space. If the element contains only inline elements (or text), it 
			will be wide enough that everything can fit in a single line box. This is called the <code>max-content</code> width. 
			(And <code>max-content</code> is an allowed value, anywhere that you can set a <code>width</code> or <code>height</code>).
		</p>

		<p>
			Let's add some more elements. 
		</p>

		<div class="example flex fitting">
			<div class="element">A element with some content in it</div>
			<div class="element">Another element</div>
			<div class="element">Another element with a fair bit more content in it</div>
		</div>

		<p>
			Now, there's not enough room for all the elements at their max-content width, so they've all shrunk a bit. The elements will all shrink
			at the same rate. In our case, if all the elements were at their max-content width, they would take up about 2000px. The container is 
			only about 650px wide though. So each element will shrink by 650 / (2000 - 650) = 40%. (I fudged the numbers a litte, so don't go 
			looking too hard in the dev tools, but hopefully you get the idea.)
		</p>

		<p>
			If we don't want the element to stretch out to its max-content width, we can set a size manually, via the <code>flex-basis</code>
			property. The <code>flex-basis</code> property will refer to the width of an element in a row, or a the height of an element in 
			a column. If we have a single item, in a large container, with a <code>flex-basis</code>, then its width will be its <code>flex-basis</code>
			value.
		</p>

		<div class="example flex fitting">
			<div class="element" style="flex-basis: 400px" contenteditable="true">flex-basis: 400px</div>
		</div>

		<p>
			If we have multiple items with <code>flex-basis</code>, and they don't all fit, they'll all shrink at the same rate, just 
			like before.
		</p>

		<div class="example flex fitting">
			<div class="element" style="flex-basis: 400px">flex-basis: 400px</div>
			<div class="element" style="flex-basis: 200px">flex-basis: 200px</div>
			<div class="element" style="flex-basis: 300px">flex-basis: 300px</div>
		</div>

		<p>
			One thing to note - if you set a <code>width</code>, rather than a <code>flex-basis</code>, then the <code>flex-basis</code> will 
			be the same as the <code>width</code>. If you set a <code>width</code> <i>and</i> a <code>flex-basis</code>, then the 
			<code>width</code> will be ignored. <code>flex-basis</code> is also what's used by the <code>flex</code> shorthand property we're 
			going to look at shortly. As such, I'd recommend using <code>flex-basis</code> over <code>width</code>, but it's not going to 
			make a big difference.
		</p>

		<p>
			Oh, and if you're using columns instead of rows, replace "width" with "height" everywhere above!
		</p>

		<h4>Controlling shrinkage</h4>

		<p>
			Ok, so, by default flex-items are going to try to be their <code>flex-basis</code> width. If they don't have a <code>flex-basis</code>,
			they will try to be their <code>max-content</code> width. If all of the flex items can't fit at their preferred width, they will 
			shrink at the same rate. 
		</p>

		<p>
			But what happens if there's nowhere near enough room and they have to shrink <i>a lot</i>. Well, it turns out that shrinking is not 
			a complete free-for-all. There are some rules.
		</p>

		<div class="example flex fitting">
			<div class="element">A element with some content in it</div>
			<div class="element">Antidisestablishmentarianism</div>
			<div class="element">Another element with a fair bit more content in it</div>
			<div class="element">Hi</div>
		</div>

		<p>
			No element will shrink below its <code>min-content</code> width. The <code>min-content</code> width is the smallest possible width that 
			the element can be, while still fitting its content. If your element just contains text, then it will be the size of the longest word.
			If your element contains other elements, it will be the size of the largest child element.
		</p>

		<p>
			You can also set a <code>min-width</code> on your element.
		</p>

		<div class="example flex fitting">
			<div class="element" style="flex-basis: 400px">flex-basis: 400px</div>
			<div class="element" style="flex-basis: 200px">flex-basis: 200px</div>
			<div class="element" style="min-width: 340px">min-width: 340px</div>
			<div class="element" style="flex-basis: 300px">flex-basis: 300px</div>
		</div>

		<p>
			No element will shrink below its <code>min-width</code> (or <code>min-height</code>, in a column). If the <code>min-width</code> is 
			smaller than the <code>min-content</code> width, then the element won't reach its <code>min-width</code> - it'll stop shrinking
				at its <code>min-content</code> width.
		</p>

		<p>
			If the elements are still too big after shrinking as much as they can, they'll overflow the container.
		</p>

		<div class="example flex flex-overflow">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</div>

		<style>
			.example.flex-overflow {
				width: 400px;
				padding: 5px;
			}
			.example.flex-overflow .element {
				min-width: 150px;
				height: 100px;
			}
		</style>

		<p>
			We can also control the rate at which elements shrink, or stop them from shrinking altogether. We do this via the 
			<code>flex-shrink</code> property.
			The default value of <code>flex-shrink</code> is 1. This means "shrink the same amount as all 
			the other elements". If we don't want an element to shrink at all, we can set <code>flex-shrink: 0</code>.
		</p>

		<style>
			.resize {
				resize: horizontal;
				overflow: hidden;
			}

			.shrink-0 .element {
				height: auto;
			}
		</style>

		<figure class="example">
			<div class="container flex resize">
				<div class="element" style="width: 250px; flex-shrink: 0">
					<div>width: 150px</div>
					<div>flex-shrink: 0</div>
				</div>
				<div class="element" style="width: 250px;">
					<div>width: 150px</div>
					<div>flex-shrink: 1</div>
				</div>
				<div class="element" style="width: 250px;">
					<div>width: 150px</div>
					<div>flex-shrink: 1</div>
				</div>
			</div>
			<figcaption>
				You can resize the container with the handle at the bottom-right corner. It's practically invisible in Chrome, 
				but trust me, it's there. These boxes will get cut off, rather than overflowing, if the container is too small.
				This is necessary to make the resize work properly, and has nothing to do with flex.
			</figcaption>
		</figure>

		<p>
			If we want an element to shrink at a different rate to the other elements, we can give it a different value of <code>flex-shrink</code>.
			An element with <code>flex-shrink: 2</code> will shrink twice as fast as elements with the default. So, if the default elements 
			shrink by 10%, our <code>flex-shrink: 2</code> element would shrink 20%. An element with <code>flex-shrink: 0.5</code> would shrink 
			only 5%. <code>flex-shrink</code> can take any positive number.
		</p>

		<figure class="example">
			<div class="container flex resize">
				<div class="element" style="width: 250px;">
					<div>width: 150px</div>
					<div>flex-shrink: 1</div>
				</div>
				<div class="element" style="width: 250px; flex-shrink: 2">
					<div>width: 150px</div>
					<div>flex-shrink: 2</div>
				</div>
				<div class="element" style="width: 250px; flex-shrink: 0.5">
					<div>width: 150px</div>
					<div>flex-shrink: 0.5</div>
				</div>
			</div>
		</figure>

		<p>
			Finally, if you have <code>flex-wrap: wrap</code>, the elements won't shrink at all. If they don't all fit, they'll just wrap 
			to another line.
		</p>

		<figure class="example flex-overflow-wrap">
			<div class="container flex resize">
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>	
			</div>
			<figcaption>
				This container has <code>flex-wrap: wrap</code>. If you resize it so it's smaller than the elements, the elements 
				will wrap rather than shrinking.
			</figcaption>
		</figure>
	
		<style>
			.example.flex-overflow-wrap .container {
				flex-wrap: wrap;
			}
			.example.flex-overflow-wrap .element {
				min-width: 150px;
				height: 100px;
			}
		</style>

		<h4>Growing our elements</h4>

		<p>
			We can also make our elements grow to fill the available space, via the <code>flex-grow</code> property.
			<code>flex-grow</code> works like <code>flex-shrink</code>, but in reverse. Like <code>flex-shrink</code>, it 
			controls the rate at which the elements grow, so an element's final size will depend on its starting size, the size 
			of the container, and what else is in the container.
		</p>

		<p>
			By default, <code>flex-grow</code> has a value of 0, meaning the element won't grow at all. Setting the value to 
			any positive number will cause the element to grow. You can also set a <code>max-width</code>, to cap the size 
			the element will grow to.
		</p>

		<p>The flex-grow algorithm can be a little tricky to grasp, so let's step through an example.</p>

		<p>
			We'll start with some markup.
		</p>
	
		<pre><code class="html">
&lt;div class="container"&gt;
	&lt;div class="element"&gt;&lt;/div&gt;
	&lt;div class="element"&gt;&lt;/div&gt;
	&lt;div class="element"&gt;&lt;/div&gt;
&lt;/div&gt;
		</code></pre>

		<p>And some styling.</p>

		<pre><code class="css">
.container {
	display: flex;
	width: 400px;
}

.container .element {
	flex-basis: 100px;
	height: 100px;
}

.container .element:nth-child(1) {
	flex-grow: 1;
}
.container .element:nth-child(2) {
	flex-grow: 2;
}
.container .element:nth-child(3) {
	flex-grow: 3;
}
		</code></pre>

		<p>
			First, the we're is going to place all of the elements in the flexbox, using their flex-basis values.
		</p>

		<style>
			.flex-grow-steps {
				width: 400px;
				margin: auto;
				padding: 0;
			}
		</style>

		<div class="example flex flex-grow-steps step-1">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>	
		</div>
	
		<p>
			Then we're going to calculate how much space is left over in the container (the shaded region below).
		</p>

		<div class="example flex flex-grow-steps step-2">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>	
			<div class="leftover"></div>
		</div>

		<style>
			.leftover {
				--colour: hsla(250, 50%, 50%, .6);
				flex-grow: 1;
				border: 2px solid var(--colour);
				background: repeating-linear-gradient(135deg, transparent, transparent 8px, var(--colour), var(--colour) 10px);
			}
		</style>

		<p>
			The container has a width of 400px, and we have three elements, 100px wide each.
		</p>
		<div>400px - (3 * 100px) = 100px</div>
		<p>
			So we've got 100px of free space. We'll remember that for later.
		</p>

		<p>
			Next we need to work out how many flex-grow "units" we have. The first element has 1, the second has 2, and the third has 3.
		</p>
		<div>1 + 2 + 3 = 6</div>
		<p>We've got a total of 6 flex-grow units.</p>

		<p>
			Then we divide the free space by the number of flex-grow units to calculate the amount of space per flex-grow.
		</p>
		<div>100px / 6 = 16px (more or less)</div>

		<p>
			Finally, we distribute the remaining space between the elements, based on how many flex-grow units they need. The first 
			element has <code>flex-grow: 1</code>, so it gets 1 * 16px = 16px. The second has <code>flex-grow: 2</code>, so it gets 
			2 * 16px = 32px. And the third has <code>flex-grow: 3</code>, so it gets 3 * 16px = 48px.
		</p>

		<p>Which results in a layout like this.</p>

		<div class="example flex flex-grow-steps step-3">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>	
		</div>

		<style>
			.flex-grow-steps.step-3 .element:nth-child(1) {
				flex-grow: 1;
			}
			.flex-grow-steps.step-3 .element:nth-child(2) {
				flex-grow: 2;
			}
			.flex-grow-steps.step-3 .element:nth-child(3) {
				flex-grow: 3;
			}
		</style>

		<p>The first element is 116px wide, the second is 132px and the third is 148px.</p>

		<p>
			Now, in the real world, things are usually a little more complicated than this, as we have to take content, and 
			max-widths and stuff into account. Hopefully though, this is enough to give you an idea of how it works. I recommend 
			playing around with this stuff in the dev tools, and checking out Firefox's flex inspector, for some help visualising 
			what your flex container is doing.
		</p>

		<p>
			Unlike <code>flex-shrink</code>, <code>flex-grow</code> will work with with <code>flex-wrap: wrap</code>. Elements 
			will grow to take up all the available space in each line. The grow-rate for each line is determined independently
			though, so different lines might grow at different rates.
		</p>

		<div class="example flex multi-line-grow">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</div>

		<style>
			.example.multi-line-grow {
				flex-wrap: wrap;
				width: 400px;
			}
			.example.multi-line-grow .element {
				flex-grow: 1;
			}
		</style>
	
		<h4>Doing it all at once</h4>

		<p>
			It's reasonably common to want to set all of <code>flex-grow</code>, <code>flex-shrink</code>, and <code>flex-basis</code> on an element.
			Good news: there's a shortcut for that! <code>flex: grow shrink basis</code>. The default value is <code>0 1 0</code>, and both 
			of the second two values are optional. (You can set just <code>flex-grow</code> and <code>flex-basis</code>, but you need to use 
			a unit on the <code>flex-basis</code> value, else it will be interpreted as <code>flex-shrink</code>!)
		</p>

		<p>
			You can try out the <code>flex</code> property below, as well as experimenting with how different content affects the final 
			size of elements. (You can type directly into the bottom part of each element to add content.) You can also resize the container, 
			using the handle on the bottom right.
		</p>

		<div class="example flex-grow">
			<div class="controls">
				<input type="radio" id="flex-grow-wrap" name="flex-grow-wrap" onchange="updateFlexGrowWrap(true)" checked>
				<label for="flex-grow-wrap">flex-wrap: wrap</label>
				<input type="radio" id="flex-grow-nowrap" name="flex-grow-wrap" onchange="updateFlexGrowWrap(false)">
				<label for="flex-grow-nowrap">flex-wrap: nowrap</label>
			</div>

			<div class="container resize flex">
				<div class="element">
					<label for="flex-0">flex:</label>
					<input id="flex-0" type="text">
					<div contenteditable="true">add content</div>
				</div>
				<div class="element">
					<label for="flex-1">flex:</label>
					<input id="flex-1" type="text">
					<div contenteditable="true">add content</div>
				</div>
				<div class="element">
					<label for="flex-2">flex:</label>
					<input id="flex-2" type="text">
					<div contenteditable="true">add content</div>
				</div>
				<div class="element">
					<label for="flex-3">flex:</label>
					<input id="flex-3" type="text">
					<div contenteditable="true">add content</div>
				</div>
			</div>
		</div>

		<style>
			.example.flex-grow .controls {
				display: grid;
				grid-template-columns: min-content max-content min-content max-content;
				align-items: center;
				grid-gap: 10px;
			}
			.example.flex-grow .controls label {
				justify-self: flex-start;
				margin-right: 20px;
			}
			.example.flex-grow .container {
				width: 100%;
			}
			.example.flex-grow .element {
				flex: 0 1 200px;
				height: auto;
			}
			.example.flex-grow .element input {
				width: 6em;
			}
		</style>

		<script>
			const flexGrowContainer = document.querySelector('.example.flex-grow .container');
			flexGrowContainer.style.flexWrap = 'wrap';
			function updateFlexGrowWrap(value) {
				flexGrowContainer.style.flexWrap = value ? 'wrap' : 'nowrap';
			}

			document.querySelectorAll('.example.flex-grow input[id^=flex]').forEach((input) => {
				input.value = '0 1 200px';
				input.addEventListener('change', function () {
					this.parentElement.style.flexGrow = this.value;
				});
			});

			document.getElementById('flex-grow-wrap').checked = true;
		</script>

		<h4>Rearranging elements</h4>

		<p>
			The final bit of magic that flex can do is to change the order that elements appear in. As we already mentioned, you can set 
			<code>flex-direction</code> to <code>row-reverse</code> or <code>column-reverse</code> to invert the order of the line.
			You can also set <code>flex-wrap</code> to <code>wrap-reverse</code> to reverse the wrapping order. (So in a
			<code>flex-direction: row</code> situation, <code>flex-wrap: wrap-reverse</code> would cause the second row to appear 
			<i>above</i> the first one.)
		</p>

		<p>
			You can also control the placement of individual elements, by setting the <code>order</code>. Elements will appear in 
			order corresponding to their <code>order</code> value. <code>order</code> can be any integer value, and the default 
			is <code>0</code>. So an element with <code>order: -1</code>, will appear first in its line. An element with 
			<code>order: 1</code> will appear last (assuming no other <code>order</code>s have been set).
		</p>

		<div class="example reordering">
			<div class="controls">
				<label for="order-flex-direction">flex-direction</label>
				<select name="flex-direction" id="order-flex-direction">
					<option value="row">row</option>
					<option value="row-reverse">row-reverse</option>
					<option value="column">column</option>
					<option value="column-reverse">column-reverse</option>
				</select>
	
				<label for="order-flex-wrap">flex-wrap</label>
				<select name="flex-wrap" id="order-flex-wrap">
					<option value="nowrap">nowrap</option>
					<option value="wrap">wrap</option>
					<option value="wrap-reverse">wrap-reverse</option>
				</select>	
			</div>

			<div class="container flex" style="margin-top: 20px">
				<div class="element">
					<span>Element 1</span>
					<label for="order-element-1">order:</label>
					<input type="number" step="1" id="order-element-1">
				</div>
				<div class="element">
					<span>Element 2</span>
					<label for="order-element-2">order:</label>
					<input type="number" step="1" id="order-element-2">
				</div>
				<div class="element">
					<span>Element 3</span>
					<label for="order-element-3">order:</label>
					<input type="number" step="1" id="order-element-3">
				</div>
				<div class="element">
					<span>Element 4</span>
					<label for="order-element-4">order:</label>
					<input type="number" step="1" id="order-element-4">
				</div>
			</div>
		</div>

		<style>
			.example.reordering .container {
				max-height: 400px;
			}	

			.example.reordering .element {
				width: auto;
				height: auto;
			}

			.example.reordering .element input {
				width: 4em;
			}
		</style>

		<script>
			const orderContainer = document.querySelector('.example.reordering .container');

			const orderDirectionSelect = document.getElementById('order-flex-direction');
			orderDirectionSelect.addEventListener('change', () => {
				orderContainer.style.flexDirection = orderDirectionSelect.value;
			});
			orderDirectionSelect.value = 'row';

			const orderWrapSelect = document.getElementById('order-flex-wrap');
			orderWrapSelect.addEventListener('change', () => {
				orderContainer.style.flexWrap = orderWrapSelect.value;
			});
			orderWrapSelect.value = 'nowrap';

			document.querySelectorAll('.example.reordering .element input').forEach((input) => {
				input.value = 0;
				input.addEventListener('change', function () {
					this.parentElement.style.order = this.value;
				});
			});
		</script>

		<p>
			One word of warning though - when you change the display order like this, the document order remains the same. A screen reader 
			will read the elements in document order, and the tab order will follow the document order. This can lead to a confusing 
			experience for users. As such, I suggest your treat these order-changing properties with extreme caution.
		</p>

		<h4>Can I use it?</h4>

		<p>
			Finally, the question I'm sure is burning everyone's lips: how well supported is <code>display: flex</code>? The answer is 
			"very well". All the flex-related properties are 100% supported by all modern browsers, and IE.
		</p>

		<figure class="example">
			<img src="images/flexbox-support.png" alt="can i use support table for flexbox, showing support in all major browsers">
			<figcaption>Source: <a href="https://caniuse.com/#feat=flexbox">Can I Use</a></figcaption>
		</figure>

		<p>
			However, there are a couple of known bugs in IE that aren't likely to be fixed.
		</p>
		<ul>
			<li>
				If the content of your flex container is overflowing unexpectedly, try setting <code>max-width: 100%</code> on
				the container.
			</li>
			<li>
				The <code>flex-basis</code> value in the <code>flex</code> shorthand requires a unit, even when it's 0. So you'll 
				need to do something like <code>flex: 1 0 0%</code>
			</li>
		</ul>
		<p>
			For a full list of known bugs, refer to the Known Issues tab on the <a href="https://caniuse.com/#feat=flexbox">Flexbox page on 
			Can I Use</a>.
		</p>

		<p>
			If you're looking for any more help with flex, then you should check out the definitive guide: 
			CSS Tricks' <a href="https://css-tricks.com/snippets/css/a-guide-to-flexbox/">Complete Guide to Flexbox</a>.
		</p>

		<h3>Grid</h3>

		<p>
			Grid is perhaps the most useful CSS layout available. It allows us to create dynamic, responsive, two-dimensional layouts.
			This is not to say that we don't need flexbox anymore though! It's often simpler to setup a flex layout than a grid, and there are 
			some things you can do in flexbox that you just can't manage in grid. Both are useful, and have their place. However, grid does 
			simplify some of the things we used to rely on flexbox for.
		</p>

		<p>
			Like flexbox, the <code>display: grid</code> property is applied to the container element, and affects the layout of the children 
			of the container. Unlike flexbox, the grid exists independent of the elements within it. The grid cells defined in CSS exist 
			whether they contain any content or not (although they can't be styled, beyond setting their size). You can see this by using 
			the grid inspector in Firefox. (I highly recommend using Firefox for all your grid-related development needs. The grid inspector 
			is absolutely invaluable.)
		</p>

		<div class="example grid dev-tools">

		</div>

		<style>
			.example.dev-tools {
				grid-template-columns: 1fr 1fr;
				grid-template-rows: 1fr 1fr;
				height: 400px;
			}
		</style>

		<p>To use the grid inspector in Firefox</p>
		<ol>
			<li>Right-click on the example above and select Inspect Element</li>
			<li>
				Click on the grid tag beside the element in the Inspector.
				<img src="images/grid-tag.png" alt="Location of grid tag in Inspector">
			</li>
		</ol>

		<p>You should end up with something like this</p>

		<figure class="example">
			<img src="images/grid-inspector.png" alt="grid with grid inspector turned on" style="border: 0">
		</figure>

		<p>
			Our example here defines a 2x2 grid, using three CSS properties.
		</p>

		<pre><code class="css">
display: grid;
grid-template-columns: 1fr 1fr;
grid-template-rows: 1fr 1fr;
		</code></pre>

		<p>
			<code>display: grid</code> makes our container a grid. <code>grid-template-columns</code> takes a list of widths. It will create 
			a column of the given width for each width in the list. In our case, we've got two columns, each 1fr wide.
			<code>grid-template-rows</code> takes a list of heights and creates a row with the given height for each height in the list. So 
			we've got two rows, each 1fr high. And, altogether, we've got a 2x2 grid, where each cell is 1fr x 1fr.
		</p>

		<h4>What the fr?</h4>

		<p>
			At this point, you might be wondering what an <code>fr</code> is. This is a good question. <code>fr</code> stands for "fraction
			of the available space". It works a lot like <code>flex-grow</code> in flexbox. To calculate the widths of the columns above,
			the browser will
		</p>
		<ol>
			<li>Work out how much space there is altogether. Let's call it 100%.</li>
			<li>Count how many frs there are: 1fr + 1fr = 2frs. Easy!</li>
			<li>Divide the total space between the number of frs: 100% / 2frs = 50%/fr</li>
		</ol>

		<p>So, in our example, each column is going to be 50% of the width of the container.</p>

		<p>
			This example is a little simplistic though. We could also have different sized columns - say 
			<code>grid-template-columns: 4fr 1fr</code>. In this case, there are 5frs altogether, so each fr receives 20% of the space
			(100% / 5 = 20%). The first column is 4frs wide, so it receives 80% (20% x 4 = 80%). The second column is 1fr, so it just gets 20%.
		</p>

		<figure class="example multi-fr">
			<div class="container fake-grid-inspector">
				<div class="cell"></div>
				<div class="cell"></div>
				<div class="cell"></div>
				<div class="cell"></div>
			</div>
		</figure>
		<style>
			.fake-grid-inspector {
				--grid-purple: #9400ff;
				display: grid;
				border: 1px solid var(--grid-purple);
				height: 300px;
				border-radius: 0;
			}
			.multi-fr .container {
				grid-template-columns: 4fr 1fr;
			}

			.fake-grid-inspector .cell {
				width: 100%;
				height: 100%;
				border: 0 dashed var(--grid-purple);
			}
			.fake-grid-inspector .cell:nth-child(2n - 1) {
				border-right-width: 1px;
			}
			.fake-grid-inspector .cell:nth-last-child(n - 2) {
				border-bottom-width: 1px;
			}
 		</style>

		<p>
			We can also mix units, like <code>grid-template-columns: 100px 1fr</code>. In this case, the first column will always be 100px 
			wide, no matter the size of the container. The second column will take up the remaining space.
		</p>

		<figure class="example mixed-fr">
			<div class="container fake-grid-inspector">
				<div class="cell"></div>
				<div class="cell"></div>
				<div class="cell"></div>
				<div class="cell"></div>
			</div>
		</figure>
		<style>
			.mixed-fr .container {
				grid-template-columns: 100px 1fr;
			}
		</style>

		<p>
			So, why do we use frs instead of just sticking with percentages? Basically, the maths is easier. You don't need to use <code>calc()</code>
			to mix percentages and fixed units. You can't get the maths wrong and end up with more than 100%. And it makes it super easy to add and remove columns 
			without needing to recalculate everything, which also works well in responsive designs, where you might have different numbers of 
			columns on different size screens. There are also a couple of other advantages we'll get to later.
		</p>

		<h4>Adding elements</h4>

		<p>
			Ok, so this is all well and good, but a grid with nothing in it is pretty boring. So let's see what happens when we add some 
			elements.
		</p>

		<div class="example grid placing-elements">
			<div class="element">1</div>
			<div class="element">2</div>
			<div class="element">3</div>
		</div>

		<style>
			.placing-elements {
				grid-template-columns: 1fr 1fr;
				grid-template-rows: 1fr 1fr;
				height: 400px;
			}

			.placing-elements .element {
				width: 100px;
				height: 100px;
			}

			.placing-elements .element {
				font-size: 2em;
				font-weight: bold;
				text-align : center;
			}
		</style>

		<p>
			You can see the elements get placed along the first row, until that row fills up. Then we start filling up the next row.
			And so on until we run out of elements. If we prefer to fill up the columns first, we can do that by setting 
			<code>grid-auto-flow: column</code>.
		</p>

		<div class="example">
			<div class="controls">
				<input type="radio" name="grid-auto-flow" id="auto-flow-row" value="row">
				<label for="auto-flow-row">grid-auto-flow: row</label>
				<input type="radio" name="grid-auto-flow" id="auto-flow-column" value="column">
				<label for="auto-flow-column">grid-auto-flow: column</label>	
			</div>
			<div class=" placing-elements container grid" style="margin-top: 10px">
				<div class="element">1</div>
				<div class="element">2</div>
				<div class="element">3</div>	
			</div>
		</div>

		<style>
			.controls {
				display: flex;
				align-items: center;
			}
			.controls input, .controls select {
				margin-right: 5px
			}
			.controls label {
				margin-right: 10px;
			}
		</style>


		<script>
			const container = document.querySelector('.placing-elements.container');
			document.querySelectorAll('input[id^=auto-flow').forEach((input) => {
				input.addEventListener('change', function () {
					container.style.gridAutoFlow = this.value;
				});
			});
			document.getElementById('auto-flow-row').checked = true;
		</script>

		<p>
			Each element is placed at the start of the cell. In a left-to-right, top-to-bottom script, this is going to be the top left. 
			In a right-to-left script, it would be the top right. And so on.
		</p>

		<p>
			We can change the vertical positioning of an element within its cell, just like we change the vertical position of an 
			item in a flexbox - using <code>align-items</code> or <code>align-self</code>.
			<code>align-items</code> is applied to the container, and changes the position of all elements in the grid. 
			<code>align-self</code> is applied to the item, and just changes the position of that item. <code>align-self</code> will 
			override <code>align-items</code>.
		</p>

		<figure class="example">
			<div class="container grid alignment">
				<div class="element">
					<code>align-self: unset</code>
				</div>
				<div class="element" style="align-self: flex-end">
					<code>align-self: flex-end</code>
				</div>
				<div class="element" style="align-self: center">
					<code>align-self: center</code>
				</div>
			</div>
			<figcaption>
				The grid container has <code>align-items: flex-start</code>
			</figcaption>
		</figure>

		<style>
			.grid.alignment {
				grid-template-columns: 1fr 1fr;
				grid-template-rows: 200px 200px;
				align-items: flex-start;
			}
			.grid.alignment .element {
				align-self: unset;
			}
		</style>

		<p>
			Unlike with flexbox, we can also change the horizontal positioning of an element within its cell.
			We do this via <code>justify-items</code> and <code>justify-self</code>.
			<code>justify-items</code> is applied to the container, and changes the position of all elements in the grid. 
			<code>justify-self</code> is applied to the item, and just changes the position of that item. <code>justify-self</code> will 
			override <code>justify-items</code>.
		</p>

		<figure class="example">
			<div class="container grid justification">
				<div class="element">
					<code>justify-self: unset</code>
				</div>
				<div class="element" style="justify-self: flex-end">
					<code>justify-self: flex-end</code>
				</div>
				<div class="element" style="justify-self: center">
					<code>justify-self: center</code>
				</div>
			</div>
			<figcaption>
				The grid container has <code>justify-items: flex-start</code>
			</figcaption>
		</figure>

		<style>
			.grid.justification {
				grid-template-columns: 1fr 1fr;
				grid-template-rows: 200px 200px;
				justify-items: flex-start;
			}
			.grid.justification .element {
				justify-self: unset;
				height: auto;
			}
		</style>

		<p>
			We can also set the <i>size</i> of the element, relative to its cell. If you set the width or height of a grid item as a 
			percentage, it will be calculated as a percentage of the size of the <i>cell</i>, rather than the parent container 
			(which is how it usually works).
		</p>

		<figure class="example relative-size">
			<div class="container placing-elements grid resize">
				<div class="element" style="width: 100%; height: 100%">
					<code>width: 100%;</code> 
					<code> height: 100%;</code>
				</div>
				<div class="element" style="width: 80%; height: 80%">
					<code>width: 80%;</code><br>
					<code>height: 80%;</code>
				</div>
				<div class="element" style="width: 40%; height: auto; height: auto">
					<code>width: 40%;</code>
					<code>height: auto;</code>
				</div>	
			</div>
			<figcaption>
				You can resize the container to see how it affects the sizes of the elements.
			</figcaption>
		</figure>

		<style>
			.relative-size .container {
				align-items: center;
				justify-items: center;
			}
			.min-content .element {
				min-width: min-content;
			}
		</style>

		<p>
			Unlike in flexbox, grid item <i>will</i> shrink down below their min-content size, causing their content to overflow.
			To stop this happening, you can set <code>min-width: min-content</code>.
		</p>

		<figure class="example relative-size">
			<div class="container placing-elements grid resize min-content">
				<div class="element" style="width: 100%; height: 100%">
					<code>width: 100%;</code> 
					<code> height: 100%;</code>
				</div>
				<div class="element" style="width: 80%; height: 80%">
					<code>width: 80%;</code><br>
					<code>height: 80%;</code>
				</div>
				<div class="element" style="width: 40%; height: auto; height: auto">
					<code>width: 40%;</code>
					<code>height: auto;</code>
				</div>	
			</div>
			<figcaption>
				This time, all the elements have <code>min-width: min-content</code>, so they won't shrink too much and overflow.
				Instead, the container itself will overflow.
			</figcaption>
		</figure>

		<h4>Adding some space</h4>

		<p>
			We can also use percentage-based sizing to create layouts with a bit of breathing room. Just set the element sizes to around 
			90%, centre-align and justify them, and we get a nice, consistent layout, with a bit of spacing.
		</p>

		<div class="example grid placing-elements percent-gap resize resize-both">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</div>

		<style>
			.resize.resize-both {
				resize: both;
			}
			.percent-gap {
				align-items: center;
				justify-items: center;
			}
			.percent-gap .element {
				width: 90%;
				height: 90%;
			}
		</style>

		<p>
			This works, but it's not great. If the elements aren't square, then the gaps are different horizontally and vertically. There's also 
			a gap <i>around</i> the elements that's half the size of the gap <i>between</i> the elements, which might be problematic, depending 
			on your design. (Have a look with the grid inspector if you don't know what I mean.)
		</p>

		<p>
			Fortunately, there is a better way! We can specify how much space we want between elements using the <code>grid-gap</code> property.
		</p>

		<p>
			You can set <code>grid-gap</code> to be a specific measurement, like 10px, or 1em. Or you can use a percentage. The percentage will be 
			calculated from the width of the entire grid for the column gaps, and the height of the entire grid for the row gaps. You'll get different 
			spacing for your rows and columns if your grid isn't square. You can also set the row and column gaps differently deliberately by 
			passing in two values: <code>grid-gap: 10px 20px</code>. The first value is the gap between the rows. The second value is the gap between the columns.
		</p>

		<div class="example grid-gap">
			<div class="controls">
				<label for="grid-gap">grid-gap</label>
				<input type="text" id="grid-gap" placeholder="10px 20px">	
			</div>
			<div class="container grid placing-elements resize resize-both">
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>
			</div>
		</div>

		<style>
			.controls {
				margin-bottom: 20px;
			}
			.grid-gap .container {
				grid-gap: 10px 20px;
			}
			.grid-gap .container .element {
				width: 100%;
				height: 100%;
			}
		</style>

		<script>
			const gridGapContainer = document.querySelector('.grid-gap .container');
			const gridGap = document.getElementById('grid-gap');
			gridGap.addEventListener('change', function () {
				gridGapContainer.style.gridGap = this.value;
			});
			gridGap.value = '10px 20px';
		</script>

		<p>
			<code>grid-gap</code> is another reason to prefer fr over percentages. fr will take the gap into account automatically. 
			While it's entirely possible to do this with percentages, using <code>calc()</code>, it's far, far more difficult.
		</p>

		<h4>Covering more ground</h4>

		<p>
			On top of all this, we can also place elements so that they take up more than one cell. We can do this by making them 
			span multiple rows and/or multiple columns. We are limited to rectangular shapes though.
		</p>

		<p>
			There are a couple of ways we can super-size our elements.
		</p>
		<ul>
			<li>Specify the start and end row and column of our element</li>
			<li>Specify how many rows and columns we want our element to cover</li>
			<li>Use named areas</li>
		</ul>

		<p>
			If we want our element to go from column 2, row 3 to column 5, row 4, we can do that by specifying the <code>grid-row</code>
			and <code>grid-column</code>
		</p>

		<pre><code class="css">
			.element {
				grid-row: 3 / 5;
				grid-column: 2 / 6;
			}			
		</code></pre>

		<style>
			.row-column {
				grid-template: repeat(5, 1fr) / repeat(5, 1fr);
				height: 600px;
				width: 600px;
			}
			.row-column .element {
				width: 100%;
				height: 100%;
			}
			.row-column .highlight {
				grid-row: 3 / 5;
				grid-column: 2 / 6;
			}
		</style>

		<div class="example grid row-column">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element highlight"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</div>

		<p>
			The numbers used to specify the start and endpoint actually refer to the lines <i>between</i> the cells. So 
			<code>grid-column: 1 / 2</code> will result in an element that goes from the first line (at the edge of the grid), to the 
			second line. It will only take up one column. You need to calculate your endpoint as your start point + the number of 
			cells you want to cover.
		</p>

		<p>You can turn on line numbers in the grid inspector, under the Layout tab.</p>

		<img src="images/line-numbers.png" alt="you can turn on line numbers in the grid inspector, under the Layout tab">

		<p>
			The grid lines are also numbered in the reverse direction, using negative numbers. So we can refer to the last 
			grid lines as -1, the second last as -2 and so on. You can see both the positive and negative numbers in the 
			grid inspector.
		</p>

		<img src="images/showing-line-numbers.png" alt="grid inspector shows positive and negative numbers">
			
		<p>
			This means that we can position an element in the last two rows 
			and last two columns of a grid, no matter how many cells there are!
		</p>

		<pre><code class="css">
			.big-grid {
				display: grid;
				grid-template-columns: repeat(10, 1fr);
				grid-template-rows: repeat(10, 1fr);
			}

			.big-grid .element:nth-child(1) {
				grid-row: 2 / 4;
				grid-column: 2 / 4;
			}
			.big-grid .element:nth-child(2) {
				grid-row: 2 / 5;
				grid-column: -2 / 6;
			}
			.big-grid .element:nth-child(3) {
				grid-row: 6;
				grid-column: 1 / -1;
			}
			.big-grid .element:nth-child(4) {
				grid-row: -1 / -4;
				grid-column: -1 / -4;
			}
		</code></pre>

		<figure class="example grid big-grid">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</figure>
		<style>
			.big-grid {
				grid-template-columns: repeat(10, 1fr);
				grid-template-rows: repeat(10, 1fr);
				width: 600px;
				height: 600px;
			}
			.big-grid .element {
				width: 100%;
				height: 100%;
			}

			.big-grid .element:nth-child(1) {
				grid-row: 2 / 4;
				grid-column: 2 / 4;
			}
			.big-grid .element:nth-child(2) {
				grid-row: 2 / 5;
				grid-column: -2 / 6;
			}
			.big-grid .element:nth-child(3) {
				grid-row: 6;
				grid-column: 1 / -1;
			}
			.big-grid .element:nth-child(4) {
				grid-row: -1 / -4;
				grid-column: -1 / -4;
			}
		</style>

		<p>
			Notice that it doesn't matter which order you put the start and end values in. Your element will appear between the 
			two named lines - it's not going to try and wrap around the outside or anything wild like that.
		</p>

		<p>
			We also have the option to specify how big we want our element to be, without necessarily knowing what the 
			start and end position is going to be, using the <code>span</code> keyword.
		</p>

		<pre><code class="css">
.element {
	grid-column: 2 / span 2; // element will begin at line 2, and span 2 columns
}

.element {
	grid-row: span 2 / -1; // element will span 2 rows, ending at the last row
}

.element {
	grid-column: span 3; // element will be placed normally, but span 3 columns
}
		</code></pre>

		<figure class="example">
			<div class="container grid span">
				<div class="element highlight"></div>
				<div class="element"></div>
				<div class="element"></div>
				<div class="element highlight"></div>
				<div class="element highlight"></div>
				<div class="element"></div>
				<div class="element"></div>	
			</div>
		</figure>
		<style>
			.grid.span {
				grid-template-rows: repeat(4, 1fr);
				grid-template-columns: repeat(4, 1fr);
				width: 600px;
				height: 600px;
			}

			.grid.span .element {
				width: 100%;
				height: 100%;
			}

			.grid.span .element:nth-child(1) {
				grid-column: 2 / span 2;
			}

			.grid.span .element:nth-child(4) {
				grid-row: span 2 / -1;
			}

			.grid.span .element:nth-child(5) {
				grid-column: span 3;
			}
		</style>

		<p>
			You'll notice that the grid just kind of slots the auto-placed elements into the next available cell after 
			each element that has a fixed position. You can change it so that elements are placed as close to the start 
			of the grid as possible, using <code>grid-auto-flow: dense</code>.
		</p>

		<figure class="example">
			<div class="container grid span dense">
				<div class="element highlight"></div>
				<div class="element"></div>
				<div class="element"></div>
				<div class="element highlight"></div>
				<div class="element highlight"></div>
				<div class="element"></div>
				<div class="element"></div>	
			</div>
			<figcaption>
				The same grid as above, with <code>grid-auto-flow: dense.</code>
			</figcaption>
		</figure>
		<style>
			.grid.span.dense {
				grid-auto-flow: dense;
			}
		</style>

		<p>
			For a more indeth discussion of how this works, check out the 
			<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Grid_Layout/Auto-placement_in_CSS_Grid_Layout">
				MDN article on Auto-placement in CSS Grid Layout
			</a>	
		</p>

		<p>
			The final way that we can cause an element to cover several cells is by using <code>grid-template-areas</code> with
			<code>grid-area</code>. <code>grid-template-areas</code> allows us to attach labels to grid cells. We can then 
			use <code>grid-area</code> to declare which cell(s) an element will occupy.
		</p>

		<p>It looks something like this:</p>

		<pre><code class="html">
			&lt;div class="container"&gt;
				&lt;div class="a"&gt;A&lt;/div&gt;
				&lt;div class="b"&gt;B&lt;/div&gt;
				&lt;div class="c"&gt;C&lt;/div&gt;
			&lt;/div&gt;
		</code></pre>

		<pre><code class="css">
			.container {
				display: grid;
				grid-template-columns: 1fr 1fr;
				grid-template-rows: 1fr 1fr;
				grid-template-areas: 'a a'
				                     'b c';
			}
			.a {
				grid-area: 'a';
			}
			.b {
				grid-aread: 'b';
			}
			.c {
				grid-area: 'c';
			}
		</code></pre>

		<figure class="example grid template-areas">
			<div class="element a">A</div>
			<div class="element b">B</div>
			<div class="element c">C</div>	
		</figure>

		<style>
			.template-areas {
				grid-template-columns: 1fr 1fr;
				grid-template-rows: 1fr 1fr;
				grid-template-areas: 'a a' 'b c';
				width: 400px;
				height: 400px;
			}

			.template-areas .element {
				width: 100%;
				height: 100%;
				font-size: 60px;
				display: flex;
				align-items: center;
			  justify-content: center;
			}

			.template-areas .a {
				grid-area: a;
			}
			.template-areas .b {
				grid-area: b;
			}
			.template-areas .c {
				grid-area: c;
			}
		</style>

		<p>
			In the <code>grid-template-areas</code> property, each string represents a row of the grid.
			The string consists of space-separated tokens. Each token represents a column. The tokens 
			can be whatever name you like. You can use single characters (which can make it a bit easier 
			to represent the grid in the CSS), or you can use meaningful names.
		</p>

		<p>
			The items labelled by <code>grid-area</code> will then be placed in the corresponding position on the grid.
			If a token is repeated, then the item will span multiple cells, like <code>A</code> above. The repeated tokens need to be adjacent though, 
			and resulting area has to be rectangular in shape. You can also turn on the grid area labels in the grid inspector - 
			the option is in the Layout tab.
		</p>

		<img src="images/grid-areas.png" alt="you can turn on the grid area labels in the grid inspector">

		<p>
			<code>grid-areas</code> can be a handy way to make your CSS a little more semantic.
		</p>

		<pre><code class="css">
grid-template-areas: 'heading heading heading'
										 'nav     content content'
										 '.       content content'
										 'footer  footer  footer'
		</code></pre>

		<p>A '.' denotes an empty cell.</p>

		<p>
			While all these properties provide a very powerful way of rearranging your grid, you should bear in mind the same caveats 
			as when reordering flexboxes. The tab order will follow the document order, not the visible order, so extensively
			rearranged elements can result in an inaccessible experience. For this reason, I'd suggest preferring a single 
			<code>span</code> value over specifying start and end values, and ensuring that your <code>grid-template-areas</code>
			follow your source order fairly closely.
		</p>

		<h4>The implicit grid</h4>

		<p>
			Everything we've looked at so far has assumed that we know how many elements are going to be in our grid. 
			Often though, that isn't the case. Luckily, grid has us covered there too!
		</p>

		<p>
			If we add more elements than we have defined in our grid, the browser will just add another row to the grid 
			and continue adding elements there. (If you're using <code>grid-auto-flow: column</code>, then it will add a 
			new column instead.) Additional rows or columns that are added like this are called the implicit grid. 
			(As opposed to the explicit grid, which is rows/columns that you set up... well... explicitly.) 
		</p>

		<p>The grid inspector depicts implicit grid cells with a dotted, rather than dashed line.</p>

		<img src="images/implicit-grid.png" alt="The grid inspector shows explicit grid cells with a dasehd line, implicit cells with a dotted line">

		<p>
			Let's start with the most extreme example. We've defined a grid container, but not specified any rows or columns.
		</p>

		<pre><code class="css">
.container {
	display: grid;
	width: 500px;
	height: 500px;
}
		</code></pre>

		<figure class="example grid implicit">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</figure>
		<style>
			.grid.implicit {
				width: 500px; 
				height: 500px;
			}
		</style>

		<p>
			We get a grid with one column per row. The single column stretches for the entire width of the row. Each row has a height 
			of <code>auto</code>. <code>auto</code> is a special value that means the element will have a <code>min-height</code> of 
			<code>min-content</code>, and a <code>max-height</code> of <code>1fr</code>. Basically, the elements are going to fill 
			the available space, without overflowing.
		</p>

		<p>
			We can specify the height of our automatically generated rows using <code>grid-auto-rows</code>.
		</p>

		<pre><code class="css">
.container {
	display: grid;
	width: 500px;
	height: 500px;
	grid-auto-rows: 100px;
}
		</code></pre>

		<figure class="example grid implicit" style="grid-auto-rows: 100px">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</figure>

		<p>
			Now our rows don't fill up all the available space! We can control the spacing of these auto-generated rows using 
			the same <code>align-content</code> property we used in flexbox.
		</p>

		<pre><code class="css">
.container {
	display: grid;
	width: 500px;
	height: 500px;
	grid-auto-rows: 100px;
	align-content: flex-end;
}
		</code></pre>

		<figure class="example grid implicit" style="grid-auto-rows: 100px; align-content: flex-end">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</figure>

		<p>
			If we're automatically adding columns, (because we've got <code>grid-auto-flow: column</code>), then we can
			use <code>justify-content</code> to control the spacing of the columns.
		</p>

		<p>
			We can also combine explicit grid with implicit grid.
		</p>

		<pre><code class="css">
.container {
	display: grid;
	grid-template-columns: 200px 1fr;
	grid-template-rows: 50px 150px 60px;
	grid-auto-rows: 100px;
}
		</code></pre>

		<figure class="example grid implicit-mixed">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</figure>
		<style>
			.implicit-mixed {
				grid-template-columns: 200px 1fr;
				grid-template-rows: 50px 150px 60px;
				grid-auto-rows: 100px;
			}
		</style>

		<p>
			One thing to remember about using the implicit grid is that you can't use negative numbers to place elements at
			the end of rows or columns. The browser has no way of knowing in advance how many rows and columns it's going 
			to need, so it has no way to calculate where the last row or column is.
		</p>

		<h4>Making it dynamic</h4>

		<p>
			Grid also has some other nice tricks for building dynamic and responsive layouts. 
			For example, sometimes, we don't actually know how many columns we want. We just want 
			as many columns as will fit, given all the columns are a certain width. We can do this 
			using the <code>repeat()</code> function, with the <code>auto-fit</code> or <code>auto-fill</code>
			keywords.
		</p>

		<p>
			The <code>repeat()</code> function can be used with <code>grid-template-columns</code> and <code>grid-template-rows</code>
			to simplify writing repetitive templates. You pass it a number of repetitions and a size. So 
			<code>grid-template-columns: repeat(4, 100px)</code> is the same as <code>grid-template-columns: 100px 100px 100px 100px</code>.
		</p>

		<p>
			The magic begins, though, when we combine <code>repeat()</code> with the <code>auto-fit</code> and <code>auto-fill</code>
			keywords. <code>repeat(auto-fit, 100px)</code> means "fit as many items as you can in columns 100px wide".
		</p>

		<div class="example grid resize auto-fit">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</div>

		<style>
			.example.auto-fit {
				grid-template-columns: repeat(auto-fit, 100px);
			}
			.example.auto-fit .element {
				height: 100px;
			}
		</style>

		<p>
			You can see that in a large enough container, the browser will create a 100px wide column for each element, and they'll all 
			appear in a single row. If you shrink the container, so it's too narrow to fit six 100px wide columns, then one of the columns 
			will disappear, and the element in that column will wrap to the next row.
		</p>

		<p>
			What about <code>auto-fill</code>? <code>repeat(auto-fill, 100px)</code> means "create as many 100px-wide columns as you can". 
			The difference is very subtle, and the result is going to look identical, when using fixed-width columns.
		</p>

		<div class="example grid resize auto-fill">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</div>

		<style>
			.example.auto-fill {
				grid-template-columns: repeat(auto-fill, 100px);
			}
			.example.auto-fill .element {
				height: 100px;
			}
		</style>

		<p>
			While the two may look identical, there is a slight difference. If you check out the <code>auto-fill</code> example using grid 
			inspector, you will see that the browser has created a bunch of implicit columns. It has, in effect, <i>filled</i> the row with 
			columns. This difference becomes more interesting when we use dynamically-sized columns.
		</p>

		<p>
			You're already familiar with one type of dynamic sizing - the <code>fr</code> unit. However, you can't use frs with <code>auto-fit</code>
			and <code>auto-fill</code>! If you did, you'd essentially be telling the browser to place your items in an unknown number of columns of 
			an unknown width. Browsers are clever, but they're not that clever.
		</p>

		<p>
			However! We do have another alternative. The <code>minmax()</code> function allows us to provide a <i>range</i> of sizes for our cells.
			<code>grid-template-columns: repeat(4, minmax(100px, 200px)</code> will create four columns, which will shrink down to 100px wide, or 
			grow as large as 200px wide, depending on the size of the container.
		</p>

		<div class="example grid resize bounded-minmax">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</div>

		<style>
			.example.bounded-minmax {
				grid-template-columns: repeat(4, minmax(100px, 200px));
			}
			.example.bounded-minmax .element {
				height: 100px;
			}
		</style>

		<p>
			A slightly more interesting use of <code>minmax()</code> is to combine it with <code>fr</code> to create columns that have a minimum 
			size, but stretch to fill all the available space. For example, <code>grid-template-columns: repeat(4, minmax(100px, 1fr))</code>.
		</p>

		<div class="example grid resize minmax-fr">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</div>

		<style>
			.example.minmax-fr {
				grid-template-columns: repeat(4, minmax(100px, 1fr));
			}
			.example.minmax-fr .element {
				height: 100px;
			}
		</style>

		<p>
			This isn't super great though, as the grid is going to overflow or be cut off when the container is smaller than 400px wide, and we're 
			going to end up with massively wide columns in larger containers, which could look a bit weird, depending on our design.
		</p>

		<p>
			What we really want is the best of both worlds. We want as many 100px wide columns as will fit in the container, and we want them 
			to stretch to fill the available space. It probably won't surprise you to learn that we can achieve that by combining 
			<code>auto-fit/auto-fill</code>, <code>minmax</code>, and <code>fr</code>.
		</p>

		<pre><code class="css">
grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
		</code></pre>

		<div class="example grid resize autofit-minmax-fr">
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
			<div class="element"></div>
		</div>

		<style>
			.example.autofit-minmax-fr {
				width: 150px;
				grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
			}
			.example.autofit-minmax-fr .element {
				height: 100px;
			}
		</style>

		<p>
			You can see here, as the container width increases, the cells grow to fill it, right up until the point where the container 
			is wide enough to fit two 100px columns. At that point, it switches to a two-column layout. Then, the elements keep growing,
			until there's enough space to fit three columns. And so on, and so forth. As I'm sure you can imagine, this is a nifty way 
			of creating responsive layouts, which respond to the size of the container, rather than the viewport (and which don't rely 
			on media queries).
		</p>

		<p>
			The difference between <code>auto-fit</code> and <code>auto-fill</code> becomes apparent once the container is wide enough 
			to fit all the elements + 1 in a single row.
		</p>

		<pre><code class="css">
grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
		</code></pre>

		<figure class="example">
			<div class="example grid resize autofill-minmax-fr">
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>
				<div class="element"></div>
			</div>
			<figcaption>
				Grid with <code>auto-fill</code>
			</figcaption>
		</figure>

		<style>
			.example.autofill-minmax-fr {
				grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
			}
			.example.autofill-minmax-fr .element {
				height: 100px;
			}
		</style>

		<p>
			In the first example - the <code>auto-fit</code> one - the elements kept stretching to fill all the available space.
			In the second example - the <code>auto-fill</code> one - they won't stretch much beyond their minimum size, leaving a 
			a large gap at the end of the row.
		</p>

		<p>
			The reason for this becomes apparent if we look at the <code>auto-fill</code> example 
			with the grid inspector.
		</p>

		<img src="images/auto-fill.png" alt="the gap at the end of the row is filled with empty cells">

		<p>
			Remember, <code>auto-fill</code> keeps creating columns, even if there's nothing to go in them. Once the container is 
			wide enough to fit all our items + 1, it creates an empty implicit column 100px - leaving an apparent gap at the end of 
			the row. As the container continues to grow, the columns will stretch to fill the available space again, but only until 
			there is enough room to add another column. Then they will all snap back to their minimum size, and the browser will add 
			another implicit column.
		</p>

		<h4>But, can I use it?</h4>

		<p>
			So that just leaves one question burning everybody's lips - can I use it? Well, the answer is yes, mostly.
		</p>

		<img src="images/can-i-use-grid.png" alt="Can I Use table for grid">

		<p>
			Globally, at least 91% of users are using a browser which supports the current grid spec. As long as you don't have a requirement 
			to support IE, you're fine. (QQ browser accounts for only 0.2% of global usage, so it's not really worth worrying about, unless you've 
			got a large user base in China. As always, you should check the usage figures for your specific domain.)
		</p>

		<p>
			But what if you do need to support IE? Well, you've got a couple of options. IE <i>does</i> support <i>a</i> version of the grid spec - 
			in fact it was the first browser to support grid at all. It lacks some of the auto-placement stuff, and requires a vendor prefix.
			Depending on your needs, it might be possible to just build your grid as you would normally, and use autoprefixer to add the 
			necessary prefixes.
		</p>

		<figure class="example">
			<pre><code>
.links {
	display: -ms-grid;
	display: grid;
	-ms-grid-columns: minmax(140px,220px) 1fr;
	grid-template-columns: minmax(140px,220px) 1fr;
}	

.links > * {
	-ms-grid-row-align: center;
	align-self: center;
}
			</code></pre>
			<figcaption>
				Modern CSS updated to include IE-friendly CSS by autoprefixer. The code sets <code>align-self</code> on all the children, 
				rather than using <code>align-items</code>, because IE doesn't support <code>align-items</code>. Autoprefixer will warn you 
				about things like this.
			</figcaption>
		</figure>
		
		<p>		
			For more information on using autoprefixer, have a look at the 
			<a href="https://css-tricks.com/css-grid-in-ie-debunking-common-ie-grid-misconceptions/">
			series on using grid in IE on CSS tricks
			</a>.
		</p>

		<p>
			The other option is to use fallbacks. While IE's support of grid is a little lacking, it does support flexbox quite well. While 
			you're not going to be able to achieve quite the same schmick two-dimensional layouts with flexbox as you are with grid, you 
			can often make a workable approximation. So, rather than depriving <i>all</i> your users of the fancy grid layout, you give the 
			users on modern browers the grid layout, and you give the IE users the flexbox layout. This is called progressive enhancement. It's 
			just like the idea that we give users on mobile phone a small, simplified layout, and add more features as the screen gets larger and 
			can accomodate more stuff.
		</p>

		<p>
			How does it work? The simplest version is to rely on the fact that browsers ignore CSS that they don't understand, and always use 
			the last value of a property. So if we do something like...
		</p>

		<pre><code class="css">
.container {
	/* for IE */
	display: flex;
	flex-wrap: wrap;
	
	/* for everyone else */
	display: grid;
	grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
}
		</code></pre>

		<p>
			IE is going to use the flex values, and ignore the grid values, because it doesn't understand them. Other browsers will understand 
			the flex values, but they'll immediately be overriden by the grid values, which appear later in the stylesheet.
		</p>

		<p>
			This works in many cases, but can cause issues when you need to set a property that is valid in both cases, but means something different.
			For example, if we added 
		</p>

		<pre><code class="css">
.item {
	width: 100%
}
		</code></pre>

		<p>
			to the above example, the item would be 100% of the width of the <i>container</i> in IE, but only 100% of the width of the cell in 
			other browsers. In these cases, we can use the <code>@supports</code> query. We pass the <code>@supports</code> query a CSS 
			rule, and it will only execute the rules inside the query if it understands the given rule. So we could do 
		</p>

		<pre><code class="css">
width: auto;

@supports(display: grid) {
	width: 100%;
}
		</code></pre>

		<p>
			Browsers which don't support <code>display: grid</code> (ie IE) will use a width of <code>auto</code>, while other browsers will use 
			a width of <code>100%</code>. (In the case of IE, it doesn't actually matter what you pass into the <code>@supports</code> query, 
			because IE doesn't event understand <code>@supports</code>, so it will ignore everything inside it, no matter what. But it can be useful for 
			providing fallbacks for other CSS properties, like <code>display: subgrid</code>, which is an exciting new grid feature currently 
			only available in Firefox.)
		</p>

		<p>
			Yes, this is a little more work than just creating a single layout for all browsers, but it does mean that all users are getting 
			the best possible experience available in the browser that they are using, and the >90% of users using modern browsers aren't 
			missing out due to the few users who aren't.
		</p>
		
		<h3 class="incomplete"><code>columns</code></h3>

		<h3 class="incomplete"><code>float</code></h3>

	</section>

	<section class="in-review">
		<h2 id="conclusion">Wrap up</h2>

		<p>
			Hopefully, all of this has given you some things to think about! The important thing to remember though is that, in 
			software, there isn't usually one right answer. Instead, it's about trade-offs. You need to think about how things 
			work in your particular situation, and decide on the best course of action yourself.
		</p>

		<p>
			If you'd like some more information about any of the topics we've covered, there are a heap of resources available 
			both online and offline. Here's some that I've found helpful.
		</p>

		<h3>Clean code</h3>
		<ul>
			<li><a href="https://www.goodreads.com/book/show/3735293-clean-code"><i>Clean Code</i></a> by Robert Martin</li>
			<li>
				Robert Martin (or "Uncle Bob") also has a <a href="https://blog.cleancoder.com/">blog</a>,
				where covers clean coding, test driven development, and whatever else takes his fancy.
			</li>
			<li>
				<a href="https://pragprog.com/book/tpp20/the-pragmatic-programmer-20th-anniversary-edition">
				<i>The Pragmatic Programmer</i></a> by David Thomas and Andrew Hunt provides more ideas to consider in your 
				software development (and was recently updated to a new edition).
			</li>
			<li>
				<a href="https://www.goodreads.com/book/show/4845.Code_Complete"><i>Code Complete</i></a> by Steve McConnell
				is one of those books that apparently every software developer "must" read. It covers complete software development 
				practices, rather than just clean coding. 
			</li>
			<li>
				<a href="https://github.com/ryanmcdermott/clean-code-javascript">The clean-code-javascript repository</a>
				contains the principles from the original <i>Clean Code</i> book, but with examples in JavaScript (the book's original examples are all  
				in C++).
			</li>
		</ul>

		<p>So yeah, apparently nobody has written a book on clean coding in the last twenty years. I'm not sure what to make of that.</p>

		<h3>Modern JavaScript</h3>
		<ul>
			<li>
				For a solid explanation into the core mechanisms of JavaScript, I highly recommend Kyle Simpson's You Don't Know JS Yet book series.
				They are availabe, online, completely for free, via the <a href="https://github.com/getify/You-Dont-Know-JS">
				You Don't Know JS Github repository</a>. There's a link in the repo with information on how to get them as a more traditional books as well.
			<li>
				If you'd prefer a more practical approach, you should check out 
				<a href="https://javascript30.com/">Wes Bos's JavaScript30</a> video course. This course is also available for free (although you 
				will need to sign up), and contains 30 short projects, showcasing a bunch of stuff you can do with vanilla JavaScript and browser APIs.
			</li>
			<li>
				I also quite enjoy @mpj's <a href="https://www.youtube.com/channel/UCO1cgjhGzsSYb1rsB4bFe4Q">Fun Fun Funtion</a> channel on YouTube. 
				He covers a bunch of different JavaScript topics, and is quite ridiculous.
			</li>
			<li>
				And finally, a great resource for keeping up to date with what's going on in the world of JavaScript (and CSS) is the 
				<a href="https://www.youtube.com/user/jsconfeu">JSConf YouTube channel</a>. Videos from JSConfs all around the world 
				are uploaded to this channel.
			</li>
		</ul>

		<h3>CSS</h3>

		<ul>
			<li>
				There are a heap of people doing wonderful work in the world of CSS. I always recommend starting out with 
				anything from <a href="https://jensimmons.com/">Jen Simmons</a> or 
				<a href="https://rachelandrew.co.uk/">Rachel Andrew</a>. 
			</li>
			<li>
				If you'd specifically like a book on layouts, check out Rachel's book,
				<a href="https://abookapart.com/products/the-new-css-layout">The New CSS Layout</a>. (Unfortunately, this one's not free.)
			</li>
			<li><a href="https://css-tricks.com/">CSS Tricks</a> is a great resource for how stuff works and how to achieve specific things in CSS.</li>
			<li>
				<a href="https://www.smashingmagazine.com/">Smashing Magazine</a> contains in-depth articles on web design and development. 
			</li>
		</ul>

		<p>
			And finally, the one resource that every web developer needs: <a href="https://developer.mozilla.org/en-US/">MDN</a> (Mozilla 
			Developer Networks). This site contains a reference for every HTML element, CSS property and JavaScript API in existence. It 
			also contains browser support tables for just about everything, as well as tutorials on things like 
			<a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility">accessibility</a>, and 
			<a href="https://developer.mozilla.org/en-US/docs/Learn/CSS/CSS_layout/Grids">grid</a>.
		</p>

		<p>
			And, if all that's not enough, my Twitter DMs are open at <a href="https://twitter.com/ErinJZimmer">@ErinJZimmer</a>.
			Feel free to drop me a line!
		</p>
	</section>
</body>
</html>